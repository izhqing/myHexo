{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/READMEen.mdown","path":"READMEen.mdown","modified":1,"renderable":0},{"_id":"source/README.mdown","path":"README.mdown","modified":1,"renderable":0},{"_id":"source/robots.txt","path":"robots.txt","modified":1,"renderable":0},{"_id":"themes/smackdown/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/smackdown/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/smackdown/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/smackdown/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/smackdown/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/smackdown/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/coderwall.png","path":"img/coderwall.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/delicious.png","path":"img/delicious.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/github.png","path":"img/github.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/facebook.png","path":"img/facebook.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/douban.png","path":"img/douban.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/google.png","path":"img/google.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/linkedin.png","path":"img/linkedin.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/img-loading.png","path":"img/img-loading.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/img-err.png","path":"img/img-err.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/mail.png","path":"img/mail.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/pinterest.png","path":"img/pinterest.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/pinboard.png","path":"img/pinboard.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/rss.png","path":"img/rss.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/qq.png","path":"img/qq.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/search.png","path":"img/search.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/stackoverflow.png","path":"img/stackoverflow.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/zhihu.png","path":"img/zhihu.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/weibo.png","path":"img/weibo.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/twitter.png","path":"img/twitter.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/js/instagram.js","path":"js/instagram.js","modified":1,"renderable":1},{"_id":"themes/smackdown/source/js/Counter.js","path":"js/Counter.js","modified":1,"renderable":1},{"_id":"themes/smackdown/source/js/jquery.lazyload.js","path":"js/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/smackdown/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/smackdown/source/js/mobile.js","path":"js/mobile.js","modified":1,"renderable":1},{"_id":"themes/smackdown/source/js/pc.js","path":"js/pc.js","modified":1,"renderable":1},{"_id":"themes/smackdown/source/js/particles.js","path":"js/particles.js","modified":1,"renderable":1},{"_id":"themes/smackdown/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/smackdown/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/smackdown/source/css/fonts/fontawesome-webfont.svgz","path":"css/fonts/fontawesome-webfont.svgz","modified":1,"renderable":1},{"_id":"themes/smackdown/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/smackdown/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/smackdown/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/smackdown/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/smackdown/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/smackdown/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/smackdown/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"bf60509a9ef5efeec32815d3360f81e995e63d63","modified":1477898739000},{"_id":"source/.DS_Store","hash":"6db64b8336fd3a77f692b9805bfe49f13e07cca4","modified":1477974045000},{"_id":"source/READMEen.mdown","hash":"8fca021d52a2d15efe559bb1f97f59575beb8089","modified":1477973781000},{"_id":"source/README.mdown","hash":"6f9ef4747aae8ef6fe298179f91f26ecbb5c3644","modified":1477973781000},{"_id":"source/robots.txt","hash":"ab5e82bf81cd2f1d491e0baa437a7c3a5ab8cfcb","modified":1477898739000},{"_id":"themes/smackdown/.DS_Store","hash":"b3d2717e1a9ce7263ea6bd225d7816c49cf8a90c","modified":1477973982000},{"_id":"themes/smackdown/.gitignore","hash":"eaa3d84cb77d92a21b111fd1e37f53edc1ff9de0","modified":1477973781000},{"_id":"themes/smackdown/README.md","hash":"6f9ef4747aae8ef6fe298179f91f26ecbb5c3644","modified":1477973781000},{"_id":"themes/smackdown/READMEen.md","hash":"8fca021d52a2d15efe559bb1f97f59575beb8089","modified":1477973781000},{"_id":"themes/smackdown/_config.yml","hash":"b55a7e08106deed534241773affb7c01ff85cefe","modified":1477973798000},{"_id":"themes/smackdown/package.json","hash":"00357ef6f24eb049074da81809e98f973f528cca","modified":1477973781000},{"_id":"source/_posts/npm-debug.log","hash":"dd97069124d6d576442ecfb8d4421b441ce5569a","modified":1477904977000},{"_id":"source/_posts/.DS_Store","hash":"8f43ee7bc2b1d1c1d1d2d7d076f19710c2611d27","modified":1477898791000},{"_id":"source/_posts/newHexo.md","hash":"b6a606c4c1cb0dc76e461f67039c319737873c81","modified":1477972871000},{"_id":"source/_posts/与服务端通信相关的兼容性问题.md","hash":"4e377633ab6a3fdb532a43196cfdacb71283db97","modified":1477898739000},{"_id":"source/_posts/与渲染混合类型相关的兼容性问题.md","hash":"66f71c285e5c050a5ad527e9220c0fdd9ff8d24e","modified":1477898739000},{"_id":"source/_posts/与脚本相关的兼容性问题.md","hash":"48e9d12c8c521e179b375edc7151f426eb84cf53","modified":1477898739000},{"_id":"source/_posts/与 CSS 相关的兼容性问题.md","hash":"a72cc9f0e92c312f489351a91b0f6a614572a16e","modified":1477898739000},{"_id":"source/_posts/与渲染HTML相关的兼容性问题.md","hash":"a3479550f05fba65fa530da16e2956f522d045a9","modified":1477898739000},{"_id":"source/_posts/作用域链和标识符详细解析.md","hash":"613acd6aed02e62f6a5caa53b163efb3cb9cf624","modified":1477898739000},{"_id":"source/_posts/高性能JavaScrip10.md","hash":"cd1f7bee3ee4bae6cec431cbb787fb45ac4798a7","modified":1477898739000},{"_id":"source/_posts/关于主题.md","hash":"f487c4a76685c89a1efeaac71ba57779a3c043d3","modified":1477898739000},{"_id":"source/_posts/写代码强行装逼.md","hash":"5c83016a253df3bef1d42f8f602d31bd095ef847","modified":1477898739000},{"_id":"source/_posts/hexo主题添加阅读数.md","hash":"9b695cc32a31822717005fea48aed377a8faa5d7","modified":1477906883000},{"_id":"source/_posts/高性能JavaScript2(DESKTOP-354QT49--xuyan--2015-08-22-15,12,25).md","hash":"8056b5105a03586d29dbe54c3d73c0c6bf4678f4","modified":1477898739000},{"_id":"source/_posts/高性能JavaScript3.md","hash":"3e78ab74c7b138690ebeb3f4fdd13494cabc3d64","modified":1477898739000},{"_id":"source/_posts/高性能JavaScript2.md","hash":"41ee33ca0d151427e3f6d63aa4dcb6a4b122d8e8","modified":1477898739000},{"_id":"source/_posts/高性能JavaScript1.md","hash":"ea5ba64b9c3fb9dab67c6589c16ac36aca364ee5","modified":1477898739000},{"_id":"source/_posts/高性能JavaScript6.md","hash":"e38b4ca2f1dc4ee0c76c2d001754dd31c34d2392","modified":1477898739000},{"_id":"source/_posts/高性能JavaScript7.md","hash":"803f64358fc38d3f181c1b3235c6a3d951003db3","modified":1477898739000},{"_id":"source/_posts/高性能JavaScript5.md","hash":"005e80460083b2328dd5cf0e6640870b29ee5c74","modified":1477898739000},{"_id":"source/_posts/高性能JavaScript8.md","hash":"ccf8f627332f183ee914088adcb201cd9343f9a1","modified":1477898739000},{"_id":"source/_posts/高性能JavaScript9.md","hash":"87075e5ada0cb1e85386ceaf898923a7cf0c6334","modified":1477898739000},{"_id":"source/_posts/高性能JavaScript4.md","hash":"8f15bb562df3489bb618bd7b29aa7766cea48669","modified":1477898739000},{"_id":"source/search/index.md","hash":"350d24efe68eb7687115857598b6a622e7058cc7","modified":1477898739000},{"_id":"source/_posts/浅谈BFC实际应用.md","hash":"450185378356874d77ad5ce0c040bfd5503423ef","modified":1477898739000},{"_id":"themes/smackdown/.git/config","hash":"33302a5925eecfbc5bced72ef7bbd07959d55fdf","modified":1477973781000},{"_id":"themes/smackdown/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1477973734000},{"_id":"themes/smackdown/.git/packed-refs","hash":"733b19df09dfaaedb59bf89bc78e9be1d48f6bd4","modified":1477973781000},{"_id":"themes/smackdown/.git/index","hash":"09591fc96592cccfea3daf1422cadaa0ed89f7a7","modified":1477973789000},{"_id":"themes/smackdown/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1477973781000},{"_id":"themes/smackdown/layout/.DS_Store","hash":"693e513b44d5241ea897cc90cc71aeba091283b9","modified":1477973781000},{"_id":"themes/smackdown/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1477973781000},{"_id":"themes/smackdown/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1477973781000},{"_id":"themes/smackdown/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1477973781000},{"_id":"themes/smackdown/layout/layout.ejs","hash":"2a03159a20b9b8c65fd1a62c24f5e93ddb0f18c8","modified":1477973781000},{"_id":"themes/smackdown/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1477973781000},{"_id":"themes/smackdown/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1477973781000},{"_id":"themes/smackdown/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1477973781000},{"_id":"themes/smackdown/source/.DS_Store","hash":"b67dd319d710cf62c9c4a871b1fc32e72ed63c7f","modified":1477973975000},{"_id":"themes/smackdown/.git/logs/HEAD","hash":"aa2fc5ae37f4c3e0a979eb7889d7c97b9a794249","modified":1477973781000},{"_id":"themes/smackdown/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1477973734000},{"_id":"themes/smackdown/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1477973734000},{"_id":"themes/smackdown/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1477973734000},{"_id":"themes/smackdown/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1477973734000},{"_id":"themes/smackdown/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1477973734000},{"_id":"themes/smackdown/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1477973734000},{"_id":"themes/smackdown/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1477973734000},{"_id":"themes/smackdown/layout/_partial/.DS_Store","hash":"e32979f5a18bff84e197c13b48f4c54e03796e4a","modified":1477973781000},{"_id":"themes/smackdown/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1477973734000},{"_id":"themes/smackdown/layout/_partial/after-footer.ejs","hash":"4bf1d05755851ffae61b281d63d273af82f72676","modified":1477973781000},{"_id":"themes/smackdown/.git/hooks/update.sample","hash":"39355a075977d05708ef74e1b66d09a36e486df1","modified":1477973734000},{"_id":"themes/smackdown/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1477973734000},{"_id":"themes/smackdown/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1477973781000},{"_id":"themes/smackdown/layout/_partial/baidu_tongji.ejs","hash":"b227224a73bfbcb31ebeece59f31723f32ed5b1d","modified":1477973781000},{"_id":"themes/smackdown/layout/_partial/article.ejs","hash":"abbd04b520a8cbb76ea4891ab615e13701eb9240","modified":1477973781000},{"_id":"themes/smackdown/layout/_partial/archive-post.ejs","hash":"3bbedf799e1788b3e62494eb6d0f7bd5df985cfc","modified":1477973781000},{"_id":"themes/smackdown/layout/_partial/google_analytics.ejs","hash":"354f8553dffba0a6bcea8294d5d656ed11315394","modified":1477973781000},{"_id":"themes/smackdown/layout/_partial/head.ejs","hash":"a3a39aa8f03e4a368e7d137cadbc66b25f60dade","modified":1477973781000},{"_id":"themes/smackdown/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1477973781000},{"_id":"themes/smackdown/layout/_partial/mathjax.ejs","hash":"960ee249eb0cfae9746589f3a4c3ece79359cae7","modified":1477973781000},{"_id":"themes/smackdown/layout/_partial/footer.ejs","hash":"5877baa1f23cac20e376787c6c7233853754e695","modified":1477973781000},{"_id":"themes/smackdown/layout/_partial/left-col.ejs","hash":"70a9951e4e2d30aabba88e75c3fa54b9235ce6a6","modified":1477973781000},{"_id":"themes/smackdown/layout/_partial/mobile-nav.ejs","hash":"cd0af87ee781ac9c2b0e6a2a05b063d4bd497d9c","modified":1477973781000},{"_id":"themes/smackdown/layout/_partial/search.ejs","hash":"87f9a4f472808398f9c7041642520d4345efac24","modified":1477973781000},{"_id":"themes/smackdown/layout/_widget/Counter.ejs","hash":"e0395ba653817d9b385f69a8733f370e5d60343d","modified":1477973781000},{"_id":"themes/smackdown/source/css/.DS_Store","hash":"fc5a428fe40854a0ba66b4cea196c6700a57cae7","modified":1477973781000},{"_id":"themes/smackdown/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1477973781000},{"_id":"themes/smackdown/source/css/_variables.styl","hash":"5e37a6571caf87149af83ac1cc0cdef99f117350","modified":1477973781000},{"_id":"themes/smackdown/source/css/style.styl","hash":"c22c1c798c042aec338b2e3111e3aff610579fa7","modified":1477973781000},{"_id":"themes/smackdown/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1477973781000},{"_id":"themes/smackdown/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1477973781000},{"_id":"themes/smackdown/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1477973781000},{"_id":"themes/smackdown/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1477973781000},{"_id":"themes/smackdown/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1477973781000},{"_id":"themes/smackdown/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1477973781000},{"_id":"themes/smackdown/source/fancybox/jquery.fancybox.css","hash":"b6aa6692c2e5f8bd74d96827b78570f0c5683c20","modified":1477973781000},{"_id":"themes/smackdown/source/fancybox/jquery.fancybox.js","hash":"a82597493d75ea989ca586e09173cff332efe41e","modified":1477973781000},{"_id":"themes/smackdown/source/img/coderwall.png","hash":"fa84676c4d654e040e51fd34bfcd9f9348cd5331","modified":1477973781000},{"_id":"themes/smackdown/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1477973781000},{"_id":"themes/smackdown/source/img/delicious.png","hash":"9553a5f5189e4a953e04a58a49dbfa74b86b73dd","modified":1477973781000},{"_id":"themes/smackdown/source/img/github.png","hash":"b84d03b32fa388dcbf149296ebd16dce6223d48d","modified":1477973781000},{"_id":"themes/smackdown/source/img/facebook.png","hash":"d19ad7a0903daf26817afd8753cd97e0cc714f54","modified":1477973781000},{"_id":"themes/smackdown/source/img/douban.png","hash":"e2ade003ffadd5826ee66ec23901c2d6e8607e4e","modified":1477973781000},{"_id":"themes/smackdown/source/img/google.png","hash":"61a21fec7346fa3400b747ac9a201cf3d5bc013d","modified":1477973781000},{"_id":"themes/smackdown/source/img/linkedin.png","hash":"e203138fb53c257cb214e97f4e30091b9c568d2c","modified":1477973781000},{"_id":"themes/smackdown/source/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1477973781000},{"_id":"themes/smackdown/source/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1477973781000},{"_id":"themes/smackdown/source/img/mail.png","hash":"fca8199cc77fdbd700a45bf56d091c82f4a67fe7","modified":1477973781000},{"_id":"themes/smackdown/source/img/pinterest.png","hash":"9c72917f8779c083157c6ce7a5d62ed4874f0630","modified":1477973781000},{"_id":"themes/smackdown/source/img/pinboard.png","hash":"0891fbb6d092fa012bf936019923383d84c6aeb0","modified":1477973781000},{"_id":"themes/smackdown/source/img/rss.png","hash":"430fd47340e75214c081abd05cd7410cf7c71b86","modified":1477973781000},{"_id":"themes/smackdown/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1477973781000},{"_id":"themes/smackdown/source/img/qq.png","hash":"93e6e87ec8cef56573a08c8f8fbb0bb53313354a","modified":1477973781000},{"_id":"themes/smackdown/source/img/search.png","hash":"1ab76b03297ae2ce61ec59dd9bf8727f1fbbcedd","modified":1477973781000},{"_id":"themes/smackdown/source/img/stackoverflow.png","hash":"da5dfe9043055c95e479d49c78cd3b020de608f2","modified":1477973781000},{"_id":"themes/smackdown/source/img/zhihu.png","hash":"a6d6ef65e9ac82e613a311810391ebb90d9b1c1d","modified":1477973781000},{"_id":"themes/smackdown/source/img/weibo.png","hash":"280dae3fd38086158b4a1b57edb94c06b1a5014b","modified":1477973781000},{"_id":"themes/smackdown/source/js/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1477973781000},{"_id":"themes/smackdown/source/img/twitter.png","hash":"14dbb8e62d056525253bc0de13acd1723da7a934","modified":1477973781000},{"_id":"themes/smackdown/source/js/instagram.js","hash":"f19adbcc0dac33536bc6660598059048ec901882","modified":1477973781000},{"_id":"themes/smackdown/source/js/Counter.js","hash":"6697d5dfba2700c059722b62d856d4c86c73031a","modified":1477973781000},{"_id":"themes/smackdown/source/js/jquery.lazyload.js","hash":"c11a2e7b330d16d06feabd0a8477099adf9d6799","modified":1477973781000},{"_id":"themes/smackdown/source/js/main.js","hash":"1d599d598cc4d90bc7f1aaf1acfb5e0841a2f97f","modified":1477973781000},{"_id":"themes/smackdown/source/js/mobile.js","hash":"b68cc01d24e80973c48205f551da87f3f3427644","modified":1477973781000},{"_id":"themes/smackdown/source/js/pc.js","hash":"fdbc039fc9ffa70815b5fc4daaa587ae29693f10","modified":1477973781000},{"_id":"themes/smackdown/source/js/particles.js","hash":"c4286268c2071a624bf3c8565f6328eccecacf30","modified":1477973781000},{"_id":"themes/smackdown/.git/refs/heads/master","hash":"91da13430c02381c090ac7a16b93020362c4dcb8","modified":1477973781000},{"_id":"themes/smackdown/.git/objects/pack/pack-63e70c980c00d66d88173c82a038f62b513d7202.idx","hash":"e6a8bd70ac68aa164d2224c6d226595c6c958fd8","modified":1477973780000},{"_id":"themes/smackdown/layout/_partial/post/nav.ejs","hash":"1939c94f24ba0f25dd728eef559509ba8647b546","modified":1477973781000},{"_id":"themes/smackdown/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1477973781000},{"_id":"themes/smackdown/layout/_partial/post/category.ejs","hash":"d4f0e36f9a2167e91082dbd7d52425a06d2bebbf","modified":1477973781000},{"_id":"themes/smackdown/layout/_partial/post/date.ejs","hash":"c0c988334e857a77ba455a056dfa21809e7e76a5","modified":1477973781000},{"_id":"themes/smackdown/layout/_partial/post/title.ejs","hash":"efa58f58564d44b819175ad11b10d77347c92891","modified":1477973781000},{"_id":"themes/smackdown/layout/_partial/post/viewCounter.ejs","hash":"07ef10241d92479fd4dafbee361c0bf9664e4452","modified":1477973781000},{"_id":"themes/smackdown/layout/_partial/post/tag.ejs","hash":"78612cfc091d7d861a70455a0dc8c3036e460879","modified":1477973781000},{"_id":"themes/smackdown/layout/_partial/post/share.ejs","hash":"da39b4ba0c0ce4e1932fd45c5aee10e8aca41f28","modified":1477973781000},{"_id":"themes/smackdown/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1477973781000},{"_id":"themes/smackdown/source/css/_partial/footer.styl","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1477973781000},{"_id":"themes/smackdown/source/css/_partial/article.styl","hash":"77286507c17021ecba6578e8e3cab12980523f77","modified":1477973781000},{"_id":"themes/smackdown/source/css/_partial/archive.styl","hash":"a5897b61c6fc714265f2a0bf2c95ba9ae57b4d5a","modified":1477973781000},{"_id":"themes/smackdown/source/css/_partial/main.styl","hash":"1b4897d47034dee9c5638afd8e46d2109d01997d","modified":1477973781000},{"_id":"themes/smackdown/source/css/_partial/instagram.styl","hash":"4de333144b00c58a5d41d682d83f78794f75d19d","modified":1477973781000},{"_id":"themes/smackdown/source/css/_partial/mobile.styl","hash":"dd601ea98944c8fdf0d6776ef5bae4d68e967835","modified":1477973781000},{"_id":"themes/smackdown/source/css/_partial/mobile-slider.styl","hash":"96eee8fb0d3f1108eae9a04682d4bbd0e968be22","modified":1477973781000},{"_id":"themes/smackdown/source/css/_partial/share.styl","hash":"6ac15a6815b1bbdbea89d3fe933c2821aa80b926","modified":1477973781000},{"_id":"themes/smackdown/source/css/_partial/highlight.styl","hash":"17a9b4fb6e746dd1f03757e89f5e3eff02b1fba6","modified":1477973781000},{"_id":"themes/smackdown/source/css/_partial/page.styl","hash":"97371f551ed051780f8632142ea00a705d76c845","modified":1477973781000},{"_id":"themes/smackdown/source/css/_partial/scroll.styl","hash":"a0bd4b253b28f694de59bec217f48f59f92cbaf2","modified":1477973781000},{"_id":"themes/smackdown/source/css/_partial/wheelmenu.styl","hash":"74630c56944e27bef53ef0c0e391611a2eec2ed0","modified":1477973781000},{"_id":"themes/smackdown/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1477973781000},{"_id":"themes/smackdown/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1477973781000},{"_id":"themes/smackdown/source/css/_partial/tagcloud.styl","hash":"84a678fe6b78befb4cf6e7523f8a40313a544fbd","modified":1477973781000},{"_id":"themes/smackdown/source/css/fonts/fontawesome-webfont.eot","hash":"3ce87b82c7a4ffdf65e96765c2ffda10b1a283c6","modified":1477973781000},{"_id":"themes/smackdown/source/css/fonts/fontawesome-webfont.ttf","hash":"1480b8101b02da9bc4c60341b5e185e63e585064","modified":1477973781000},{"_id":"themes/smackdown/source/css/fonts/fontawesome-webfont.svgz","hash":"4bfdd33ed702e32ae01399fcc2652377f78e7626","modified":1477973781000},{"_id":"themes/smackdown/source/css/fonts/fontawesome-webfont.woff","hash":"cafc4ac5761a0a252d33dce4ea3952cf9a38d832","modified":1477973781000},{"_id":"themes/smackdown/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1477973781000},{"_id":"themes/smackdown/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1477973781000},{"_id":"themes/smackdown/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1477973781000},{"_id":"themes/smackdown/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1477973781000},{"_id":"themes/smackdown/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1477973781000},{"_id":"themes/smackdown/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1477973781000},{"_id":"themes/smackdown/.git/logs/refs/heads/master","hash":"aa2fc5ae37f4c3e0a979eb7889d7c97b9a794249","modified":1477973781000},{"_id":"themes/smackdown/source/css/fonts/fontawesome-webfont.svg","hash":"23a6f5b2ff76de9cb3cf1e886194c67647fd868a","modified":1477973781000},{"_id":"themes/smackdown/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1477973781000},{"_id":"themes/smackdown/.git/objects/pack/pack-63e70c980c00d66d88173c82a038f62b513d7202.pack","hash":"1b957d3c7a920bef411d50d0e46844ffbcaf989c","modified":1477973780000},{"_id":"themes/smackdown/.git/logs/refs/remotes/origin/HEAD","hash":"aa2fc5ae37f4c3e0a979eb7889d7c97b9a794249","modified":1477973781000},{"_id":"public/baidusitemap.xml","hash":"91204d13e7b288795ed52322bbea04444a9a4a5b","modified":1477974081996},{"_id":"public/sitemap.xml","hash":"6e1fe5d7f552cd849915f352aac25fc73c42ba45","modified":1477974082546},{"_id":"public/search/index.html","hash":"220d53998b31f1de9d73de3dc4a6e03040dc81bf","modified":1477974082601},{"_id":"public/2016/10/31/hexo主题添加阅读数/index.html","hash":"3e2cb5713af26a87d79c4a9c3039d6eeec14a8d1","modified":1477974082601},{"_id":"public/2016/10/12/写代码强行装逼/index.html","hash":"5cbdb764071e2b7323cabea82d70a0f524a6bf05","modified":1477974082601},{"_id":"public/2015/08/15/与服务端通信相关的兼容性问题/index.html","hash":"b2a9a78cd166f0c15e0f297104c59dbb79cdf152","modified":1477974082602},{"_id":"public/2015/08/06/高性能JavaScrip10/index.html","hash":"d8b73e462b540bd87eb1197af05f27bf8400a250","modified":1477974082602},{"_id":"public/2015/08/05/高性能JavaScript9/index.html","hash":"b52b6b76664d5f641dba0015aaab0e5b94d5fb41","modified":1477974082602},{"_id":"public/2015/08/04/高性能JavaScript6/index.html","hash":"7f4463a19fafd4536c7d0a1ee368ca9303def3cc","modified":1477974082603},{"_id":"public/2015/08/02/高性能JavaScript4/index.html","hash":"11a51243e5775277c272f0840333e08dfa14a9c1","modified":1477974082604},{"_id":"public/2015/07/31/作用域链和标识符详细解析/index.html","hash":"fc0934248a880792c89352e1d1de0aac3a60e618","modified":1477974082604},{"_id":"public/2015/07/28/关于主题/index.html","hash":"9470387521a039fb36d381484db59e4e91a9175d","modified":1477974082604},{"_id":"public/archives/page/3/index.html","hash":"7189a1e251b47b3b91a7c3adefb3fa4984c4fe69","modified":1477974082604},{"_id":"public/archives/2015/05/index.html","hash":"6ee59d5f7596ff89e4ebcedf1c7356b7226abdd9","modified":1477974082604},{"_id":"public/archives/2015/07/index.html","hash":"c43db417d5fe7d2d1c353a9c1c195ee2ba431c92","modified":1477974082604},{"_id":"public/archives/2015/08/page/2/index.html","hash":"2f02d9f1dd221a8ebf45232f35ef19d7d20ef5b0","modified":1477974082604},{"_id":"public/archives/2016/index.html","hash":"b28365a008e4bf076a4da5188e403d093e3ae3e5","modified":1477974082605},{"_id":"public/archives/2016/10/index.html","hash":"a761c08ac8e1d681a81059638f62bfc2561fe39f","modified":1477974082605},{"_id":"public/categories/hexo/index.html","hash":"5c63e5e543c1665725b687d101cc0c8fbc31fd74","modified":1477974082605},{"_id":"public/categories/与脚本相关的兼容性问题/index.html","hash":"3a64b21dece322f40336d3661722c27f41a0b294","modified":1477974082605},{"_id":"public/categories/与渲染混合类型相关的兼容性问题/index.html","hash":"26e9f129ef0270f0ca291e240741397c51248d3e","modified":1477974082605},{"_id":"public/categories/与-CSS-相关的兼容性问题/index.html","hash":"3531df361c07ca277292cf80ee825cd0a1ff8101","modified":1477974082605},{"_id":"public/categories/与渲染HTML相关的兼容性问题/index.html","hash":"c10ee14a344ee3c03dbc3fe01bba01812deb08d8","modified":1477974082605},{"_id":"public/categories/作用域链和标识符详细解析/index.html","hash":"7fa00b12ed40e45b22deeef8588193381415de93","modified":1477974082607},{"_id":"public/categories/高性能JavaScript-10/index.html","hash":"f75e7f9c39eefe646fdc73af8c143b4dea279b45","modified":1477974082607},{"_id":"public/categories/关于主题/index.html","hash":"12d880c37be0111153520cfb0a463abff4d9dc1f","modified":1477974082607},{"_id":"public/categories/高性能JavaScript-2/index.html","hash":"2b175a10d82e22868f61474731203ef97d1e2faf","modified":1477974082607},{"_id":"public/categories/高性能JavaScript-3/index.html","hash":"4ac5fd675c29c8d2de405a8d0ce1884add84649f","modified":1477974082607},{"_id":"public/categories/高性能JavaScript-1/index.html","hash":"d7d8a09ef901c8edd1ffc9f4766a6c3bf2df0aae","modified":1477974082607},{"_id":"public/categories/高性能JavaScript-6/index.html","hash":"f55b340e777edebc7d058680dadc8fdb3e68139d","modified":1477974082608},{"_id":"public/categories/高性能JavaScript-7/index.html","hash":"37e6141fd122bd788f7360a66a7f4731ff3e7d73","modified":1477974082608},{"_id":"public/categories/高性能JavaScript-5/index.html","hash":"c9cc6e80ea8053e580406cc9a4de1d76a72a2fd2","modified":1477974082608},{"_id":"public/categories/高性能JavaScript-8/index.html","hash":"10ecfbd5651a6525797edc68e2111faab61364aa","modified":1477974082608},{"_id":"public/categories/高性能JavaScript-4/index.html","hash":"4f84e875b7d97d48d2c6cf89330719ca77e354f4","modified":1477974082608},{"_id":"public/categories/高性能JavaScript-9/index.html","hash":"dfb30260b74b084cf66c9bb9dd8ef6587769d15c","modified":1477974082608},{"_id":"public/categories/浅谈BFC实际应用/index.html","hash":"db4f1e2a6ba9e68b3b5e1363c21df81d03e07d84","modified":1477974082608},{"_id":"public/page/3/index.html","hash":"8899aa8a954038385c101d2bba62d21a8670678c","modified":1477974082608},{"_id":"public/tags/hexo/index.html","hash":"9d4c0209eedb958d87631ddd2a58d743cdd84bb7","modified":1477974082608},{"_id":"public/tags/兼容性/index.html","hash":"216187b9e196bb2e15d7e91a1bb11f1f3bd88abb","modified":1477974082608},{"_id":"public/tags/高性能JavaScript学习笔记/page/2/index.html","hash":"88d6cedd4a3c28370c6f5ac39c17ed13e503db7b","modified":1477974082608},{"_id":"public/tags/没事瞎扯/index.html","hash":"8a10aa9cd8eb59af2ed4e128a758ec6fa37886fc","modified":1477974082608},{"_id":"public/tags/CSS/index.html","hash":"e2a4bdf14a86d2717ef45307e6aae5a4bce78a43","modified":1477974082608},{"_id":"public/2015/08/21/与 CSS 相关的兼容性问题/index.html","hash":"3529e3072ec112ceeeba6481d4945962a271f4ef","modified":1477974082609},{"_id":"public/2015/08/19/与脚本相关的兼容性问题/index.html","hash":"73063c0d49e0fba97f5e903764b8780e087818d9","modified":1477974082609},{"_id":"public/2015/08/14/与渲染混合类型相关的兼容性问题/index.html","hash":"21d1dd5946be6c46e0eff29d4d40810a807a6021","modified":1477974082609},{"_id":"public/2015/08/12/与渲染HTML相关的兼容性问题/index.html","hash":"d6a09a4b8cfbc343c4b07bd2289287052cac98dd","modified":1477974082609},{"_id":"public/2015/08/08/浅谈BFC实际应用/index.html","hash":"cb0a5add72b3349b72787aa784ae2c3a20546d7e","modified":1477974082609},{"_id":"public/2015/08/04/高性能JavaScript8/index.html","hash":"6162a2a146988a7310ea34ce5480214e1f1f9dbc","modified":1477974082609},{"_id":"public/2015/08/04/高性能JavaScript7/index.html","hash":"223eb804153755e29b59841f43bbab7f7b598862","modified":1477974082610},{"_id":"public/2015/08/03/高性能JavaScript5/index.html","hash":"6c52deafd726b9401f57892748a5d7757e80e454","modified":1477974082610},{"_id":"public/2015/08/01/高性能JavaScript3/index.html","hash":"a4e9d10fdb3dff44f783b604fa2754f1a99385ee","modified":1477974082610},{"_id":"public/2015/07/31/高性能JavaScript2/index.html","hash":"8ce2b7b2daa8abfe802ed3a9660058812742c5c7","modified":1477974082610},{"_id":"public/2015/07/31/高性能JavaScript2(DESKTOP-354QT49--xuyan--2015-08-22-15,12,25)/index.html","hash":"75a2c2ab0a49d4973085aafc1e05ed3a725d4484","modified":1477974082610},{"_id":"public/2015/07/29/高性能JavaScript1/index.html","hash":"cef55c3802596f2b247962a5fc464c4c000f4b06","modified":1477974082610},{"_id":"public/2015/05/25/newHexo/index.html","hash":"797268c317c07883c7963ab243ef3cf841a4fdac","modified":1477974082610},{"_id":"public/archives/index.html","hash":"125b8feee3d1a7a3116fdec404c38da918af4f20","modified":1477974082610},{"_id":"public/archives/page/2/index.html","hash":"b4d6129c584ff571e8f95fd3bcd1a9835c0eba4d","modified":1477974082610},{"_id":"public/archives/2015/index.html","hash":"00f18d6204fdd4fd6861769571a519c0601d2724","modified":1477974082610},{"_id":"public/archives/2015/page/2/index.html","hash":"43ed317e9d5ca9612aa40e2eea1eba69bde90fc6","modified":1477974082611},{"_id":"public/archives/2015/08/index.html","hash":"c650f136ef5ff5f3469941c79e6d28af43103337","modified":1477974082611},{"_id":"public/index.html","hash":"04bd5f3584fc0a27306d4557bfcc5304ac1a5aa7","modified":1477974082611},{"_id":"public/page/2/index.html","hash":"988442549e686c499e713c2e5c6de0fed9cda486","modified":1477974082611},{"_id":"public/tags/高性能JavaScript学习笔记/index.html","hash":"dab131b288d9bf61a83187f063b06ca2bf8e0bc4","modified":1477974082611},{"_id":"public/CNAME","hash":"bf60509a9ef5efeec32815d3360f81e995e63d63","modified":1477974082627},{"_id":"public/READMEen.mdown","hash":"8fca021d52a2d15efe559bb1f97f59575beb8089","modified":1477974082628},{"_id":"public/README.mdown","hash":"6f9ef4747aae8ef6fe298179f91f26ecbb5c3644","modified":1477974082628},{"_id":"public/robots.txt","hash":"ab5e82bf81cd2f1d491e0baa437a7c3a5ab8cfcb","modified":1477974082628},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1477974082628},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1477974082628},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1477974082628},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1477974082628},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1477974082628},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1477974082628},{"_id":"public/img/coderwall.png","hash":"fa84676c4d654e040e51fd34bfcd9f9348cd5331","modified":1477974082628},{"_id":"public/img/delicious.png","hash":"9553a5f5189e4a953e04a58a49dbfa74b86b73dd","modified":1477974082628},{"_id":"public/img/github.png","hash":"b84d03b32fa388dcbf149296ebd16dce6223d48d","modified":1477974082628},{"_id":"public/img/facebook.png","hash":"d19ad7a0903daf26817afd8753cd97e0cc714f54","modified":1477974082629},{"_id":"public/img/douban.png","hash":"e2ade003ffadd5826ee66ec23901c2d6e8607e4e","modified":1477974082629},{"_id":"public/img/google.png","hash":"61a21fec7346fa3400b747ac9a201cf3d5bc013d","modified":1477974082629},{"_id":"public/img/linkedin.png","hash":"e203138fb53c257cb214e97f4e30091b9c568d2c","modified":1477974082629},{"_id":"public/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1477974082629},{"_id":"public/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1477974082629},{"_id":"public/img/mail.png","hash":"fca8199cc77fdbd700a45bf56d091c82f4a67fe7","modified":1477974082629},{"_id":"public/img/pinterest.png","hash":"9c72917f8779c083157c6ce7a5d62ed4874f0630","modified":1477974082629},{"_id":"public/img/pinboard.png","hash":"0891fbb6d092fa012bf936019923383d84c6aeb0","modified":1477974082629},{"_id":"public/img/rss.png","hash":"430fd47340e75214c081abd05cd7410cf7c71b86","modified":1477974082629},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1477974082629},{"_id":"public/img/search.png","hash":"1ab76b03297ae2ce61ec59dd9bf8727f1fbbcedd","modified":1477974082629},{"_id":"public/img/stackoverflow.png","hash":"da5dfe9043055c95e479d49c78cd3b020de608f2","modified":1477974082629},{"_id":"public/img/qq.png","hash":"93e6e87ec8cef56573a08c8f8fbb0bb53313354a","modified":1477974082629},{"_id":"public/img/zhihu.png","hash":"a6d6ef65e9ac82e613a311810391ebb90d9b1c1d","modified":1477974082629},{"_id":"public/img/weibo.png","hash":"280dae3fd38086158b4a1b57edb94c06b1a5014b","modified":1477974082629},{"_id":"public/img/twitter.png","hash":"14dbb8e62d056525253bc0de13acd1723da7a934","modified":1477974082629},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"3ce87b82c7a4ffdf65e96765c2ffda10b1a283c6","modified":1477974082629},{"_id":"public/css/fonts/fontawesome-webfont.svgz","hash":"4bfdd33ed702e32ae01399fcc2652377f78e7626","modified":1477974082629},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"1480b8101b02da9bc4c60341b5e185e63e585064","modified":1477974082629},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"cafc4ac5761a0a252d33dce4ea3952cf9a38d832","modified":1477974082629},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1477974082629},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"23a6f5b2ff76de9cb3cf1e886194c67647fd868a","modified":1477974085269},{"_id":"public/fancybox/jquery.fancybox.css","hash":"b6aa6692c2e5f8bd74d96827b78570f0c5683c20","modified":1477974085326},{"_id":"public/js/instagram.js","hash":"f19adbcc0dac33536bc6660598059048ec901882","modified":1477974085327},{"_id":"public/js/Counter.js","hash":"6697d5dfba2700c059722b62d856d4c86c73031a","modified":1477974085327},{"_id":"public/js/jquery.lazyload.js","hash":"c11a2e7b330d16d06feabd0a8477099adf9d6799","modified":1477974085327},{"_id":"public/js/main.js","hash":"1d599d598cc4d90bc7f1aaf1acfb5e0841a2f97f","modified":1477974085327},{"_id":"public/js/mobile.js","hash":"b68cc01d24e80973c48205f551da87f3f3427644","modified":1477974085327},{"_id":"public/js/pc.js","hash":"fdbc039fc9ffa70815b5fc4daaa587ae29693f10","modified":1477974085327},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1477974085327},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1477974085328},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1477974085328},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1477974085328},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1477974085328},{"_id":"public/css/style.css","hash":"0154043a6bc1838fcf882edf31c1eb252f76f278","modified":1477974085328},{"_id":"public/fancybox/jquery.fancybox.js","hash":"a82597493d75ea989ca586e09173cff332efe41e","modified":1477974085328},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1477974085328},{"_id":"public/js/particles.js","hash":"c4286268c2071a624bf3c8565f6328eccecacf30","modified":1477974085328}],"Category":[{"name":"hexo","_id":"ciuyzlust0003e6tbm48nq62p"},{"name":"与脚本相关的兼容性问题","_id":"ciuyzlut90008e6tbrhbcxtjm"},{"name":"与渲染混合类型相关的兼容性问题","_id":"ciuyzluto000ee6tb1haabqz1"},{"name":"与 CSS 相关的兼容性问题","_id":"ciuyzluu6000te6tbi9zagdla"},{"name":"与渲染HTML相关的兼容性问题","_id":"ciuyzluuc0010e6tb4mhd20z6"},{"name":"作用域链和标识符详细解析","_id":"ciuyzluuq0019e6tbvf7x03do"},{"name":"高性能JavaScript-10","_id":"ciuyzluv0001ge6tbrmg3rtdj"},{"name":"关于主题","_id":"ciuyzluvd001ne6tbeka8scnr"},{"name":"高性能JavaScript-2","_id":"ciuyzluvs001ve6tbzt1t8ncg"},{"name":"高性能JavaScript-3","_id":"ciuyzluvz0020e6tb2iphli38"},{"name":"高性能JavaScript-1","_id":"ciuyzluw20028e6tbc7dvlshn"},{"name":"高性能JavaScript-6","_id":"ciuyzluw4002ae6tbrd523146"},{"name":"高性能JavaScript-7","_id":"ciuyzluw6002ce6tbypno09v3"},{"name":"高性能JavaScript-5","_id":"ciuyzluw7002ee6tbeynciu8v"},{"name":"高性能JavaScript-8","_id":"ciuyzluw8002ge6tbu7g9kdee"},{"name":"高性能JavaScript-4","_id":"ciuyzluwa002ie6tbpiu9dzrg"},{"name":"高性能JavaScript-9","_id":"ciuyzluwb002ke6tbcul6lygg"},{"name":"浅谈BFC实际应用","_id":"ciuyzluwc002me6tblmmjrxu9"}],"Data":[],"Page":[{"layout":"search","title":"RESULT","toc":false,"comments":0,"_content":"<div id=\"st-results-container\">\n</div>","source":"search/index.md","raw":"layout: search\ntitle: RESULT\ntoc: false\ncomments: false\n----\n<div id=\"st-results-container\">\n</div>","date":"2016-10-31T07:25:39.000Z","updated":"2016-10-31T07:25:39.000Z","path":"search/index.html","_id":"ciuyzlusn0001e6tb80u829f0","content":"<div id=\"st-results-container\"><br></div>","excerpt":"","more":"<div id=\"st-results-container\"><br></div>"}],"Post":[{"title":"搭建你的Hexo博客","date":"2015-05-25T05:13:45.000Z","top":100,"_content":" 早就想在github上搭建属于自己的博客了，一直没有腾出时间，Jekyll也觉得一般，前一阵一个朋友推荐hexo，看了看文档，很不错，也决定用hexo搭建一个自己的博客，下面是我摘自网络的教程，想搭建自己博客的朋友可以自己动手试一试。\n<!--more-->\n---\nhexo出自台湾大学生tommy351之手，是一个基于Node.js的静态博客程序，其编译上百篇文字只需要几秒。hexo生成的静态网页可以直接放到GitHub Pages，BAE，SAE等平台上。先看看tommy是如何吐槽Octopress的 →＿→ Hexo颯爽登場。\n>- 如果你对默认配置满意，只需几个命令便可秒搭一个hexo。\n>- 如果你跟我一样喜欢折腾下，30分钟也足够个性化。\n>- 如果你过于喜欢折腾，可以折腾个把星期，尽情的玩。\n\n搭建过程你或许觉得有那么点小繁琐，但一旦搭建完成，写文章是极简单，极舒服的。\n只需要几个简单命令，你就可以完成一切。\n\n\thexo n #写文章\n\thexo g #生成\n\thexo d #部署 # 可与hexo g合并为 hexo d -g\n\n下面逐步介绍，进入正题。\n\n---\n**环境准备**\n===\n**安装Node**\n到[Node.js官网](http://nodejs.org/)下载相应平台的最新版本，一路安装即可。我用的是[node-v0.10.22-x86.msi](http://nodejs.org/dist/v0.10.22/node-v0.10.22-x86.msi)\n**安装Git**\nGit的客户端很多，我用的是[msysgit](http://code.google.com/p/msysgit)，喜欢用绿色版本[Portable application for official Git for Windows 1.8.4](http://code.google.com/p/msysgit/downloads/detail?name=PortableGit-1.8.4-preview20130916.7z)，下载下来设置一下环境变量即可，Git_HOME，%Git_HOME%\\bin之类的，不多说。\n**安装Sublime（可选）**\n[Sublime Text 2](http://www.sublimetext.com/)在这里仅仅作为一个文本编辑器使用，支持各种编程语言和文件格式，当然也支持Markdown语法，实在是个不可多得的练码奇才。喜欢追鲜的也可以尝试处于beta版本的[Sublime Text 3](http://www.sublimetext.com/3)。我用绿色版本[Portable Sublime Text 2.0.2.zip](http://c758482.r82.cf2.rackcdn.com/Sublime%20Text%202.0.2.zip)。\n> *本屌是穷码畜，对于高大上的Mac码帅用户请移步：[hexo installation](http://zespia.tw/hexo/docs/installation.html)*\n\n**GitHub**\n===\n>GitHub账号和GitHub Pages 一般都应该有吧，已有的请自动无视这一部分。\n\n- 首先注册一个『GitHub』帐号，已有的默认默认请忽略\n- 建立与你用户名对应的仓库，仓库名必须为『your_user_name.github.com』\n- 添加SSH公钥到『Account settings -> SSH Keys -> Add SSH Key』\n![GitHub Mark](http://7xkj1z.com1.z0.glb.clouddn.com/my-github-pages.jpg \"GitHub Mark\")\n\n前两步忽略，只说第三步，添加SSH-Key。\n\n首先设置你的用户名密码(邮箱和用户名改你自己的，下同)：\n\n\tgit config --global user.email \"bu.ru@qq.com\"\n\tgit config --global user.name \"bruce-sha\"\n生成密钥：\n\n\tssh-keygen -t rsa -C \"bu.ru@qq.com\"\n输入文件路径：\n\n\tH:\\hexo\\blog>ssh-keygen -t rsa -C \"bu.ru@qq.com\"\n\tGenerating public/private rsa key pair.\n\tEnter file in which to save the key (//.ssh/id_rsa): H:\\git\\myssh\\ssh\n\tEnter passphrase (empty for no passphrase):\n\tEnter same passphrase again:\n\tYour identification has been saved in H:\\git\\myssh\\ssh.\n\tYour public key has been saved in H:\\git\\myssh\\ssh.pub.\n\tThe key fingerprint is:\n\tb0:0c:2e:67:33:ab:c1:50:10:40:0a:ba:c1:80:59:22 bu.ru@qq.com\t\n\n> *有个bug，文件路径中的盘符H必须大写，否则会报错。*\n\n上述命令若执行成功，会在H:\\git\\myssh目录下生成两个文件id_rsa和id_rsa.pub，最后两步：\n >1.用文本编辑器打开ssh.pub文件，拷贝其中的内容，将其添加到Add SSH Key\n >2.将id_rsa和id_rsa.pub拷贝至你Git安装目录下的.ssh目录，如H:\\PortableGit-1.8.4\\.ssh\n\n ![GitHub Mark](http://7xkj1z.com1.z0.glb.clouddn.com/add-ssh-keys.jpg \"GitHub Mark\")\n 最后可以验证一下：\n\n\tssh -T git@github.com\n\n若有问题，请重新设置。常见错误请参考：\n[GitHub Help - Generating SSH Keys](http://help.github.com/articles/generating-ssh-keys)\n[GitHub Help - Error Permission denied (publickey)](http://help.github.com/articles/error-permission-denied-publickey)\n**安装**\n===\nNode和Git都安装好后，可执行如下命令安装hexo：\n\n\tnpm install -g hexo\n**初始化**\n===\n然后，执行init命令初始化hexo到你指定的目录：\n\n\thexo init <folder>\n>也可以cd到目标目录，执行hexo init。\n\n好啦，至此，全部安装工作已经完成！\n**生成静态页面**\n===\ncd 到你的init目录，执行如下命令，生成静态页面至hexo\\public\\目录。\n\n\thexo generate\n> - *命令必须在init目录下执行，否则不成功，但是也不报错。*\n- *当你修改文章Tag或内容，不能正确重新生成内容，可以删除hexo\\db.json后重试，还不行就到public目录删除对应的文件，重新生成。*\n\n**本地启动**\n===\n执行如下命令，启动本地服务，进行文章预览调试。\n\n\thexo server\n浏览器输入 http://localhost:4000 就可以看到效果。\n>请使用高级浏览器，否则可能…你懂的！\n\n**写文章**\n===\n执行new命令，生成指定名称的文章至hexo\\source\\_posts\\postName.md。\n\n\thexo new [layout] \"postName\" #新建文章\n其中layout是可选参数，默认值为post。有哪些layout呢，请到scaffolds目录下查看，这些文件名称就是layout名称。当然你可以添加自己的layout，方法就是添加一个文件即可，同时你也可以编辑现有的layout，比如post的layout默认是hexo\\scaffolds\\post.md\n\n\ttitle: { { title } }\n\tdate: { { date } }\n\ttags:\n\t---\n>请注意，大括号与大括号之间我多加了个空格，否则会被转义，不能正常显示。\n\n我想添加categories，以免每次手工输入，只需要修改这个文件添加一行，如下:\n\n\ttitle: { { title } }\n\tdate: { { date } }\n\tcategories: \n\ttags: \n\t---\npostName是md文件的名字，同时也出现在你文章的URL中，postName如果包含空格，必须用”将其包围，postName可以为中文。\n>注意，所有文件：后面都必须有个空格，不然会报错。\n\n看一下刚才生成的文件hexo\\source\\_posts\\postName.md，内容如下：\n\n\ttitle: postName #文章页面上的显示名称，可以任意修改，不会出现在URL中\n\tdate: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改\n\tcategories: #文章分类目录，可以为空，注意:后面有个空格\n\ttags: #文章标签，可空，多标签请用格式[tag1,tag2,tag3]，注意:后面有个空格\n\t---\n\t这里开始使用markdown格式输入你的正文。\n\n接下来，你就可以用喜爱的编辑器尽情书写你的文章。关于markdown语法，可以参考我的文章[Markdown简明语法]()。\n**fancybox**\n可能有人对这个Reading页面中图片的fancybox效果感兴趣，这个是怎么做的呢。\n很简单，只需要在你的文章*.md文件的头上添加photos项即可，然后一行行添加你要展示的照片：\n\n\tlayout: photo\n\ttitle: 我的阅历\n\tdate: 2085-01-16 07:33:44\n\ttags: [hexo]\n\tphotos:\n\t- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-0.jpg\n\t- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-1.jpg\n>经过测试，文件头上的layout: photo可以省略。\n\n不想每次都手动添加怎么办？同样的，打开您的hexo\\scaffolds\\photo.md\n\n\tlayout: { { layout } }\n\ttitle: { { title } }\n\tdate: { { date } }\n\ttags: \n\tphotos: \n\t- \n\t---\n\n然后每次可以执行带layout的new命令生成照片文章：\n\n\thexo new photo \"photoPostName\" #新建照片文章\n\n**description**\nmarkdown文件头中也可以添加description，以覆盖全局配置文件中的description内容，请参考下文_config.yml的介绍。\n\n\ttitle: hexo你的博客\n\tdate: 2013-11-22 17:11:54\n\tcategories: default\n\ttags: [hexo]\n\tdescription: 你对本页的描述\n\t---\n\n>hexo默认会处理全部markdown和html文件，如果不想让hexo处理你的文件，可以在文件头中加入layout: false。\n\n**文章摘要:**\n在需要显示摘要的地方添加如下代码即可：\n\n\t以上是摘要\n\t<!--more-->\n\t以下是余下全文\n\nmore以上内容即是文章摘要，在主页显示，more以下内容点击『> Read More』链接打开全文才显示。\n>hexo中所有文件的编码格式均是UTF-8。\n\n**主题安装**\n===\n萝卜白菜各有所爱，玩博客换主题是必不可少的，hexo的主题列表Hexo Themes。\n我比较喜欢pacman，modernist、ishgo，raytaylorism。Pacman最为优秀，简洁大方小清新，同时移动版本支持的也很好，但作者并没有把很多参数分离出来给出可配置项，我最终选择了modernist。\n\n安装主题的方法就是一句git命令：\n\n\tgit clone https://github.com/heroicyang/hexo-theme-modernist.git themes/modernist\n>目录是否是modernist无所谓，只要与_config.yml文件一致即可。\n\n安装完成后，打开hexo\\_config.yml，修改主题为modernist\n\n\ttheme: modernist\n打开hexo\\themes\\modernist目录，编辑主题配置文件_config.yml：\n\n\tmenu: #配置页头显示哪些菜单\n\t#  Home: /\n\t  Archives: /archives\n\t  Reading: /reading\n\t  About: /about\n\t#  Guestbook: /about\n\n\texcerpt_link: Read More #摘要链接文字\n\tarchive_yearly: false #按年存档\n\n\twidgets: #配置页脚显示哪些小挂件\n\t  - category\n\t#  - tag\n\t  - tagcloud\n\t  - recent_posts\n\t#  - blogroll\n\n\tblogrolls: #友情链接\n\t  - bruce sha's duapp wordpress: http://ibruce.duapp.com\n\t  - bruce sha's javaeye: http://buru.iteye.com\n\t  - bruce sha's oschina blog: http://my.oschina.net/buru\n\t  - bruce sha's baidu space: http://hi.baidu.com/iburu\n\n\tfancybox: true #是否开启fancybox效果\n\n\tduoshuo_shortname: buru #多说账号\n\n\tgoogle_analytics:\n\trss:\n\n更新主题\n\n\tcd themes/modernist\n\tgit pull\n**评论框**\n===\n静态博客要使用第三方评论系统，hexo默认集成的是Disqus，因为你懂的，所以国内的话还是建议用多说。\n直接用你的微博/豆瓣/人人/百度/开心网帐号登录多说，做一下基本设置。如果使用modernist主题，在modernist_config.yml中配置duoshuo_shortname为多说的基本设置->域名中的shortname即可。你也可以在多说后台自定义一下多说评论框的格式，比如评论框的位置，对于css设置，可以参考这里，我是在HeroicYang的基础上修改的。\n\n如果你是有的其他第三方评论系统，将通用代码粘贴到hexo\\themes\\modernist\\layout\\_partial\\comment.ejs里面，如下：\n\n\t<% if (config.disqus_shortname && page.comments){ %>\n\t<section id=\"comment\">\n\t  #你的通用代码\n\t<% } %>\n**自定义页面**\n===\n执行new page命令\n\n\thexo new page \"about\"\n在hexo\\source\\下会生成about目录，里面有个index.md，直接编辑就可以了，然后在主题的_config.yml中将其配置显示出来。\n上述步骤，也可以手工生成，在hexo\\source\\下手工新建about和index.md也是完全等价的。\n\n>因为markdown对table的支持不好，我是在about中直接建立index.html，里面书写页面内容，hexo会帮你加上头和尾。\n\n**404页面**\n===\nGitHub Pages 自定义[404页面](http://help.github.com/articles/custom-404-pages)非常容易，直接在根目录下创建自己的**404.html**就可以。但是自定义404页面仅对绑定顶级域名的项目才起作用，GitHub默认分配的二级域名是不起作用的，使用hexo server在本机调试也是不起作用的。\n其实，404页面可以做更多有意义的事，来做个404公益项目吧。做点有意义的事情，也对得起这个域名。\n目前有如下几个公益404接入地址，我选择了腾讯的。404页面，每个人可以做的更多。\n\n- [腾讯公益404](http://www.qq.com/404)\n- [404公益_益云(公益互联网)社会创新中心](http://yibo.iyiyun.com/Index/web404)\n- [失蹤兒童少年資料管理中心404](http://404page.missingkids.org.tw/)\n\n**图床**\n===\n考虑到博客的速度，同时也为了便于博客的迁移，图床是必须的。我墙裂推荐七牛，访问速度极快，支持日志、防盗链和水印。\n\n免费用户有每月10GB流量+总空间10GB+PUT/DELETE 10万次请求+GET 100万次请求，这对个人博客来说足够，也可通过邀请好友获得奖励。有一点要说明的是，七牛没有目录的概念，但是文件名可以包含/，比如2013/11/27/reading/photos-0.jpg，参考这里关于[key-value存储系统](http://kb.qiniu.com/key-value-system)。\n\n七牛除了作为图床还可以作为其他静态文件存储空间，比如我的个人站点首页有个字库文件和JS文件下载较慢，有时间会把它弄到七牛上去，以提高首页打开速度。请看这篇[Linux中国采用七牛云存储支撑图片访问](http://linux.cn/thread/11986/1/1)。\n\n如果非要说不足的话，就是文件管理界面不是很友好，不支持CNAME到分配的永久链接，也不能绑定未备案的自有域名，必须备案才可以。\n\n>如果你对七牛web版的文件管理界面不满意，可以用官方的[七牛云存储工具](http://docs.qiniu.com/tools/v6/index.html)。\n\n您还可以使用如下图床服务 [FarBox](http://www.farbox.com/)，[Dropbox](http://www.dropbox.com/)，[又拍云](http://www.upyun.com/)。\n\n**申请域名（可选）**\n===\nGitHubPages默认为每个用户分配了一个二级域名『your_user_name.github.com』或『your_user_name.github.io』。\n如果你对上述域名不满意，可以到[狗爹](http://www.godaddy.com/)，或者[万网](http://wanwang.aliyun.com/)上申请一个自己的域名，然后绑定到GitHub Pages。绑定方法很简单，在repo根目录下建立一个CNAME文件，里面写上域名即可。\n\n**GoDaddy**\n买域名首选狗爹，国内的服务商大家都懂的。\n目前.info域名只要￥18.99，但据说续费比较贵，我是先玩下，一年后再换，至于搜索引擎重新索引之类的，无所谓。.me和.com域名稍微贵点，大约￥60-100，网上有很多优惠码可用，可惜有的优惠码有限制。比如有个.com域名优惠码只要$1.99，但只能用国外信用卡购买。更多优惠码可以自行谷歌或到独特优惠码找。不着急的同学可以将中意的域名加入购物车先不付款，过几天，狗爹就会发优惠信息给你。狗爹不定期也会有活动，可以多关注。\n付款后，需要稍微等一会你才会拿到域名，特别是支付宝付款的，要等大约半小时左右。此外域名要一年年的买，这样比较划算。\n\n>建议大家申请.com或.me域名。据说.info因垃圾网站太多，被搜索引擎惩罚，而且续费较贵。\n\n**DNSPod**\nGoDaddy的NameServers有时会被墙，因此墙裂推荐国内的[DNSPod](http://www.dnspod.cn/)解析域名，免费服务真心不错。支持微信/邮件提醒，监控与报警，访问统计，健康诊断，搜索引擎推送，速度哇哇的，对于我来说足够。\n两步设置就可以搞定，怎么操作参考[Godaddy注册商域名修改DNS地址](http://support.dnspod.cn/Kb/showarticle/tsid/42)。\n\n**命令**\n===\n**常用命令：**\n\n\thexo new \"postName\" #新建文章\n\thexo new page \"pageName\" #新建页面\n\thexo generate #生成静态页面至public目录\n\thexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\n\thexo deploy #将.deploy目录部署到GitHub\n**常用复合命令：**\n\n\thexo deploy -g\n\thexo server -g\n**简写：**\n\t\n\thexo n == hexo new\n\thexo g == hexo generate\n\thexo s == hexo server\n\thexo d == hexo deploy\n\n---\n**至此，基本操作介绍完毕,如果有什么问题，欢迎评论问我，看到一定回复**\n===\n\n---","source":"_posts/newHexo.md","raw":"title: 搭建你的Hexo博客\ndate: 2015-05-25 13:13:45\ntags: hexo\ncategories: hexo\ntop: 100\n\n---\n 早就想在github上搭建属于自己的博客了，一直没有腾出时间，Jekyll也觉得一般，前一阵一个朋友推荐hexo，看了看文档，很不错，也决定用hexo搭建一个自己的博客，下面是我摘自网络的教程，想搭建自己博客的朋友可以自己动手试一试。\n<!--more-->\n---\nhexo出自台湾大学生tommy351之手，是一个基于Node.js的静态博客程序，其编译上百篇文字只需要几秒。hexo生成的静态网页可以直接放到GitHub Pages，BAE，SAE等平台上。先看看tommy是如何吐槽Octopress的 →＿→ Hexo颯爽登場。\n>- 如果你对默认配置满意，只需几个命令便可秒搭一个hexo。\n>- 如果你跟我一样喜欢折腾下，30分钟也足够个性化。\n>- 如果你过于喜欢折腾，可以折腾个把星期，尽情的玩。\n\n搭建过程你或许觉得有那么点小繁琐，但一旦搭建完成，写文章是极简单，极舒服的。\n只需要几个简单命令，你就可以完成一切。\n\n\thexo n #写文章\n\thexo g #生成\n\thexo d #部署 # 可与hexo g合并为 hexo d -g\n\n下面逐步介绍，进入正题。\n\n---\n**环境准备**\n===\n**安装Node**\n到[Node.js官网](http://nodejs.org/)下载相应平台的最新版本，一路安装即可。我用的是[node-v0.10.22-x86.msi](http://nodejs.org/dist/v0.10.22/node-v0.10.22-x86.msi)\n**安装Git**\nGit的客户端很多，我用的是[msysgit](http://code.google.com/p/msysgit)，喜欢用绿色版本[Portable application for official Git for Windows 1.8.4](http://code.google.com/p/msysgit/downloads/detail?name=PortableGit-1.8.4-preview20130916.7z)，下载下来设置一下环境变量即可，Git_HOME，%Git_HOME%\\bin之类的，不多说。\n**安装Sublime（可选）**\n[Sublime Text 2](http://www.sublimetext.com/)在这里仅仅作为一个文本编辑器使用，支持各种编程语言和文件格式，当然也支持Markdown语法，实在是个不可多得的练码奇才。喜欢追鲜的也可以尝试处于beta版本的[Sublime Text 3](http://www.sublimetext.com/3)。我用绿色版本[Portable Sublime Text 2.0.2.zip](http://c758482.r82.cf2.rackcdn.com/Sublime%20Text%202.0.2.zip)。\n> *本屌是穷码畜，对于高大上的Mac码帅用户请移步：[hexo installation](http://zespia.tw/hexo/docs/installation.html)*\n\n**GitHub**\n===\n>GitHub账号和GitHub Pages 一般都应该有吧，已有的请自动无视这一部分。\n\n- 首先注册一个『GitHub』帐号，已有的默认默认请忽略\n- 建立与你用户名对应的仓库，仓库名必须为『your_user_name.github.com』\n- 添加SSH公钥到『Account settings -> SSH Keys -> Add SSH Key』\n![GitHub Mark](http://7xkj1z.com1.z0.glb.clouddn.com/my-github-pages.jpg \"GitHub Mark\")\n\n前两步忽略，只说第三步，添加SSH-Key。\n\n首先设置你的用户名密码(邮箱和用户名改你自己的，下同)：\n\n\tgit config --global user.email \"bu.ru@qq.com\"\n\tgit config --global user.name \"bruce-sha\"\n生成密钥：\n\n\tssh-keygen -t rsa -C \"bu.ru@qq.com\"\n输入文件路径：\n\n\tH:\\hexo\\blog>ssh-keygen -t rsa -C \"bu.ru@qq.com\"\n\tGenerating public/private rsa key pair.\n\tEnter file in which to save the key (//.ssh/id_rsa): H:\\git\\myssh\\ssh\n\tEnter passphrase (empty for no passphrase):\n\tEnter same passphrase again:\n\tYour identification has been saved in H:\\git\\myssh\\ssh.\n\tYour public key has been saved in H:\\git\\myssh\\ssh.pub.\n\tThe key fingerprint is:\n\tb0:0c:2e:67:33:ab:c1:50:10:40:0a:ba:c1:80:59:22 bu.ru@qq.com\t\n\n> *有个bug，文件路径中的盘符H必须大写，否则会报错。*\n\n上述命令若执行成功，会在H:\\git\\myssh目录下生成两个文件id_rsa和id_rsa.pub，最后两步：\n >1.用文本编辑器打开ssh.pub文件，拷贝其中的内容，将其添加到Add SSH Key\n >2.将id_rsa和id_rsa.pub拷贝至你Git安装目录下的.ssh目录，如H:\\PortableGit-1.8.4\\.ssh\n\n ![GitHub Mark](http://7xkj1z.com1.z0.glb.clouddn.com/add-ssh-keys.jpg \"GitHub Mark\")\n 最后可以验证一下：\n\n\tssh -T git@github.com\n\n若有问题，请重新设置。常见错误请参考：\n[GitHub Help - Generating SSH Keys](http://help.github.com/articles/generating-ssh-keys)\n[GitHub Help - Error Permission denied (publickey)](http://help.github.com/articles/error-permission-denied-publickey)\n**安装**\n===\nNode和Git都安装好后，可执行如下命令安装hexo：\n\n\tnpm install -g hexo\n**初始化**\n===\n然后，执行init命令初始化hexo到你指定的目录：\n\n\thexo init <folder>\n>也可以cd到目标目录，执行hexo init。\n\n好啦，至此，全部安装工作已经完成！\n**生成静态页面**\n===\ncd 到你的init目录，执行如下命令，生成静态页面至hexo\\public\\目录。\n\n\thexo generate\n> - *命令必须在init目录下执行，否则不成功，但是也不报错。*\n- *当你修改文章Tag或内容，不能正确重新生成内容，可以删除hexo\\db.json后重试，还不行就到public目录删除对应的文件，重新生成。*\n\n**本地启动**\n===\n执行如下命令，启动本地服务，进行文章预览调试。\n\n\thexo server\n浏览器输入 http://localhost:4000 就可以看到效果。\n>请使用高级浏览器，否则可能…你懂的！\n\n**写文章**\n===\n执行new命令，生成指定名称的文章至hexo\\source\\_posts\\postName.md。\n\n\thexo new [layout] \"postName\" #新建文章\n其中layout是可选参数，默认值为post。有哪些layout呢，请到scaffolds目录下查看，这些文件名称就是layout名称。当然你可以添加自己的layout，方法就是添加一个文件即可，同时你也可以编辑现有的layout，比如post的layout默认是hexo\\scaffolds\\post.md\n\n\ttitle: { { title } }\n\tdate: { { date } }\n\ttags:\n\t---\n>请注意，大括号与大括号之间我多加了个空格，否则会被转义，不能正常显示。\n\n我想添加categories，以免每次手工输入，只需要修改这个文件添加一行，如下:\n\n\ttitle: { { title } }\n\tdate: { { date } }\n\tcategories: \n\ttags: \n\t---\npostName是md文件的名字，同时也出现在你文章的URL中，postName如果包含空格，必须用”将其包围，postName可以为中文。\n>注意，所有文件：后面都必须有个空格，不然会报错。\n\n看一下刚才生成的文件hexo\\source\\_posts\\postName.md，内容如下：\n\n\ttitle: postName #文章页面上的显示名称，可以任意修改，不会出现在URL中\n\tdate: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改\n\tcategories: #文章分类目录，可以为空，注意:后面有个空格\n\ttags: #文章标签，可空，多标签请用格式[tag1,tag2,tag3]，注意:后面有个空格\n\t---\n\t这里开始使用markdown格式输入你的正文。\n\n接下来，你就可以用喜爱的编辑器尽情书写你的文章。关于markdown语法，可以参考我的文章[Markdown简明语法]()。\n**fancybox**\n可能有人对这个Reading页面中图片的fancybox效果感兴趣，这个是怎么做的呢。\n很简单，只需要在你的文章*.md文件的头上添加photos项即可，然后一行行添加你要展示的照片：\n\n\tlayout: photo\n\ttitle: 我的阅历\n\tdate: 2085-01-16 07:33:44\n\ttags: [hexo]\n\tphotos:\n\t- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-0.jpg\n\t- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-1.jpg\n>经过测试，文件头上的layout: photo可以省略。\n\n不想每次都手动添加怎么办？同样的，打开您的hexo\\scaffolds\\photo.md\n\n\tlayout: { { layout } }\n\ttitle: { { title } }\n\tdate: { { date } }\n\ttags: \n\tphotos: \n\t- \n\t---\n\n然后每次可以执行带layout的new命令生成照片文章：\n\n\thexo new photo \"photoPostName\" #新建照片文章\n\n**description**\nmarkdown文件头中也可以添加description，以覆盖全局配置文件中的description内容，请参考下文_config.yml的介绍。\n\n\ttitle: hexo你的博客\n\tdate: 2013-11-22 17:11:54\n\tcategories: default\n\ttags: [hexo]\n\tdescription: 你对本页的描述\n\t---\n\n>hexo默认会处理全部markdown和html文件，如果不想让hexo处理你的文件，可以在文件头中加入layout: false。\n\n**文章摘要:**\n在需要显示摘要的地方添加如下代码即可：\n\n\t以上是摘要\n\t<!--more-->\n\t以下是余下全文\n\nmore以上内容即是文章摘要，在主页显示，more以下内容点击『> Read More』链接打开全文才显示。\n>hexo中所有文件的编码格式均是UTF-8。\n\n**主题安装**\n===\n萝卜白菜各有所爱，玩博客换主题是必不可少的，hexo的主题列表Hexo Themes。\n我比较喜欢pacman，modernist、ishgo，raytaylorism。Pacman最为优秀，简洁大方小清新，同时移动版本支持的也很好，但作者并没有把很多参数分离出来给出可配置项，我最终选择了modernist。\n\n安装主题的方法就是一句git命令：\n\n\tgit clone https://github.com/heroicyang/hexo-theme-modernist.git themes/modernist\n>目录是否是modernist无所谓，只要与_config.yml文件一致即可。\n\n安装完成后，打开hexo\\_config.yml，修改主题为modernist\n\n\ttheme: modernist\n打开hexo\\themes\\modernist目录，编辑主题配置文件_config.yml：\n\n\tmenu: #配置页头显示哪些菜单\n\t#  Home: /\n\t  Archives: /archives\n\t  Reading: /reading\n\t  About: /about\n\t#  Guestbook: /about\n\n\texcerpt_link: Read More #摘要链接文字\n\tarchive_yearly: false #按年存档\n\n\twidgets: #配置页脚显示哪些小挂件\n\t  - category\n\t#  - tag\n\t  - tagcloud\n\t  - recent_posts\n\t#  - blogroll\n\n\tblogrolls: #友情链接\n\t  - bruce sha's duapp wordpress: http://ibruce.duapp.com\n\t  - bruce sha's javaeye: http://buru.iteye.com\n\t  - bruce sha's oschina blog: http://my.oschina.net/buru\n\t  - bruce sha's baidu space: http://hi.baidu.com/iburu\n\n\tfancybox: true #是否开启fancybox效果\n\n\tduoshuo_shortname: buru #多说账号\n\n\tgoogle_analytics:\n\trss:\n\n更新主题\n\n\tcd themes/modernist\n\tgit pull\n**评论框**\n===\n静态博客要使用第三方评论系统，hexo默认集成的是Disqus，因为你懂的，所以国内的话还是建议用多说。\n直接用你的微博/豆瓣/人人/百度/开心网帐号登录多说，做一下基本设置。如果使用modernist主题，在modernist_config.yml中配置duoshuo_shortname为多说的基本设置->域名中的shortname即可。你也可以在多说后台自定义一下多说评论框的格式，比如评论框的位置，对于css设置，可以参考这里，我是在HeroicYang的基础上修改的。\n\n如果你是有的其他第三方评论系统，将通用代码粘贴到hexo\\themes\\modernist\\layout\\_partial\\comment.ejs里面，如下：\n\n\t<% if (config.disqus_shortname && page.comments){ %>\n\t<section id=\"comment\">\n\t  #你的通用代码\n\t<% } %>\n**自定义页面**\n===\n执行new page命令\n\n\thexo new page \"about\"\n在hexo\\source\\下会生成about目录，里面有个index.md，直接编辑就可以了，然后在主题的_config.yml中将其配置显示出来。\n上述步骤，也可以手工生成，在hexo\\source\\下手工新建about和index.md也是完全等价的。\n\n>因为markdown对table的支持不好，我是在about中直接建立index.html，里面书写页面内容，hexo会帮你加上头和尾。\n\n**404页面**\n===\nGitHub Pages 自定义[404页面](http://help.github.com/articles/custom-404-pages)非常容易，直接在根目录下创建自己的**404.html**就可以。但是自定义404页面仅对绑定顶级域名的项目才起作用，GitHub默认分配的二级域名是不起作用的，使用hexo server在本机调试也是不起作用的。\n其实，404页面可以做更多有意义的事，来做个404公益项目吧。做点有意义的事情，也对得起这个域名。\n目前有如下几个公益404接入地址，我选择了腾讯的。404页面，每个人可以做的更多。\n\n- [腾讯公益404](http://www.qq.com/404)\n- [404公益_益云(公益互联网)社会创新中心](http://yibo.iyiyun.com/Index/web404)\n- [失蹤兒童少年資料管理中心404](http://404page.missingkids.org.tw/)\n\n**图床**\n===\n考虑到博客的速度，同时也为了便于博客的迁移，图床是必须的。我墙裂推荐七牛，访问速度极快，支持日志、防盗链和水印。\n\n免费用户有每月10GB流量+总空间10GB+PUT/DELETE 10万次请求+GET 100万次请求，这对个人博客来说足够，也可通过邀请好友获得奖励。有一点要说明的是，七牛没有目录的概念，但是文件名可以包含/，比如2013/11/27/reading/photos-0.jpg，参考这里关于[key-value存储系统](http://kb.qiniu.com/key-value-system)。\n\n七牛除了作为图床还可以作为其他静态文件存储空间，比如我的个人站点首页有个字库文件和JS文件下载较慢，有时间会把它弄到七牛上去，以提高首页打开速度。请看这篇[Linux中国采用七牛云存储支撑图片访问](http://linux.cn/thread/11986/1/1)。\n\n如果非要说不足的话，就是文件管理界面不是很友好，不支持CNAME到分配的永久链接，也不能绑定未备案的自有域名，必须备案才可以。\n\n>如果你对七牛web版的文件管理界面不满意，可以用官方的[七牛云存储工具](http://docs.qiniu.com/tools/v6/index.html)。\n\n您还可以使用如下图床服务 [FarBox](http://www.farbox.com/)，[Dropbox](http://www.dropbox.com/)，[又拍云](http://www.upyun.com/)。\n\n**申请域名（可选）**\n===\nGitHubPages默认为每个用户分配了一个二级域名『your_user_name.github.com』或『your_user_name.github.io』。\n如果你对上述域名不满意，可以到[狗爹](http://www.godaddy.com/)，或者[万网](http://wanwang.aliyun.com/)上申请一个自己的域名，然后绑定到GitHub Pages。绑定方法很简单，在repo根目录下建立一个CNAME文件，里面写上域名即可。\n\n**GoDaddy**\n买域名首选狗爹，国内的服务商大家都懂的。\n目前.info域名只要￥18.99，但据说续费比较贵，我是先玩下，一年后再换，至于搜索引擎重新索引之类的，无所谓。.me和.com域名稍微贵点，大约￥60-100，网上有很多优惠码可用，可惜有的优惠码有限制。比如有个.com域名优惠码只要$1.99，但只能用国外信用卡购买。更多优惠码可以自行谷歌或到独特优惠码找。不着急的同学可以将中意的域名加入购物车先不付款，过几天，狗爹就会发优惠信息给你。狗爹不定期也会有活动，可以多关注。\n付款后，需要稍微等一会你才会拿到域名，特别是支付宝付款的，要等大约半小时左右。此外域名要一年年的买，这样比较划算。\n\n>建议大家申请.com或.me域名。据说.info因垃圾网站太多，被搜索引擎惩罚，而且续费较贵。\n\n**DNSPod**\nGoDaddy的NameServers有时会被墙，因此墙裂推荐国内的[DNSPod](http://www.dnspod.cn/)解析域名，免费服务真心不错。支持微信/邮件提醒，监控与报警，访问统计，健康诊断，搜索引擎推送，速度哇哇的，对于我来说足够。\n两步设置就可以搞定，怎么操作参考[Godaddy注册商域名修改DNS地址](http://support.dnspod.cn/Kb/showarticle/tsid/42)。\n\n**命令**\n===\n**常用命令：**\n\n\thexo new \"postName\" #新建文章\n\thexo new page \"pageName\" #新建页面\n\thexo generate #生成静态页面至public目录\n\thexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\n\thexo deploy #将.deploy目录部署到GitHub\n**常用复合命令：**\n\n\thexo deploy -g\n\thexo server -g\n**简写：**\n\t\n\thexo n == hexo new\n\thexo g == hexo generate\n\thexo s == hexo server\n\thexo d == hexo deploy\n\n---\n**至此，基本操作介绍完毕,如果有什么问题，欢迎评论问我，看到一定回复**\n===\n\n---","slug":"newHexo","published":1,"updated":"2016-11-01T04:01:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciuyzlusd0000e6tb8paarqu1","content":"<p> 早就想在github上搭建属于自己的博客了，一直没有腾出时间，Jekyll也觉得一般，前一阵一个朋友推荐hexo，看了看文档，很不错，也决定用hexo搭建一个自己的博客，下面是我摘自网络的教程，想搭建自己博客的朋友可以自己动手试一试。</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><a id=\"more\"></a></h2><p>hexo出自台湾大学生tommy351之手，是一个基于Node.js的静态博客程序，其编译上百篇文字只需要几秒。hexo生成的静态网页可以直接放到GitHub Pages，BAE，SAE等平台上。先看看tommy是如何吐槽Octopress的 →＿→ Hexo颯爽登場。</p>\n<blockquote>\n<ul>\n<li>如果你对默认配置满意，只需几个命令便可秒搭一个hexo。</li>\n<li>如果你跟我一样喜欢折腾下，30分钟也足够个性化。</li>\n<li>如果你过于喜欢折腾，可以折腾个把星期，尽情的玩。</li>\n</ul>\n</blockquote>\n<p>搭建过程你或许觉得有那么点小繁琐，但一旦搭建完成，写文章是极简单，极舒服的。<br>只需要几个简单命令，你就可以完成一切。</p>\n<pre><code>hexo n #写文章\nhexo g #生成\nhexo d #部署 # 可与hexo g合并为 hexo d -g\n</code></pre><p>下面逐步介绍，进入正题。</p>\n<hr>\n<h1 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a><strong>环境准备</strong></h1><p><strong>安装Node</strong><br>到<a href=\"http://nodejs.org/\" target=\"_blank\" rel=\"external\">Node.js官网</a>下载相应平台的最新版本，一路安装即可。我用的是<a href=\"http://nodejs.org/dist/v0.10.22/node-v0.10.22-x86.msi\" target=\"_blank\" rel=\"external\">node-v0.10.22-x86.msi</a><br><strong>安装Git</strong><br>Git的客户端很多，我用的是<a href=\"http://code.google.com/p/msysgit\" target=\"_blank\" rel=\"external\">msysgit</a>，喜欢用绿色版本<a href=\"http://code.google.com/p/msysgit/downloads/detail?name=PortableGit-1.8.4-preview20130916.7z\" target=\"_blank\" rel=\"external\">Portable application for official Git for Windows 1.8.4</a>，下载下来设置一下环境变量即可，Git_HOME，%Git_HOME%\\bin之类的，不多说。<br><strong>安装Sublime（可选）</strong><br><a href=\"http://www.sublimetext.com/\" target=\"_blank\" rel=\"external\">Sublime Text 2</a>在这里仅仅作为一个文本编辑器使用，支持各种编程语言和文件格式，当然也支持Markdown语法，实在是个不可多得的练码奇才。喜欢追鲜的也可以尝试处于beta版本的<a href=\"http://www.sublimetext.com/3\" target=\"_blank\" rel=\"external\">Sublime Text 3</a>。我用绿色版本<a href=\"http://c758482.r82.cf2.rackcdn.com/Sublime%20Text%202.0.2.zip\" target=\"_blank\" rel=\"external\">Portable Sublime Text 2.0.2.zip</a>。</p>\n<blockquote>\n<p><em>本屌是穷码畜，对于高大上的Mac码帅用户请移步：<a href=\"http://zespia.tw/hexo/docs/installation.html\" target=\"_blank\" rel=\"external\">hexo installation</a></em></p>\n</blockquote>\n<h1 id=\"GitHub\"><a href=\"#GitHub\" class=\"headerlink\" title=\"GitHub\"></a><strong>GitHub</strong></h1><blockquote>\n<p>GitHub账号和GitHub Pages 一般都应该有吧，已有的请自动无视这一部分。</p>\n</blockquote>\n<ul>\n<li>首先注册一个『GitHub』帐号，已有的默认默认请忽略</li>\n<li>建立与你用户名对应的仓库，仓库名必须为『your_user_name.github.com』</li>\n<li>添加SSH公钥到『Account settings -&gt; SSH Keys -&gt; Add SSH Key』<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/my-github-pages.jpg\" alt=\"GitHub Mark\" title=\"GitHub Mark\"></li>\n</ul>\n<p>前两步忽略，只说第三步，添加SSH-Key。</p>\n<p>首先设置你的用户名密码(邮箱和用户名改你自己的，下同)：</p>\n<pre><code>git config --global user.email &quot;bu.ru@qq.com&quot;\ngit config --global user.name &quot;bruce-sha&quot;\n</code></pre><p>生成密钥：</p>\n<pre><code>ssh-keygen -t rsa -C &quot;bu.ru@qq.com&quot;\n</code></pre><p>输入文件路径：</p>\n<pre><code>H:\\hexo\\blog&gt;ssh-keygen -t rsa -C &quot;bu.ru@qq.com&quot;\nGenerating public/private rsa key pair.\nEnter file in which to save the key (//.ssh/id_rsa): H:\\git\\myssh\\ssh\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\nYour identification has been saved in H:\\git\\myssh\\ssh.\nYour public key has been saved in H:\\git\\myssh\\ssh.pub.\nThe key fingerprint is:\nb0:0c:2e:67:33:ab:c1:50:10:40:0a:ba:c1:80:59:22 bu.ru@qq.com    \n</code></pre><blockquote>\n<p><em>有个bug，文件路径中的盘符H必须大写，否则会报错。</em></p>\n</blockquote>\n<p>上述命令若执行成功，会在H:\\git\\myssh目录下生成两个文件id_rsa和id_rsa.pub，最后两步：</p>\n<blockquote>\n<p>1.用文本编辑器打开ssh.pub文件，拷贝其中的内容，将其添加到Add SSH Key<br>2.将id_rsa和id_rsa.pub拷贝至你Git安装目录下的.ssh目录，如H:\\PortableGit-1.8.4.ssh</p>\n</blockquote>\n<p> <img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/add-ssh-keys.jpg\" alt=\"GitHub Mark\" title=\"GitHub Mark\"><br> 最后可以验证一下：</p>\n<pre><code>ssh -T git@github.com\n</code></pre><p>若有问题，请重新设置。常见错误请参考：<br><a href=\"http://help.github.com/articles/generating-ssh-keys\" target=\"_blank\" rel=\"external\">GitHub Help - Generating SSH Keys</a><br><a href=\"http://help.github.com/articles/error-permission-denied-publickey\" target=\"_blank\" rel=\"external\">GitHub Help - Error Permission denied (publickey)</a></p>\n<h1 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a><strong>安装</strong></h1><p>Node和Git都安装好后，可执行如下命令安装hexo：</p>\n<pre><code>npm install -g hexo\n</code></pre><h1 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a><strong>初始化</strong></h1><p>然后，执行init命令初始化hexo到你指定的目录：</p>\n<pre><code>hexo init &lt;folder&gt;\n</code></pre><blockquote>\n<p>也可以cd到目标目录，执行hexo init。</p>\n</blockquote>\n<p>好啦，至此，全部安装工作已经完成！</p>\n<h1 id=\"生成静态页面\"><a href=\"#生成静态页面\" class=\"headerlink\" title=\"生成静态页面\"></a><strong>生成静态页面</strong></h1><p>cd 到你的init目录，执行如下命令，生成静态页面至hexo\\public\\目录。</p>\n<pre><code>hexo generate\n</code></pre><blockquote>\n<ul>\n<li><em>命令必须在init目录下执行，否则不成功，但是也不报错。</em></li>\n<li><em>当你修改文章Tag或内容，不能正确重新生成内容，可以删除hexo\\db.json后重试，还不行就到public目录删除对应的文件，重新生成。</em></li>\n</ul>\n</blockquote>\n<h1 id=\"本地启动\"><a href=\"#本地启动\" class=\"headerlink\" title=\"本地启动\"></a><strong>本地启动</strong></h1><p>执行如下命令，启动本地服务，进行文章预览调试。</p>\n<pre><code>hexo server\n</code></pre><p>浏览器输入 <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"external\">http://localhost:4000</a> 就可以看到效果。</p>\n<blockquote>\n<p>请使用高级浏览器，否则可能…你懂的！</p>\n</blockquote>\n<h1 id=\"写文章\"><a href=\"#写文章\" class=\"headerlink\" title=\"写文章\"></a><strong>写文章</strong></h1><p>执行new命令，生成指定名称的文章至hexo\\source_posts\\postName.md。</p>\n<pre><code>hexo new [layout] &quot;postName&quot; #新建文章\n</code></pre><p>其中layout是可选参数，默认值为post。有哪些layout呢，请到scaffolds目录下查看，这些文件名称就是layout名称。当然你可以添加自己的layout，方法就是添加一个文件即可，同时你也可以编辑现有的layout，比如post的layout默认是hexo\\scaffolds\\post.md</p>\n<pre><code>title: { { title } }\ndate: { { date } }\ntags:\n---\n</code></pre><blockquote>\n<p>请注意，大括号与大括号之间我多加了个空格，否则会被转义，不能正常显示。</p>\n</blockquote>\n<p>我想添加categories，以免每次手工输入，只需要修改这个文件添加一行，如下:</p>\n<pre><code>title: { { title } }\ndate: { { date } }\ncategories: \ntags: \n---\n</code></pre><p>postName是md文件的名字，同时也出现在你文章的URL中，postName如果包含空格，必须用”将其包围，postName可以为中文。</p>\n<blockquote>\n<p>注意，所有文件：后面都必须有个空格，不然会报错。</p>\n</blockquote>\n<p>看一下刚才生成的文件hexo\\source_posts\\postName.md，内容如下：</p>\n<pre><code>title: postName #文章页面上的显示名称，可以任意修改，不会出现在URL中\ndate: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改\ncategories: #文章分类目录，可以为空，注意:后面有个空格\ntags: #文章标签，可空，多标签请用格式[tag1,tag2,tag3]，注意:后面有个空格\n---\n这里开始使用markdown格式输入你的正文。\n</code></pre><p>接下来，你就可以用喜爱的编辑器尽情书写你的文章。关于markdown语法，可以参考我的文章<a href=\"\">Markdown简明语法</a>。<br><strong>fancybox</strong><br>可能有人对这个Reading页面中图片的fancybox效果感兴趣，这个是怎么做的呢。<br>很简单，只需要在你的文章*.md文件的头上添加photos项即可，然后一行行添加你要展示的照片：</p>\n<pre><code>layout: photo\ntitle: 我的阅历\ndate: 2085-01-16 07:33:44\ntags: [hexo]\nphotos:\n- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-0.jpg\n- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-1.jpg\n</code></pre><blockquote>\n<p>经过测试，文件头上的layout: photo可以省略。</p>\n</blockquote>\n<p>不想每次都手动添加怎么办？同样的，打开您的hexo\\scaffolds\\photo.md</p>\n<pre><code>layout: { { layout } }\ntitle: { { title } }\ndate: { { date } }\ntags: \nphotos: \n- \n---\n</code></pre><p>然后每次可以执行带layout的new命令生成照片文章：</p>\n<pre><code>hexo new photo &quot;photoPostName&quot; #新建照片文章\n</code></pre><p><strong>description</strong><br>markdown文件头中也可以添加description，以覆盖全局配置文件中的description内容，请参考下文_config.yml的介绍。</p>\n<pre><code>title: hexo你的博客\ndate: 2013-11-22 17:11:54\ncategories: default\ntags: [hexo]\ndescription: 你对本页的描述\n---\n</code></pre><blockquote>\n<p>hexo默认会处理全部markdown和html文件，如果不想让hexo处理你的文件，可以在文件头中加入layout: false。</p>\n</blockquote>\n<p><strong>文章摘要:</strong><br>在需要显示摘要的地方添加如下代码即可：</p>\n<pre><code>以上是摘要\n&lt;!--more--&gt;\n以下是余下全文\n</code></pre><p>more以上内容即是文章摘要，在主页显示，more以下内容点击『&gt; Read More』链接打开全文才显示。</p>\n<blockquote>\n<p>hexo中所有文件的编码格式均是UTF-8。</p>\n</blockquote>\n<h1 id=\"主题安装\"><a href=\"#主题安装\" class=\"headerlink\" title=\"主题安装\"></a><strong>主题安装</strong></h1><p>萝卜白菜各有所爱，玩博客换主题是必不可少的，hexo的主题列表Hexo Themes。<br>我比较喜欢pacman，modernist、ishgo，raytaylorism。Pacman最为优秀，简洁大方小清新，同时移动版本支持的也很好，但作者并没有把很多参数分离出来给出可配置项，我最终选择了modernist。</p>\n<p>安装主题的方法就是一句git命令：</p>\n<pre><code>git clone https://github.com/heroicyang/hexo-theme-modernist.git themes/modernist\n</code></pre><blockquote>\n<p>目录是否是modernist无所谓，只要与_config.yml文件一致即可。</p>\n</blockquote>\n<p>安装完成后，打开hexo_config.yml，修改主题为modernist</p>\n<pre><code>theme: modernist\n</code></pre><p>打开hexo\\themes\\modernist目录，编辑主题配置文件_config.yml：</p>\n<pre><code>menu: #配置页头显示哪些菜单\n#  Home: /\n  Archives: /archives\n  Reading: /reading\n  About: /about\n#  Guestbook: /about\n\nexcerpt_link: Read More #摘要链接文字\narchive_yearly: false #按年存档\n\nwidgets: #配置页脚显示哪些小挂件\n  - category\n#  - tag\n  - tagcloud\n  - recent_posts\n#  - blogroll\n\nblogrolls: #友情链接\n  - bruce sha&apos;s duapp wordpress: http://ibruce.duapp.com\n  - bruce sha&apos;s javaeye: http://buru.iteye.com\n  - bruce sha&apos;s oschina blog: http://my.oschina.net/buru\n  - bruce sha&apos;s baidu space: http://hi.baidu.com/iburu\n\nfancybox: true #是否开启fancybox效果\n\nduoshuo_shortname: buru #多说账号\n\ngoogle_analytics:\nrss:\n</code></pre><p>更新主题</p>\n<pre><code>cd themes/modernist\ngit pull\n</code></pre><h1 id=\"评论框\"><a href=\"#评论框\" class=\"headerlink\" title=\"评论框\"></a><strong>评论框</strong></h1><p>静态博客要使用第三方评论系统，hexo默认集成的是Disqus，因为你懂的，所以国内的话还是建议用多说。<br>直接用你的微博/豆瓣/人人/百度/开心网帐号登录多说，做一下基本设置。如果使用modernist主题，在modernist_config.yml中配置duoshuo_shortname为多说的基本设置-&gt;域名中的shortname即可。你也可以在多说后台自定义一下多说评论框的格式，比如评论框的位置，对于css设置，可以参考这里，我是在HeroicYang的基础上修改的。</p>\n<p>如果你是有的其他第三方评论系统，将通用代码粘贴到hexo\\themes\\modernist\\layout_partial\\comment.ejs里面，如下：</p>\n<pre><code>&lt;% if (config.disqus_shortname &amp;&amp; page.comments){ %&gt;\n&lt;section id=&quot;comment&quot;&gt;\n  #你的通用代码\n&lt;% } %&gt;\n</code></pre><h1 id=\"自定义页面\"><a href=\"#自定义页面\" class=\"headerlink\" title=\"自定义页面\"></a><strong>自定义页面</strong></h1><p>执行new page命令</p>\n<pre><code>hexo new page &quot;about&quot;\n</code></pre><p>在hexo\\source\\下会生成about目录，里面有个index.md，直接编辑就可以了，然后在主题的_config.yml中将其配置显示出来。<br>上述步骤，也可以手工生成，在hexo\\source\\下手工新建about和index.md也是完全等价的。</p>\n<blockquote>\n<p>因为markdown对table的支持不好，我是在about中直接建立index.html，里面书写页面内容，hexo会帮你加上头和尾。</p>\n</blockquote>\n<h1 id=\"404页面\"><a href=\"#404页面\" class=\"headerlink\" title=\"404页面\"></a><strong>404页面</strong></h1><p>GitHub Pages 自定义<a href=\"http://help.github.com/articles/custom-404-pages\" target=\"_blank\" rel=\"external\">404页面</a>非常容易，直接在根目录下创建自己的<strong>404.html</strong>就可以。但是自定义404页面仅对绑定顶级域名的项目才起作用，GitHub默认分配的二级域名是不起作用的，使用hexo server在本机调试也是不起作用的。<br>其实，404页面可以做更多有意义的事，来做个404公益项目吧。做点有意义的事情，也对得起这个域名。<br>目前有如下几个公益404接入地址，我选择了腾讯的。404页面，每个人可以做的更多。</p>\n<ul>\n<li><a href=\"http://www.qq.com/404\" target=\"_blank\" rel=\"external\">腾讯公益404</a></li>\n<li><a href=\"http://yibo.iyiyun.com/Index/web404\" target=\"_blank\" rel=\"external\">404公益_益云(公益互联网)社会创新中心</a></li>\n<li><a href=\"http://404page.missingkids.org.tw/\" target=\"_blank\" rel=\"external\">失蹤兒童少年資料管理中心404</a></li>\n</ul>\n<h1 id=\"图床\"><a href=\"#图床\" class=\"headerlink\" title=\"图床\"></a><strong>图床</strong></h1><p>考虑到博客的速度，同时也为了便于博客的迁移，图床是必须的。我墙裂推荐七牛，访问速度极快，支持日志、防盗链和水印。</p>\n<p>免费用户有每月10GB流量+总空间10GB+PUT/DELETE 10万次请求+GET 100万次请求，这对个人博客来说足够，也可通过邀请好友获得奖励。有一点要说明的是，七牛没有目录的概念，但是文件名可以包含/，比如2013/11/27/reading/photos-0.jpg，参考这里关于<a href=\"http://kb.qiniu.com/key-value-system\" target=\"_blank\" rel=\"external\">key-value存储系统</a>。</p>\n<p>七牛除了作为图床还可以作为其他静态文件存储空间，比如我的个人站点首页有个字库文件和JS文件下载较慢，有时间会把它弄到七牛上去，以提高首页打开速度。请看这篇<a href=\"http://linux.cn/thread/11986/1/1\" target=\"_blank\" rel=\"external\">Linux中国采用七牛云存储支撑图片访问</a>。</p>\n<p>如果非要说不足的话，就是文件管理界面不是很友好，不支持CNAME到分配的永久链接，也不能绑定未备案的自有域名，必须备案才可以。</p>\n<blockquote>\n<p>如果你对七牛web版的文件管理界面不满意，可以用官方的<a href=\"http://docs.qiniu.com/tools/v6/index.html\" target=\"_blank\" rel=\"external\">七牛云存储工具</a>。</p>\n</blockquote>\n<p>您还可以使用如下图床服务 <a href=\"http://www.farbox.com/\" target=\"_blank\" rel=\"external\">FarBox</a>，<a href=\"http://www.dropbox.com/\" target=\"_blank\" rel=\"external\">Dropbox</a>，<a href=\"http://www.upyun.com/\" target=\"_blank\" rel=\"external\">又拍云</a>。</p>\n<h1 id=\"申请域名（可选）\"><a href=\"#申请域名（可选）\" class=\"headerlink\" title=\"申请域名（可选）\"></a><strong>申请域名（可选）</strong></h1><p>GitHubPages默认为每个用户分配了一个二级域名『your_user_name.github.com』或『your_user_name.github.io』。<br>如果你对上述域名不满意，可以到<a href=\"http://www.godaddy.com/\" target=\"_blank\" rel=\"external\">狗爹</a>，或者<a href=\"http://wanwang.aliyun.com/\" target=\"_blank\" rel=\"external\">万网</a>上申请一个自己的域名，然后绑定到GitHub Pages。绑定方法很简单，在repo根目录下建立一个CNAME文件，里面写上域名即可。</p>\n<p><strong>GoDaddy</strong><br>买域名首选狗爹，国内的服务商大家都懂的。<br>目前.info域名只要￥18.99，但据说续费比较贵，我是先玩下，一年后再换，至于搜索引擎重新索引之类的，无所谓。.me和.com域名稍微贵点，大约￥60-100，网上有很多优惠码可用，可惜有的优惠码有限制。比如有个.com域名优惠码只要$1.99，但只能用国外信用卡购买。更多优惠码可以自行谷歌或到独特优惠码找。不着急的同学可以将中意的域名加入购物车先不付款，过几天，狗爹就会发优惠信息给你。狗爹不定期也会有活动，可以多关注。<br>付款后，需要稍微等一会你才会拿到域名，特别是支付宝付款的，要等大约半小时左右。此外域名要一年年的买，这样比较划算。</p>\n<blockquote>\n<p>建议大家申请.com或.me域名。据说.info因垃圾网站太多，被搜索引擎惩罚，而且续费较贵。</p>\n</blockquote>\n<p><strong>DNSPod</strong><br>GoDaddy的NameServers有时会被墙，因此墙裂推荐国内的<a href=\"http://www.dnspod.cn/\" target=\"_blank\" rel=\"external\">DNSPod</a>解析域名，免费服务真心不错。支持微信/邮件提醒，监控与报警，访问统计，健康诊断，搜索引擎推送，速度哇哇的，对于我来说足够。<br>两步设置就可以搞定，怎么操作参考<a href=\"http://support.dnspod.cn/Kb/showarticle/tsid/42\" target=\"_blank\" rel=\"external\">Godaddy注册商域名修改DNS地址</a>。</p>\n<h1 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a><strong>命令</strong></h1><p><strong>常用命令：</strong></p>\n<pre><code>hexo new &quot;postName&quot; #新建文章\nhexo new page &quot;pageName&quot; #新建页面\nhexo generate #生成静态页面至public目录\nhexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）\nhexo deploy #将.deploy目录部署到GitHub\n</code></pre><p><strong>常用复合命令：</strong></p>\n<pre><code>hexo deploy -g\nhexo server -g\n</code></pre><p><strong>简写：</strong></p>\n<pre><code>hexo n == hexo new\nhexo g == hexo generate\nhexo s == hexo server\nhexo d == hexo deploy\n</code></pre><hr>\n<h1 id=\"至此，基本操作介绍完毕-如果有什么问题，欢迎评论问我，看到一定回复\"><a href=\"#至此，基本操作介绍完毕-如果有什么问题，欢迎评论问我，看到一定回复\" class=\"headerlink\" title=\"至此，基本操作介绍完毕,如果有什么问题，欢迎评论问我，看到一定回复\"></a><strong>至此，基本操作介绍完毕,如果有什么问题，欢迎评论问我，看到一定回复</strong></h1><hr>\n","excerpt":"<p> 早就想在github上搭建属于自己的博客了，一直没有腾出时间，Jekyll也觉得一般，前一阵一个朋友推荐hexo，看了看文档，很不错，也决定用hexo搭建一个自己的博客，下面是我摘自网络的教程，想搭建自己博客的朋友可以自己动手试一试。</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a>","more":"</h2><p>hexo出自台湾大学生tommy351之手，是一个基于Node.js的静态博客程序，其编译上百篇文字只需要几秒。hexo生成的静态网页可以直接放到GitHub Pages，BAE，SAE等平台上。先看看tommy是如何吐槽Octopress的 →＿→ Hexo颯爽登場。</p>\n<blockquote>\n<ul>\n<li>如果你对默认配置满意，只需几个命令便可秒搭一个hexo。</li>\n<li>如果你跟我一样喜欢折腾下，30分钟也足够个性化。</li>\n<li>如果你过于喜欢折腾，可以折腾个把星期，尽情的玩。</li>\n</ul>\n</blockquote>\n<p>搭建过程你或许觉得有那么点小繁琐，但一旦搭建完成，写文章是极简单，极舒服的。<br>只需要几个简单命令，你就可以完成一切。</p>\n<pre><code>hexo n #写文章\nhexo g #生成\nhexo d #部署 # 可与hexo g合并为 hexo d -g\n</code></pre><p>下面逐步介绍，进入正题。</p>\n<hr>\n<h1 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a><strong>环境准备</strong></h1><p><strong>安装Node</strong><br>到<a href=\"http://nodejs.org/\">Node.js官网</a>下载相应平台的最新版本，一路安装即可。我用的是<a href=\"http://nodejs.org/dist/v0.10.22/node-v0.10.22-x86.msi\">node-v0.10.22-x86.msi</a><br><strong>安装Git</strong><br>Git的客户端很多，我用的是<a href=\"http://code.google.com/p/msysgit\">msysgit</a>，喜欢用绿色版本<a href=\"http://code.google.com/p/msysgit/downloads/detail?name=PortableGit-1.8.4-preview20130916.7z\">Portable application for official Git for Windows 1.8.4</a>，下载下来设置一下环境变量即可，Git_HOME，%Git_HOME%\\bin之类的，不多说。<br><strong>安装Sublime（可选）</strong><br><a href=\"http://www.sublimetext.com/\">Sublime Text 2</a>在这里仅仅作为一个文本编辑器使用，支持各种编程语言和文件格式，当然也支持Markdown语法，实在是个不可多得的练码奇才。喜欢追鲜的也可以尝试处于beta版本的<a href=\"http://www.sublimetext.com/3\">Sublime Text 3</a>。我用绿色版本<a href=\"http://c758482.r82.cf2.rackcdn.com/Sublime%20Text%202.0.2.zip\">Portable Sublime Text 2.0.2.zip</a>。</p>\n<blockquote>\n<p><em>本屌是穷码畜，对于高大上的Mac码帅用户请移步：<a href=\"http://zespia.tw/hexo/docs/installation.html\">hexo installation</a></em></p>\n</blockquote>\n<h1 id=\"GitHub\"><a href=\"#GitHub\" class=\"headerlink\" title=\"GitHub\"></a><strong>GitHub</strong></h1><blockquote>\n<p>GitHub账号和GitHub Pages 一般都应该有吧，已有的请自动无视这一部分。</p>\n</blockquote>\n<ul>\n<li>首先注册一个『GitHub』帐号，已有的默认默认请忽略</li>\n<li>建立与你用户名对应的仓库，仓库名必须为『your_user_name.github.com』</li>\n<li>添加SSH公钥到『Account settings -&gt; SSH Keys -&gt; Add SSH Key』<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/my-github-pages.jpg\" alt=\"GitHub Mark\" title=\"GitHub Mark\"></li>\n</ul>\n<p>前两步忽略，只说第三步，添加SSH-Key。</p>\n<p>首先设置你的用户名密码(邮箱和用户名改你自己的，下同)：</p>\n<pre><code>git config --global user.email &quot;bu.ru@qq.com&quot;\ngit config --global user.name &quot;bruce-sha&quot;\n</code></pre><p>生成密钥：</p>\n<pre><code>ssh-keygen -t rsa -C &quot;bu.ru@qq.com&quot;\n</code></pre><p>输入文件路径：</p>\n<pre><code>H:\\hexo\\blog&gt;ssh-keygen -t rsa -C &quot;bu.ru@qq.com&quot;\nGenerating public/private rsa key pair.\nEnter file in which to save the key (//.ssh/id_rsa): H:\\git\\myssh\\ssh\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\nYour identification has been saved in H:\\git\\myssh\\ssh.\nYour public key has been saved in H:\\git\\myssh\\ssh.pub.\nThe key fingerprint is:\nb0:0c:2e:67:33:ab:c1:50:10:40:0a:ba:c1:80:59:22 bu.ru@qq.com    \n</code></pre><blockquote>\n<p><em>有个bug，文件路径中的盘符H必须大写，否则会报错。</em></p>\n</blockquote>\n<p>上述命令若执行成功，会在H:\\git\\myssh目录下生成两个文件id_rsa和id_rsa.pub，最后两步：</p>\n<blockquote>\n<p>1.用文本编辑器打开ssh.pub文件，拷贝其中的内容，将其添加到Add SSH Key<br>2.将id_rsa和id_rsa.pub拷贝至你Git安装目录下的.ssh目录，如H:\\PortableGit-1.8.4.ssh</p>\n</blockquote>\n<p> <img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/add-ssh-keys.jpg\" alt=\"GitHub Mark\" title=\"GitHub Mark\"><br> 最后可以验证一下：</p>\n<pre><code>ssh -T git@github.com\n</code></pre><p>若有问题，请重新设置。常见错误请参考：<br><a href=\"http://help.github.com/articles/generating-ssh-keys\">GitHub Help - Generating SSH Keys</a><br><a href=\"http://help.github.com/articles/error-permission-denied-publickey\">GitHub Help - Error Permission denied (publickey)</a></p>\n<h1 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a><strong>安装</strong></h1><p>Node和Git都安装好后，可执行如下命令安装hexo：</p>\n<pre><code>npm install -g hexo\n</code></pre><h1 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a><strong>初始化</strong></h1><p>然后，执行init命令初始化hexo到你指定的目录：</p>\n<pre><code>hexo init &lt;folder&gt;\n</code></pre><blockquote>\n<p>也可以cd到目标目录，执行hexo init。</p>\n</blockquote>\n<p>好啦，至此，全部安装工作已经完成！</p>\n<h1 id=\"生成静态页面\"><a href=\"#生成静态页面\" class=\"headerlink\" title=\"生成静态页面\"></a><strong>生成静态页面</strong></h1><p>cd 到你的init目录，执行如下命令，生成静态页面至hexo\\public\\目录。</p>\n<pre><code>hexo generate\n</code></pre><blockquote>\n<ul>\n<li><em>命令必须在init目录下执行，否则不成功，但是也不报错。</em></li>\n<li><em>当你修改文章Tag或内容，不能正确重新生成内容，可以删除hexo\\db.json后重试，还不行就到public目录删除对应的文件，重新生成。</em></li>\n</ul>\n</blockquote>\n<h1 id=\"本地启动\"><a href=\"#本地启动\" class=\"headerlink\" title=\"本地启动\"></a><strong>本地启动</strong></h1><p>执行如下命令，启动本地服务，进行文章预览调试。</p>\n<pre><code>hexo server\n</code></pre><p>浏览器输入 <a href=\"http://localhost:4000\">http://localhost:4000</a> 就可以看到效果。</p>\n<blockquote>\n<p>请使用高级浏览器，否则可能…你懂的！</p>\n</blockquote>\n<h1 id=\"写文章\"><a href=\"#写文章\" class=\"headerlink\" title=\"写文章\"></a><strong>写文章</strong></h1><p>执行new命令，生成指定名称的文章至hexo\\source_posts\\postName.md。</p>\n<pre><code>hexo new [layout] &quot;postName&quot; #新建文章\n</code></pre><p>其中layout是可选参数，默认值为post。有哪些layout呢，请到scaffolds目录下查看，这些文件名称就是layout名称。当然你可以添加自己的layout，方法就是添加一个文件即可，同时你也可以编辑现有的layout，比如post的layout默认是hexo\\scaffolds\\post.md</p>\n<pre><code>title: { { title } }\ndate: { { date } }\ntags:\n---\n</code></pre><blockquote>\n<p>请注意，大括号与大括号之间我多加了个空格，否则会被转义，不能正常显示。</p>\n</blockquote>\n<p>我想添加categories，以免每次手工输入，只需要修改这个文件添加一行，如下:</p>\n<pre><code>title: { { title } }\ndate: { { date } }\ncategories: \ntags: \n---\n</code></pre><p>postName是md文件的名字，同时也出现在你文章的URL中，postName如果包含空格，必须用”将其包围，postName可以为中文。</p>\n<blockquote>\n<p>注意，所有文件：后面都必须有个空格，不然会报错。</p>\n</blockquote>\n<p>看一下刚才生成的文件hexo\\source_posts\\postName.md，内容如下：</p>\n<pre><code>title: postName #文章页面上的显示名称，可以任意修改，不会出现在URL中\ndate: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改\ncategories: #文章分类目录，可以为空，注意:后面有个空格\ntags: #文章标签，可空，多标签请用格式[tag1,tag2,tag3]，注意:后面有个空格\n---\n这里开始使用markdown格式输入你的正文。\n</code></pre><p>接下来，你就可以用喜爱的编辑器尽情书写你的文章。关于markdown语法，可以参考我的文章<a href=\"\">Markdown简明语法</a>。<br><strong>fancybox</strong><br>可能有人对这个Reading页面中图片的fancybox效果感兴趣，这个是怎么做的呢。<br>很简单，只需要在你的文章*.md文件的头上添加photos项即可，然后一行行添加你要展示的照片：</p>\n<pre><code>layout: photo\ntitle: 我的阅历\ndate: 2085-01-16 07:33:44\ntags: [hexo]\nphotos:\n- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-0.jpg\n- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-1.jpg\n</code></pre><blockquote>\n<p>经过测试，文件头上的layout: photo可以省略。</p>\n</blockquote>\n<p>不想每次都手动添加怎么办？同样的，打开您的hexo\\scaffolds\\photo.md</p>\n<pre><code>layout: { { layout } }\ntitle: { { title } }\ndate: { { date } }\ntags: \nphotos: \n- \n---\n</code></pre><p>然后每次可以执行带layout的new命令生成照片文章：</p>\n<pre><code>hexo new photo &quot;photoPostName&quot; #新建照片文章\n</code></pre><p><strong>description</strong><br>markdown文件头中也可以添加description，以覆盖全局配置文件中的description内容，请参考下文_config.yml的介绍。</p>\n<pre><code>title: hexo你的博客\ndate: 2013-11-22 17:11:54\ncategories: default\ntags: [hexo]\ndescription: 你对本页的描述\n---\n</code></pre><blockquote>\n<p>hexo默认会处理全部markdown和html文件，如果不想让hexo处理你的文件，可以在文件头中加入layout: false。</p>\n</blockquote>\n<p><strong>文章摘要:</strong><br>在需要显示摘要的地方添加如下代码即可：</p>\n<pre><code>以上是摘要\n&lt;!--more--&gt;\n以下是余下全文\n</code></pre><p>more以上内容即是文章摘要，在主页显示，more以下内容点击『&gt; Read More』链接打开全文才显示。</p>\n<blockquote>\n<p>hexo中所有文件的编码格式均是UTF-8。</p>\n</blockquote>\n<h1 id=\"主题安装\"><a href=\"#主题安装\" class=\"headerlink\" title=\"主题安装\"></a><strong>主题安装</strong></h1><p>萝卜白菜各有所爱，玩博客换主题是必不可少的，hexo的主题列表Hexo Themes。<br>我比较喜欢pacman，modernist、ishgo，raytaylorism。Pacman最为优秀，简洁大方小清新，同时移动版本支持的也很好，但作者并没有把很多参数分离出来给出可配置项，我最终选择了modernist。</p>\n<p>安装主题的方法就是一句git命令：</p>\n<pre><code>git clone https://github.com/heroicyang/hexo-theme-modernist.git themes/modernist\n</code></pre><blockquote>\n<p>目录是否是modernist无所谓，只要与_config.yml文件一致即可。</p>\n</blockquote>\n<p>安装完成后，打开hexo_config.yml，修改主题为modernist</p>\n<pre><code>theme: modernist\n</code></pre><p>打开hexo\\themes\\modernist目录，编辑主题配置文件_config.yml：</p>\n<pre><code>menu: #配置页头显示哪些菜单\n#  Home: /\n  Archives: /archives\n  Reading: /reading\n  About: /about\n#  Guestbook: /about\n\nexcerpt_link: Read More #摘要链接文字\narchive_yearly: false #按年存档\n\nwidgets: #配置页脚显示哪些小挂件\n  - category\n#  - tag\n  - tagcloud\n  - recent_posts\n#  - blogroll\n\nblogrolls: #友情链接\n  - bruce sha&apos;s duapp wordpress: http://ibruce.duapp.com\n  - bruce sha&apos;s javaeye: http://buru.iteye.com\n  - bruce sha&apos;s oschina blog: http://my.oschina.net/buru\n  - bruce sha&apos;s baidu space: http://hi.baidu.com/iburu\n\nfancybox: true #是否开启fancybox效果\n\nduoshuo_shortname: buru #多说账号\n\ngoogle_analytics:\nrss:\n</code></pre><p>更新主题</p>\n<pre><code>cd themes/modernist\ngit pull\n</code></pre><h1 id=\"评论框\"><a href=\"#评论框\" class=\"headerlink\" title=\"评论框\"></a><strong>评论框</strong></h1><p>静态博客要使用第三方评论系统，hexo默认集成的是Disqus，因为你懂的，所以国内的话还是建议用多说。<br>直接用你的微博/豆瓣/人人/百度/开心网帐号登录多说，做一下基本设置。如果使用modernist主题，在modernist_config.yml中配置duoshuo_shortname为多说的基本设置-&gt;域名中的shortname即可。你也可以在多说后台自定义一下多说评论框的格式，比如评论框的位置，对于css设置，可以参考这里，我是在HeroicYang的基础上修改的。</p>\n<p>如果你是有的其他第三方评论系统，将通用代码粘贴到hexo\\themes\\modernist\\layout_partial\\comment.ejs里面，如下：</p>\n<pre><code>&lt;% if (config.disqus_shortname &amp;&amp; page.comments){ %&gt;\n&lt;section id=&quot;comment&quot;&gt;\n  #你的通用代码\n&lt;% } %&gt;\n</code></pre><h1 id=\"自定义页面\"><a href=\"#自定义页面\" class=\"headerlink\" title=\"自定义页面\"></a><strong>自定义页面</strong></h1><p>执行new page命令</p>\n<pre><code>hexo new page &quot;about&quot;\n</code></pre><p>在hexo\\source\\下会生成about目录，里面有个index.md，直接编辑就可以了，然后在主题的_config.yml中将其配置显示出来。<br>上述步骤，也可以手工生成，在hexo\\source\\下手工新建about和index.md也是完全等价的。</p>\n<blockquote>\n<p>因为markdown对table的支持不好，我是在about中直接建立index.html，里面书写页面内容，hexo会帮你加上头和尾。</p>\n</blockquote>\n<h1 id=\"404页面\"><a href=\"#404页面\" class=\"headerlink\" title=\"404页面\"></a><strong>404页面</strong></h1><p>GitHub Pages 自定义<a href=\"http://help.github.com/articles/custom-404-pages\">404页面</a>非常容易，直接在根目录下创建自己的<strong>404.html</strong>就可以。但是自定义404页面仅对绑定顶级域名的项目才起作用，GitHub默认分配的二级域名是不起作用的，使用hexo server在本机调试也是不起作用的。<br>其实，404页面可以做更多有意义的事，来做个404公益项目吧。做点有意义的事情，也对得起这个域名。<br>目前有如下几个公益404接入地址，我选择了腾讯的。404页面，每个人可以做的更多。</p>\n<ul>\n<li><a href=\"http://www.qq.com/404\">腾讯公益404</a></li>\n<li><a href=\"http://yibo.iyiyun.com/Index/web404\">404公益_益云(公益互联网)社会创新中心</a></li>\n<li><a href=\"http://404page.missingkids.org.tw/\">失蹤兒童少年資料管理中心404</a></li>\n</ul>\n<h1 id=\"图床\"><a href=\"#图床\" class=\"headerlink\" title=\"图床\"></a><strong>图床</strong></h1><p>考虑到博客的速度，同时也为了便于博客的迁移，图床是必须的。我墙裂推荐七牛，访问速度极快，支持日志、防盗链和水印。</p>\n<p>免费用户有每月10GB流量+总空间10GB+PUT/DELETE 10万次请求+GET 100万次请求，这对个人博客来说足够，也可通过邀请好友获得奖励。有一点要说明的是，七牛没有目录的概念，但是文件名可以包含/，比如2013/11/27/reading/photos-0.jpg，参考这里关于<a href=\"http://kb.qiniu.com/key-value-system\">key-value存储系统</a>。</p>\n<p>七牛除了作为图床还可以作为其他静态文件存储空间，比如我的个人站点首页有个字库文件和JS文件下载较慢，有时间会把它弄到七牛上去，以提高首页打开速度。请看这篇<a href=\"http://linux.cn/thread/11986/1/1\">Linux中国采用七牛云存储支撑图片访问</a>。</p>\n<p>如果非要说不足的话，就是文件管理界面不是很友好，不支持CNAME到分配的永久链接，也不能绑定未备案的自有域名，必须备案才可以。</p>\n<blockquote>\n<p>如果你对七牛web版的文件管理界面不满意，可以用官方的<a href=\"http://docs.qiniu.com/tools/v6/index.html\">七牛云存储工具</a>。</p>\n</blockquote>\n<p>您还可以使用如下图床服务 <a href=\"http://www.farbox.com/\">FarBox</a>，<a href=\"http://www.dropbox.com/\">Dropbox</a>，<a href=\"http://www.upyun.com/\">又拍云</a>。</p>\n<h1 id=\"申请域名（可选）\"><a href=\"#申请域名（可选）\" class=\"headerlink\" title=\"申请域名（可选）\"></a><strong>申请域名（可选）</strong></h1><p>GitHubPages默认为每个用户分配了一个二级域名『your_user_name.github.com』或『your_user_name.github.io』。<br>如果你对上述域名不满意，可以到<a href=\"http://www.godaddy.com/\">狗爹</a>，或者<a href=\"http://wanwang.aliyun.com/\">万网</a>上申请一个自己的域名，然后绑定到GitHub Pages。绑定方法很简单，在repo根目录下建立一个CNAME文件，里面写上域名即可。</p>\n<p><strong>GoDaddy</strong><br>买域名首选狗爹，国内的服务商大家都懂的。<br>目前.info域名只要￥18.99，但据说续费比较贵，我是先玩下，一年后再换，至于搜索引擎重新索引之类的，无所谓。.me和.com域名稍微贵点，大约￥60-100，网上有很多优惠码可用，可惜有的优惠码有限制。比如有个.com域名优惠码只要$1.99，但只能用国外信用卡购买。更多优惠码可以自行谷歌或到独特优惠码找。不着急的同学可以将中意的域名加入购物车先不付款，过几天，狗爹就会发优惠信息给你。狗爹不定期也会有活动，可以多关注。<br>付款后，需要稍微等一会你才会拿到域名，特别是支付宝付款的，要等大约半小时左右。此外域名要一年年的买，这样比较划算。</p>\n<blockquote>\n<p>建议大家申请.com或.me域名。据说.info因垃圾网站太多，被搜索引擎惩罚，而且续费较贵。</p>\n</blockquote>\n<p><strong>DNSPod</strong><br>GoDaddy的NameServers有时会被墙，因此墙裂推荐国内的<a href=\"http://www.dnspod.cn/\">DNSPod</a>解析域名，免费服务真心不错。支持微信/邮件提醒，监控与报警，访问统计，健康诊断，搜索引擎推送，速度哇哇的，对于我来说足够。<br>两步设置就可以搞定，怎么操作参考<a href=\"http://support.dnspod.cn/Kb/showarticle/tsid/42\">Godaddy注册商域名修改DNS地址</a>。</p>\n<h1 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a><strong>命令</strong></h1><p><strong>常用命令：</strong></p>\n<pre><code>hexo new &quot;postName&quot; #新建文章\nhexo new page &quot;pageName&quot; #新建页面\nhexo generate #生成静态页面至public目录\nhexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）\nhexo deploy #将.deploy目录部署到GitHub\n</code></pre><p><strong>常用复合命令：</strong></p>\n<pre><code>hexo deploy -g\nhexo server -g\n</code></pre><p><strong>简写：</strong></p>\n<pre><code>hexo n == hexo new\nhexo g == hexo generate\nhexo s == hexo server\nhexo d == hexo deploy\n</code></pre><hr>\n<h1 id=\"至此，基本操作介绍完毕-如果有什么问题，欢迎评论问我，看到一定回复\"><a href=\"#至此，基本操作介绍完毕-如果有什么问题，欢迎评论问我，看到一定回复\" class=\"headerlink\" title=\"至此，基本操作介绍完毕,如果有什么问题，欢迎评论问我，看到一定回复\"></a><strong>至此，基本操作介绍完毕,如果有什么问题，欢迎评论问我，看到一定回复</strong></h1><hr>"},{"title":"与脚本相关的兼容性问题","date":"2015-08-15T08:20:38.000Z","keywords":"javascript兼容性, js兼容性, 浏览器兼容性","_content":"内容如题\n<!-- more -->\n---\n\n> - 1、IE Chrome Opera 中，cookie 中可以保存 Unicode 字符；Firefox 则会将中文字符内码将被转换为 Unicode 编码；Safari 会忽略包含中文字符的键值对。\n>> 解决办法：在设置和读取 cookie 时，始终为字符进行编解码操作，推荐使用 \"encodeURIComponent\" 和 \"decodeURIComponent\" 方法做相应编解码工作。\n\n> - 2、IE Firefox Opera 在自定义提交方式下不会提交普通按钮及提交按钮的键值对信息；而 Chrome Safari 会将这些信息也提交给服务器端。\n>> 解决办法：通常情况下，服务器端不需要按钮的 key/value 信息，建议删除按钮的 name 属性，不使其成为 successful control。\n\n> - 3、Content-Type 报头字符串代表着服务器端发送给客户端浏览器的具体数据类型，浏览器将根据这个信息决定如何处理得到的数据内容。比如：'Content-Type:text/html' 表示着这是个 HTML 文件，需要渲染引擎解释内容后输出；'Content-Type: application/octet-stream' 表示这是个二进制流，需要下载到本地后由用户端环境决定如何使用。\n每个浏览器内置支持的 Content-Type 类型表各不相同，这导致了某些类型字符串在某些浏览器下不被识别；另外，如果出现错误的 Content-Type 类型，各个浏览器又会以不同的方式处理。\n>> 解决办法：这个问题比较复杂，如需避免出现显示异常，建议不要使用非法的 Content-Type 头字符串；并且文件实际内容和数据格式应与 Content-Type 头字符串内类型声明一致。\n\n> - 4、在 IE6 IE7 IE8 中，若一个页面被打开时接收到的响应头的 content-type 为 text/plain，浏览器会尝试嗅探页面文件内实际内容来判断是否可能为一个 HTML 文档，若是则会以 text/html 的方式将页面作为 HTML 文档解释，而不是将其作为纯文本内容处理。\n>> 解决办法：这是由于 IE 浏览器的特有内容嗅探机制导致，故在不修改服务器端代码的情况下，无法通过常规办法解决此 IE 特性问题。更多关于此问题的资料参考官方信息：Internet Explorer 未按预期方式处理“Text/Plain”内容类型。\n合理、正确地设置文档的 content-type 是最佳的解决方案，同时应避免在非 HTML 文件中出现可被 IE6 IE7 IE8 嗅探机制捕获的 HTML、BODY、HEAD、TITLE 标记书写格式。\n\n> - 5、IE6 不支持 RSS，使用浏览器打开响应头为 application/rss+xml 的内容会当做二进制文件而提示下载；Chrome 会将 application/rss+xml 以纯文本处理而显示出源代码。\n>> 解决办法：各浏览器对于 RSS 的支持及渲染方式为浏览器各自实现导致，故无法通过常规办法使各浏览器达到一致的效果，对于暂不支持 RSS 的浏览器应给予提示。Chrome 可通过安装扩展插件实现此功能。\n\n\n> - 6、IE6 IE7 IE8 始终不在使用 META 元素控制跳转时附加 Referer 字段到请求头中。在普通页面中，当脚本调用 location 对象进行跳转时也不会附加 Referer 字段信息；\nFirefox 始终不在使用 META 元素控制跳转时附加 Referer 字段到请求头中。\n>> 解决办法：若服务端需要获得正确的 Referer 字段信息，则应采用各浏览器均可以附加 Referer 字段信息的方式进行跳转。如，普通超链接、表单提交、HTTP 302 跳转。\n\n> - 7、如果服务器端产生 HTTP 400 错误，并且在服务器端没有配置相应的显示页面，则会由本地客户端使用本地资源文件显示此错误信息。但是各浏览器的本地资源提示不同，更有些浏览器使用空白页代替本体错误提示页，造成用户识别混淆。\n>> 解决办法：HTTP 出错时返回错误代码，如果服务器端没有设置显示该问题的页面，则会由本地浏览器根据本地预置资源文件来显示，这些本地页面的显示风格由各浏览器决定，无法由用户控制。因此最好的解决方案还是在服务器端配置所有的错误代码对应的远程页面。","source":"_posts/与服务端通信相关的兼容性问题.md","raw":"title: 与脚本相关的兼容性问题\ndate: 2015-08-15 16:20:38\ntags: 兼容性\ncategories: 与脚本相关的兼容性问题\nkeywords: javascript兼容性, js兼容性, 浏览器兼容性\n---\n内容如题\n<!-- more -->\n---\n\n> - 1、IE Chrome Opera 中，cookie 中可以保存 Unicode 字符；Firefox 则会将中文字符内码将被转换为 Unicode 编码；Safari 会忽略包含中文字符的键值对。\n>> 解决办法：在设置和读取 cookie 时，始终为字符进行编解码操作，推荐使用 \"encodeURIComponent\" 和 \"decodeURIComponent\" 方法做相应编解码工作。\n\n> - 2、IE Firefox Opera 在自定义提交方式下不会提交普通按钮及提交按钮的键值对信息；而 Chrome Safari 会将这些信息也提交给服务器端。\n>> 解决办法：通常情况下，服务器端不需要按钮的 key/value 信息，建议删除按钮的 name 属性，不使其成为 successful control。\n\n> - 3、Content-Type 报头字符串代表着服务器端发送给客户端浏览器的具体数据类型，浏览器将根据这个信息决定如何处理得到的数据内容。比如：'Content-Type:text/html' 表示着这是个 HTML 文件，需要渲染引擎解释内容后输出；'Content-Type: application/octet-stream' 表示这是个二进制流，需要下载到本地后由用户端环境决定如何使用。\n每个浏览器内置支持的 Content-Type 类型表各不相同，这导致了某些类型字符串在某些浏览器下不被识别；另外，如果出现错误的 Content-Type 类型，各个浏览器又会以不同的方式处理。\n>> 解决办法：这个问题比较复杂，如需避免出现显示异常，建议不要使用非法的 Content-Type 头字符串；并且文件实际内容和数据格式应与 Content-Type 头字符串内类型声明一致。\n\n> - 4、在 IE6 IE7 IE8 中，若一个页面被打开时接收到的响应头的 content-type 为 text/plain，浏览器会尝试嗅探页面文件内实际内容来判断是否可能为一个 HTML 文档，若是则会以 text/html 的方式将页面作为 HTML 文档解释，而不是将其作为纯文本内容处理。\n>> 解决办法：这是由于 IE 浏览器的特有内容嗅探机制导致，故在不修改服务器端代码的情况下，无法通过常规办法解决此 IE 特性问题。更多关于此问题的资料参考官方信息：Internet Explorer 未按预期方式处理“Text/Plain”内容类型。\n合理、正确地设置文档的 content-type 是最佳的解决方案，同时应避免在非 HTML 文件中出现可被 IE6 IE7 IE8 嗅探机制捕获的 HTML、BODY、HEAD、TITLE 标记书写格式。\n\n> - 5、IE6 不支持 RSS，使用浏览器打开响应头为 application/rss+xml 的内容会当做二进制文件而提示下载；Chrome 会将 application/rss+xml 以纯文本处理而显示出源代码。\n>> 解决办法：各浏览器对于 RSS 的支持及渲染方式为浏览器各自实现导致，故无法通过常规办法使各浏览器达到一致的效果，对于暂不支持 RSS 的浏览器应给予提示。Chrome 可通过安装扩展插件实现此功能。\n\n\n> - 6、IE6 IE7 IE8 始终不在使用 META 元素控制跳转时附加 Referer 字段到请求头中。在普通页面中，当脚本调用 location 对象进行跳转时也不会附加 Referer 字段信息；\nFirefox 始终不在使用 META 元素控制跳转时附加 Referer 字段到请求头中。\n>> 解决办法：若服务端需要获得正确的 Referer 字段信息，则应采用各浏览器均可以附加 Referer 字段信息的方式进行跳转。如，普通超链接、表单提交、HTTP 302 跳转。\n\n> - 7、如果服务器端产生 HTTP 400 错误，并且在服务器端没有配置相应的显示页面，则会由本地客户端使用本地资源文件显示此错误信息。但是各浏览器的本地资源提示不同，更有些浏览器使用空白页代替本体错误提示页，造成用户识别混淆。\n>> 解决办法：HTTP 出错时返回错误代码，如果服务器端没有设置显示该问题的页面，则会由本地浏览器根据本地预置资源文件来显示，这些本地页面的显示风格由各浏览器决定，无法由用户控制。因此最好的解决方案还是在服务器端配置所有的错误代码对应的远程页面。","slug":"与服务端通信相关的兼容性问题","published":1,"updated":"2016-10-31T07:25:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciuyzlusp0002e6tb3cpuk7tt","content":"<p>内容如题</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><a id=\"more\"></a></h2><blockquote>\n<ul>\n<li><p>1、IE Chrome Opera 中，cookie 中可以保存 Unicode 字符；Firefox 则会将中文字符内码将被转换为 Unicode 编码；Safari 会忽略包含中文字符的键值对。</p>\n<blockquote>\n<p>解决办法：在设置和读取 cookie 时，始终为字符进行编解码操作，推荐使用 “encodeURIComponent” 和 “decodeURIComponent” 方法做相应编解码工作。</p>\n</blockquote>\n</li>\n<li><p>2、IE Firefox Opera 在自定义提交方式下不会提交普通按钮及提交按钮的键值对信息；而 Chrome Safari 会将这些信息也提交给服务器端。</p>\n<blockquote>\n<p>解决办法：通常情况下，服务器端不需要按钮的 key/value 信息，建议删除按钮的 name 属性，不使其成为 successful control。</p>\n</blockquote>\n</li>\n<li><p>3、Content-Type 报头字符串代表着服务器端发送给客户端浏览器的具体数据类型，浏览器将根据这个信息决定如何处理得到的数据内容。比如：’Content-Type:text/html’ 表示着这是个 HTML 文件，需要渲染引擎解释内容后输出；’Content-Type: application/octet-stream’ 表示这是个二进制流，需要下载到本地后由用户端环境决定如何使用。<br>每个浏览器内置支持的 Content-Type 类型表各不相同，这导致了某些类型字符串在某些浏览器下不被识别；另外，如果出现错误的 Content-Type 类型，各个浏览器又会以不同的方式处理。</p>\n<blockquote>\n<p>解决办法：这个问题比较复杂，如需避免出现显示异常，建议不要使用非法的 Content-Type 头字符串；并且文件实际内容和数据格式应与 Content-Type 头字符串内类型声明一致。</p>\n</blockquote>\n</li>\n<li><p>4、在 IE6 IE7 IE8 中，若一个页面被打开时接收到的响应头的 content-type 为 text/plain，浏览器会尝试嗅探页面文件内实际内容来判断是否可能为一个 HTML 文档，若是则会以 text/html 的方式将页面作为 HTML 文档解释，而不是将其作为纯文本内容处理。</p>\n<blockquote>\n<p>解决办法：这是由于 IE 浏览器的特有内容嗅探机制导致，故在不修改服务器端代码的情况下，无法通过常规办法解决此 IE 特性问题。更多关于此问题的资料参考官方信息：Internet Explorer 未按预期方式处理“Text/Plain”内容类型。<br>合理、正确地设置文档的 content-type 是最佳的解决方案，同时应避免在非 HTML 文件中出现可被 IE6 IE7 IE8 嗅探机制捕获的 HTML、BODY、HEAD、TITLE 标记书写格式。</p>\n</blockquote>\n</li>\n<li><p>5、IE6 不支持 RSS，使用浏览器打开响应头为 application/rss+xml 的内容会当做二进制文件而提示下载；Chrome 会将 application/rss+xml 以纯文本处理而显示出源代码。</p>\n<blockquote>\n<p>解决办法：各浏览器对于 RSS 的支持及渲染方式为浏览器各自实现导致，故无法通过常规办法使各浏览器达到一致的效果，对于暂不支持 RSS 的浏览器应给予提示。Chrome 可通过安装扩展插件实现此功能。</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>6、IE6 IE7 IE8 始终不在使用 META 元素控制跳转时附加 Referer 字段到请求头中。在普通页面中，当脚本调用 location 对象进行跳转时也不会附加 Referer 字段信息；<br>Firefox 始终不在使用 META 元素控制跳转时附加 Referer 字段到请求头中。</p>\n<blockquote>\n<p>解决办法：若服务端需要获得正确的 Referer 字段信息，则应采用各浏览器均可以附加 Referer 字段信息的方式进行跳转。如，普通超链接、表单提交、HTTP 302 跳转。</p>\n</blockquote>\n</li>\n<li><p>7、如果服务器端产生 HTTP 400 错误，并且在服务器端没有配置相应的显示页面，则会由本地客户端使用本地资源文件显示此错误信息。但是各浏览器的本地资源提示不同，更有些浏览器使用空白页代替本体错误提示页，造成用户识别混淆。</p>\n<blockquote>\n<p>解决办法：HTTP 出错时返回错误代码，如果服务器端没有设置显示该问题的页面，则会由本地浏览器根据本地预置资源文件来显示，这些本地页面的显示风格由各浏览器决定，无法由用户控制。因此最好的解决方案还是在服务器端配置所有的错误代码对应的远程页面。</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n","excerpt":"<p>内容如题</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a>","more":"</h2><blockquote>\n<ul>\n<li><p>1、IE Chrome Opera 中，cookie 中可以保存 Unicode 字符；Firefox 则会将中文字符内码将被转换为 Unicode 编码；Safari 会忽略包含中文字符的键值对。</p>\n<blockquote>\n<p>解决办法：在设置和读取 cookie 时，始终为字符进行编解码操作，推荐使用 “encodeURIComponent” 和 “decodeURIComponent” 方法做相应编解码工作。</p>\n</blockquote>\n</li>\n<li><p>2、IE Firefox Opera 在自定义提交方式下不会提交普通按钮及提交按钮的键值对信息；而 Chrome Safari 会将这些信息也提交给服务器端。</p>\n<blockquote>\n<p>解决办法：通常情况下，服务器端不需要按钮的 key/value 信息，建议删除按钮的 name 属性，不使其成为 successful control。</p>\n</blockquote>\n</li>\n<li><p>3、Content-Type 报头字符串代表着服务器端发送给客户端浏览器的具体数据类型，浏览器将根据这个信息决定如何处理得到的数据内容。比如：’Content-Type:text/html’ 表示着这是个 HTML 文件，需要渲染引擎解释内容后输出；’Content-Type: application/octet-stream’ 表示这是个二进制流，需要下载到本地后由用户端环境决定如何使用。<br>每个浏览器内置支持的 Content-Type 类型表各不相同，这导致了某些类型字符串在某些浏览器下不被识别；另外，如果出现错误的 Content-Type 类型，各个浏览器又会以不同的方式处理。</p>\n<blockquote>\n<p>解决办法：这个问题比较复杂，如需避免出现显示异常，建议不要使用非法的 Content-Type 头字符串；并且文件实际内容和数据格式应与 Content-Type 头字符串内类型声明一致。</p>\n</blockquote>\n</li>\n<li><p>4、在 IE6 IE7 IE8 中，若一个页面被打开时接收到的响应头的 content-type 为 text/plain，浏览器会尝试嗅探页面文件内实际内容来判断是否可能为一个 HTML 文档，若是则会以 text/html 的方式将页面作为 HTML 文档解释，而不是将其作为纯文本内容处理。</p>\n<blockquote>\n<p>解决办法：这是由于 IE 浏览器的特有内容嗅探机制导致，故在不修改服务器端代码的情况下，无法通过常规办法解决此 IE 特性问题。更多关于此问题的资料参考官方信息：Internet Explorer 未按预期方式处理“Text/Plain”内容类型。<br>合理、正确地设置文档的 content-type 是最佳的解决方案，同时应避免在非 HTML 文件中出现可被 IE6 IE7 IE8 嗅探机制捕获的 HTML、BODY、HEAD、TITLE 标记书写格式。</p>\n</blockquote>\n</li>\n<li><p>5、IE6 不支持 RSS，使用浏览器打开响应头为 application/rss+xml 的内容会当做二进制文件而提示下载；Chrome 会将 application/rss+xml 以纯文本处理而显示出源代码。</p>\n<blockquote>\n<p>解决办法：各浏览器对于 RSS 的支持及渲染方式为浏览器各自实现导致，故无法通过常规办法使各浏览器达到一致的效果，对于暂不支持 RSS 的浏览器应给予提示。Chrome 可通过安装扩展插件实现此功能。</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>6、IE6 IE7 IE8 始终不在使用 META 元素控制跳转时附加 Referer 字段到请求头中。在普通页面中，当脚本调用 location 对象进行跳转时也不会附加 Referer 字段信息；<br>Firefox 始终不在使用 META 元素控制跳转时附加 Referer 字段到请求头中。</p>\n<blockquote>\n<p>解决办法：若服务端需要获得正确的 Referer 字段信息，则应采用各浏览器均可以附加 Referer 字段信息的方式进行跳转。如，普通超链接、表单提交、HTTP 302 跳转。</p>\n</blockquote>\n</li>\n<li><p>7、如果服务器端产生 HTTP 400 错误，并且在服务器端没有配置相应的显示页面，则会由本地客户端使用本地资源文件显示此错误信息。但是各浏览器的本地资源提示不同，更有些浏览器使用空白页代替本体错误提示页，造成用户识别混淆。</p>\n<blockquote>\n<p>解决办法：HTTP 出错时返回错误代码，如果服务器端没有设置显示该问题的页面，则会由本地浏览器根据本地预置资源文件来显示，这些本地页面的显示风格由各浏览器决定，无法由用户控制。因此最好的解决方案还是在服务器端配置所有的错误代码对应的远程页面。</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>"},{"title":"与渲染混合类型相关的兼容性问题","date":"2015-08-14T04:22:31.000Z","keywords":"css兼容性, 渲染兼容性, 浏览器兼容性","_content":"内容如题\n<!-- more -->\n\n> - 1、在 IE5.0 IE5.5 IE6 中，当为一个块级元素同时设置了向左浮动（float:left）及左边距或右边距（'margin-left' | 'margin-right'）后，则该元素的左边距或右边距在某些情况下会是设定值的两倍。同样地，向右浮动（float:right）及右边距（'margin-right'）也存在此现象。这个是 IE 著名的 \"双边距Bug\"（IE Double Margin Bug）。\n>> 解决办法：\n>> - 尽量避免同时使用 'margin-left' 与 float:left，及 'margin-right' 与 float:right；\n>> - 由于这个 Bug 对于 'display' 特性为 'inline' 的元素不会触发，所以可以通过设置 display:inline 消除此 Bug，由于此 Bug 仅在元素浮动时发生，而浮动将使该元素 'display' 特性计算为 'block' 或者 'table'（见 CSS2.1 规范第 9.7 Relationships between 'display', 'position', and 'float' 节），因此可以通过设置 display:inline 消除双边距 Bug。\n\n> - 2、对于溢出单元格的内容，IE6 IE7 IE8 混杂模式始终会对溢出部分进行隐藏，而不考虑单元格的 'overflow' 特性，就好像单元格始终设置了 \"overflow:hidden\" 一样。\n>> 解决办法：遵照 W3C 规范所描述的，为单元格元素设置 \"overflow:hidden\" ，在所有浏览器中均会裁切溢出单元格的内容。\n\n> - 3、在 IE6 IE7 IE8(Q)中，若 TD 元素没有明确设定 'white-space' 特性，其值为继承自其父元素的值，则其内的子元素不再能够自动继承 TD 的 'white-space' 特性。并且若 TD 元素明确设定了 'width' 特性，则 TD 元素本身的 'white-space' 特性自动变为了初始值 'normal'。\n>> 解决办法：明确地为 TD 的子元素设置 'white-space' 特性，避免使 TD 元素自动继承父元素的 'white-space' 特性。或者避免同时为 TD 元素设置宽度及 white-space:nowrap（或是 nowrap 属性）。\n\n> - 4、明确地为 TD 的子元素设置 'white-space' 特性，避免使 TD 元素自动继承父元素的 'white-space' 特性。或者避免同时为 TD 元素设置宽度及 white-space:nowrap（或是 nowrap 属性）。\n>> 解决办法：由于 TABLE 元素的 align 属性已经被 W3C 废弃，所以在考虑 TABLE 元素对齐问题上应避免使用 align 属性，而改用 CSS。\n>> - 使用CSS的 float:left 代替 align=\"left\"；\n>> - 使用CSS的 float:right 代替 align=\"right\"；\n>> - 使用CSS的 margin-left:auto 及 margin-right:auto 代替 align=\"center\"。\n\n> - 5、A 元素缺少 href 属性时，在 IE6 IE7 IE8(Q) Chrome(Q) Safari(Q) 中 ':hover' 和 ':active' 伪类会失效。\n>> 解决办法：如果需要一个 A 元素能根据用户的行为改变样式，请添加 A 元素的 'href' 属性使伪类生效。\n\n> - 6、当为 BR 元素设置 'line-height' 特性时，在 IE8(S) Firefox(S) Chrome Safari 中 BR 元素的 'line-height' 特性的计算值不会小于其继承值。在 IE6 IE7 IE8(Q) Firefox(Q) Opera 中计算后则可能会小于其继承来的 'line-height' 特性的计算值。\n>> 解决办法：尽可能不为 BR 元素设定一个可能小于其继承值的值。\n\n> - 7、IE6 IE7 IE8(Q) 中，对于 U-A 及 A-U 元素嵌套结构，只要最内层元素的 'text-decoration' 为 'none' ，则其内容文本就不会出现下划线。\nIE6 IE7 IE8(Q) 中，对于 A 元素包含 S 元素，A 元素设置了 text-decoration:line-through ，S 元素设置了 text-decoration:none，而此时对于 S 元素，浏览器不再为其渲染删除线。\n>> 解决办法：U、S 元素本身是废弃元素，应避免使用，而用 CSS 相关特性来替代这些元素产生的效果。\n\n> - 8、IE6 IE7 IE8(Q) 中 cellspacing 属性在重合的边框模型的表格中仍然有效。\n>> 解决办法：在使用 border-collapse:collapse 时应保证 TABLE 元素的 cellspacing 属性值为 0。\n\n> - 9、在 IE Chrome Safari 中，IFRAME 元素引入的子页面 HTML 元素的 \"overflow:hidden\" 会使 IFRAME 元素的 scrolling 属性失效，IFRAME 元素不会出现滚动条。\n在 Chrome Safari 中，虽然 IFRAME 元素的 scrolling 属性为 \"no\"，但若其子页面的 HTML 或 BODY 元素的 'overflow' 特性为 'scroll'，则 IFRAME 仍会被渲染上滚动条。\n>> 解决办法：W3C 规范并没有说明 scrolling 属性应该控制子页面哪个元素的滚动条的生成或者 'overflow' 特性，为防止在某些情况下 Chrome Safari 的 IFRAME 子页面中出现多余滚动条，应避免为 HTML 或者 BODY 元素设置 overflow:scroll。\n\n> - 10、IE 混杂模式(Q) 中给 IMG 元素设置 'padding' 特性无效。\n>> 解决办法：使用标准模式。\n在 IE6(Q) IE7(Q) IE8(Q) 中如需为 IMG 元素设置 'padding' 特性，需要在 IMG 元素外加一层容器标签，为该标签设置 'padding'。\n\n> - 11、在 IE6 IE7 IE8(Q) Firefox(Q) Opera(Q) 中，FONT 元素的 color 属性指定的颜色可以覆盖由其祖先元素生成的 'text-decoration' 修饰效果的颜色。\n在 Chrome(Q) Safari(Q) 中，FONT 元素的 CSS 'color' 特性指定的颜色可以将由其祖先元素生成的 'text-decoration' 修饰效果的颜色覆盖。\n>> 解决办法：FONT 元素本身是废弃元素，并且其所有属性均已不推荐使用，应避免使用 FONT 元素。\nFONT 元素的 size、color、face 属性可以分别使用 SPAN 元素搭配 'font-size'、'color'、'font-family' 这几个 CSS 特性实现相同的效果。\n\n> - 12、不同浏览器中 Flash 与其他元素发生覆盖时， Flash 与其他元素的层叠顺序有差异。\n>> 解决办法：若有页面需求是要求其他元素遮挡 Flash\n>> - 使用 EMBED 引入Flash 。\n>> - wmode的值使用 'transparent' 或 'opaque' 。\n>> - 使用的 iframe 需要设置背景色(设置为白色)。\n\n> - 13、在 Chrome Safari 中，若表格设定了 cellspacing 属性或者 'border-spacing' 特性，则由于设定的单元格上下间隙会作用在 THEAD、TBODY、TFOOT 元素内部，会导致这些元素之间会出现双倍的间隙。\n>> 解决办法：CSS 规范并没有明确说明单元格间隙的作用位置以及行组元素对其的影响，所以为了避免差异应避免在包含 THEAD、TBODY、TFOOT 这类行组元素的表格内设定非 0 的单元格间隙 (cellsping 属性或 'border-spacing' 特性)。\n\n> - 14、在 IE6 IE7 IE8(Q) 中，无论容器的宽度为多大，其内所有 align 属性设置为 'left' 或 'right' 的 IMG、OBJECT、TABLE、IFRAME 等元素将始终显示在一行中。并不会随着其包含块宽度的缩小而发生折行现象。\n>> 解决办法：align 属性已被废弃，应避免使用这类 HTML 属性。为 IMG、OBJECT、IFRAME、TABLE、APPLET、EMBED 元素使用 CSS 的 'float' 特性以达到相同的效果。\n\n> - 15、IE Opera 中会将 image 选择器解释为 IMG 选择器，其他浏览器不存在此问题。\n>> 解决办法：严格按照 CSS2.1 及 DOM 规范的规定书写代码，避免作为 CSS 选择子以及在脚本中需要传入 HTML 标签名的方法中使用 IMAGE 关键字。\n\n> - 16、CSS2.1 规范中并没有明确说明对于应用 \"shrink-to-fit\" 算法计算宽度的元素内包含 'width' 特性单位为 \"百分比\" 的元素时究竟应该如何计算父子元素的宽度。但 IE 在此类情况下，对于宽度的计算与规范中明确说明的规定有明显出入，导致计算的宽度与其他浏览器有很大的差异。且与文档模式有关。\n>> 解决办法：\n>> - 明确为浮动元素设置一个宽度值，避免其在进行 \"shrink-to-fit\" 计算时在不同浏览器之间出现的宽度计算差异。\n>> - 若浮动元素出于某些情况必须使用 \"shrink-to-fit\" 宽度时，则应尽量保证其内子元素的宽度不依赖其自身宽度，如使用 px 为单位的宽度值。\n\n> - 17、当某块级元素设置了 margin-top ，并且之前存在着可被渲染的绝对定位元素时，其 margin-top 在 IE6 IE7 IE8(Q) 会失效。\n>> 解决办法：针对这类低版本 IE 浏览器的 bug，请尽量避免满足其所有触发条件。如本例中所需间隙可以采用其它设置元素的 margin-bottom或问题元素的 padding-top 等方式来弥补。\n","source":"_posts/与渲染混合类型相关的兼容性问题.md","raw":"title: 与渲染混合类型相关的兼容性问题\ndate: 2015-08-14 12:22:31\ntags: 兼容性\ncategories: 与渲染混合类型相关的兼容性问题\nkeywords: css兼容性, 渲染兼容性, 浏览器兼容性\n---\n内容如题\n<!-- more -->\n\n> - 1、在 IE5.0 IE5.5 IE6 中，当为一个块级元素同时设置了向左浮动（float:left）及左边距或右边距（'margin-left' | 'margin-right'）后，则该元素的左边距或右边距在某些情况下会是设定值的两倍。同样地，向右浮动（float:right）及右边距（'margin-right'）也存在此现象。这个是 IE 著名的 \"双边距Bug\"（IE Double Margin Bug）。\n>> 解决办法：\n>> - 尽量避免同时使用 'margin-left' 与 float:left，及 'margin-right' 与 float:right；\n>> - 由于这个 Bug 对于 'display' 特性为 'inline' 的元素不会触发，所以可以通过设置 display:inline 消除此 Bug，由于此 Bug 仅在元素浮动时发生，而浮动将使该元素 'display' 特性计算为 'block' 或者 'table'（见 CSS2.1 规范第 9.7 Relationships between 'display', 'position', and 'float' 节），因此可以通过设置 display:inline 消除双边距 Bug。\n\n> - 2、对于溢出单元格的内容，IE6 IE7 IE8 混杂模式始终会对溢出部分进行隐藏，而不考虑单元格的 'overflow' 特性，就好像单元格始终设置了 \"overflow:hidden\" 一样。\n>> 解决办法：遵照 W3C 规范所描述的，为单元格元素设置 \"overflow:hidden\" ，在所有浏览器中均会裁切溢出单元格的内容。\n\n> - 3、在 IE6 IE7 IE8(Q)中，若 TD 元素没有明确设定 'white-space' 特性，其值为继承自其父元素的值，则其内的子元素不再能够自动继承 TD 的 'white-space' 特性。并且若 TD 元素明确设定了 'width' 特性，则 TD 元素本身的 'white-space' 特性自动变为了初始值 'normal'。\n>> 解决办法：明确地为 TD 的子元素设置 'white-space' 特性，避免使 TD 元素自动继承父元素的 'white-space' 特性。或者避免同时为 TD 元素设置宽度及 white-space:nowrap（或是 nowrap 属性）。\n\n> - 4、明确地为 TD 的子元素设置 'white-space' 特性，避免使 TD 元素自动继承父元素的 'white-space' 特性。或者避免同时为 TD 元素设置宽度及 white-space:nowrap（或是 nowrap 属性）。\n>> 解决办法：由于 TABLE 元素的 align 属性已经被 W3C 废弃，所以在考虑 TABLE 元素对齐问题上应避免使用 align 属性，而改用 CSS。\n>> - 使用CSS的 float:left 代替 align=\"left\"；\n>> - 使用CSS的 float:right 代替 align=\"right\"；\n>> - 使用CSS的 margin-left:auto 及 margin-right:auto 代替 align=\"center\"。\n\n> - 5、A 元素缺少 href 属性时，在 IE6 IE7 IE8(Q) Chrome(Q) Safari(Q) 中 ':hover' 和 ':active' 伪类会失效。\n>> 解决办法：如果需要一个 A 元素能根据用户的行为改变样式，请添加 A 元素的 'href' 属性使伪类生效。\n\n> - 6、当为 BR 元素设置 'line-height' 特性时，在 IE8(S) Firefox(S) Chrome Safari 中 BR 元素的 'line-height' 特性的计算值不会小于其继承值。在 IE6 IE7 IE8(Q) Firefox(Q) Opera 中计算后则可能会小于其继承来的 'line-height' 特性的计算值。\n>> 解决办法：尽可能不为 BR 元素设定一个可能小于其继承值的值。\n\n> - 7、IE6 IE7 IE8(Q) 中，对于 U-A 及 A-U 元素嵌套结构，只要最内层元素的 'text-decoration' 为 'none' ，则其内容文本就不会出现下划线。\nIE6 IE7 IE8(Q) 中，对于 A 元素包含 S 元素，A 元素设置了 text-decoration:line-through ，S 元素设置了 text-decoration:none，而此时对于 S 元素，浏览器不再为其渲染删除线。\n>> 解决办法：U、S 元素本身是废弃元素，应避免使用，而用 CSS 相关特性来替代这些元素产生的效果。\n\n> - 8、IE6 IE7 IE8(Q) 中 cellspacing 属性在重合的边框模型的表格中仍然有效。\n>> 解决办法：在使用 border-collapse:collapse 时应保证 TABLE 元素的 cellspacing 属性值为 0。\n\n> - 9、在 IE Chrome Safari 中，IFRAME 元素引入的子页面 HTML 元素的 \"overflow:hidden\" 会使 IFRAME 元素的 scrolling 属性失效，IFRAME 元素不会出现滚动条。\n在 Chrome Safari 中，虽然 IFRAME 元素的 scrolling 属性为 \"no\"，但若其子页面的 HTML 或 BODY 元素的 'overflow' 特性为 'scroll'，则 IFRAME 仍会被渲染上滚动条。\n>> 解决办法：W3C 规范并没有说明 scrolling 属性应该控制子页面哪个元素的滚动条的生成或者 'overflow' 特性，为防止在某些情况下 Chrome Safari 的 IFRAME 子页面中出现多余滚动条，应避免为 HTML 或者 BODY 元素设置 overflow:scroll。\n\n> - 10、IE 混杂模式(Q) 中给 IMG 元素设置 'padding' 特性无效。\n>> 解决办法：使用标准模式。\n在 IE6(Q) IE7(Q) IE8(Q) 中如需为 IMG 元素设置 'padding' 特性，需要在 IMG 元素外加一层容器标签，为该标签设置 'padding'。\n\n> - 11、在 IE6 IE7 IE8(Q) Firefox(Q) Opera(Q) 中，FONT 元素的 color 属性指定的颜色可以覆盖由其祖先元素生成的 'text-decoration' 修饰效果的颜色。\n在 Chrome(Q) Safari(Q) 中，FONT 元素的 CSS 'color' 特性指定的颜色可以将由其祖先元素生成的 'text-decoration' 修饰效果的颜色覆盖。\n>> 解决办法：FONT 元素本身是废弃元素，并且其所有属性均已不推荐使用，应避免使用 FONT 元素。\nFONT 元素的 size、color、face 属性可以分别使用 SPAN 元素搭配 'font-size'、'color'、'font-family' 这几个 CSS 特性实现相同的效果。\n\n> - 12、不同浏览器中 Flash 与其他元素发生覆盖时， Flash 与其他元素的层叠顺序有差异。\n>> 解决办法：若有页面需求是要求其他元素遮挡 Flash\n>> - 使用 EMBED 引入Flash 。\n>> - wmode的值使用 'transparent' 或 'opaque' 。\n>> - 使用的 iframe 需要设置背景色(设置为白色)。\n\n> - 13、在 Chrome Safari 中，若表格设定了 cellspacing 属性或者 'border-spacing' 特性，则由于设定的单元格上下间隙会作用在 THEAD、TBODY、TFOOT 元素内部，会导致这些元素之间会出现双倍的间隙。\n>> 解决办法：CSS 规范并没有明确说明单元格间隙的作用位置以及行组元素对其的影响，所以为了避免差异应避免在包含 THEAD、TBODY、TFOOT 这类行组元素的表格内设定非 0 的单元格间隙 (cellsping 属性或 'border-spacing' 特性)。\n\n> - 14、在 IE6 IE7 IE8(Q) 中，无论容器的宽度为多大，其内所有 align 属性设置为 'left' 或 'right' 的 IMG、OBJECT、TABLE、IFRAME 等元素将始终显示在一行中。并不会随着其包含块宽度的缩小而发生折行现象。\n>> 解决办法：align 属性已被废弃，应避免使用这类 HTML 属性。为 IMG、OBJECT、IFRAME、TABLE、APPLET、EMBED 元素使用 CSS 的 'float' 特性以达到相同的效果。\n\n> - 15、IE Opera 中会将 image 选择器解释为 IMG 选择器，其他浏览器不存在此问题。\n>> 解决办法：严格按照 CSS2.1 及 DOM 规范的规定书写代码，避免作为 CSS 选择子以及在脚本中需要传入 HTML 标签名的方法中使用 IMAGE 关键字。\n\n> - 16、CSS2.1 规范中并没有明确说明对于应用 \"shrink-to-fit\" 算法计算宽度的元素内包含 'width' 特性单位为 \"百分比\" 的元素时究竟应该如何计算父子元素的宽度。但 IE 在此类情况下，对于宽度的计算与规范中明确说明的规定有明显出入，导致计算的宽度与其他浏览器有很大的差异。且与文档模式有关。\n>> 解决办法：\n>> - 明确为浮动元素设置一个宽度值，避免其在进行 \"shrink-to-fit\" 计算时在不同浏览器之间出现的宽度计算差异。\n>> - 若浮动元素出于某些情况必须使用 \"shrink-to-fit\" 宽度时，则应尽量保证其内子元素的宽度不依赖其自身宽度，如使用 px 为单位的宽度值。\n\n> - 17、当某块级元素设置了 margin-top ，并且之前存在着可被渲染的绝对定位元素时，其 margin-top 在 IE6 IE7 IE8(Q) 会失效。\n>> 解决办法：针对这类低版本 IE 浏览器的 bug，请尽量避免满足其所有触发条件。如本例中所需间隙可以采用其它设置元素的 margin-bottom或问题元素的 padding-top 等方式来弥补。\n","slug":"与渲染混合类型相关的兼容性问题","published":1,"updated":"2016-10-31T07:25:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciuyzlut00005e6tb1i3zhwhb","content":"<p>内容如题<br><a id=\"more\"></a></p>\n<blockquote>\n<ul>\n<li><p>1、在 IE5.0 IE5.5 IE6 中，当为一个块级元素同时设置了向左浮动（float:left）及左边距或右边距（’margin-left’ | ‘margin-right’）后，则该元素的左边距或右边距在某些情况下会是设定值的两倍。同样地，向右浮动（float:right）及右边距（’margin-right’）也存在此现象。这个是 IE 著名的 “双边距Bug”（IE Double Margin Bug）。</p>\n<blockquote>\n<p>解决办法：</p>\n<ul>\n<li>尽量避免同时使用 ‘margin-left’ 与 float:left，及 ‘margin-right’ 与 float:right；</li>\n<li>由于这个 Bug 对于 ‘display’ 特性为 ‘inline’ 的元素不会触发，所以可以通过设置 display:inline 消除此 Bug，由于此 Bug 仅在元素浮动时发生，而浮动将使该元素 ‘display’ 特性计算为 ‘block’ 或者 ‘table’（见 CSS2.1 规范第 9.7 Relationships between ‘display’, ‘position’, and ‘float’ 节），因此可以通过设置 display:inline 消除双边距 Bug。</li>\n</ul>\n</blockquote>\n</li>\n<li><p>2、对于溢出单元格的内容，IE6 IE7 IE8 混杂模式始终会对溢出部分进行隐藏，而不考虑单元格的 ‘overflow’ 特性，就好像单元格始终设置了 “overflow:hidden” 一样。</p>\n<blockquote>\n<p>解决办法：遵照 W3C 规范所描述的，为单元格元素设置 “overflow:hidden” ，在所有浏览器中均会裁切溢出单元格的内容。</p>\n</blockquote>\n</li>\n<li><p>3、在 IE6 IE7 IE8(Q)中，若 TD 元素没有明确设定 ‘white-space’ 特性，其值为继承自其父元素的值，则其内的子元素不再能够自动继承 TD 的 ‘white-space’ 特性。并且若 TD 元素明确设定了 ‘width’ 特性，则 TD 元素本身的 ‘white-space’ 特性自动变为了初始值 ‘normal’。</p>\n<blockquote>\n<p>解决办法：明确地为 TD 的子元素设置 ‘white-space’ 特性，避免使 TD 元素自动继承父元素的 ‘white-space’ 特性。或者避免同时为 TD 元素设置宽度及 white-space:nowrap（或是 nowrap 属性）。</p>\n</blockquote>\n</li>\n<li><p>4、明确地为 TD 的子元素设置 ‘white-space’ 特性，避免使 TD 元素自动继承父元素的 ‘white-space’ 特性。或者避免同时为 TD 元素设置宽度及 white-space:nowrap（或是 nowrap 属性）。</p>\n<blockquote>\n<p>解决办法：由于 TABLE 元素的 align 属性已经被 W3C 废弃，所以在考虑 TABLE 元素对齐问题上应避免使用 align 属性，而改用 CSS。</p>\n<ul>\n<li>使用CSS的 float:left 代替 align=”left”；</li>\n<li>使用CSS的 float:right 代替 align=”right”；</li>\n<li>使用CSS的 margin-left:auto 及 margin-right:auto 代替 align=”center”。</li>\n</ul>\n</blockquote>\n</li>\n<li><p>5、A 元素缺少 href 属性时，在 IE6 IE7 IE8(Q) Chrome(Q) Safari(Q) 中 ‘:hover’ 和 ‘:active’ 伪类会失效。</p>\n<blockquote>\n<p>解决办法：如果需要一个 A 元素能根据用户的行为改变样式，请添加 A 元素的 ‘href’ 属性使伪类生效。</p>\n</blockquote>\n</li>\n<li><p>6、当为 BR 元素设置 ‘line-height’ 特性时，在 IE8(S) Firefox(S) Chrome Safari 中 BR 元素的 ‘line-height’ 特性的计算值不会小于其继承值。在 IE6 IE7 IE8(Q) Firefox(Q) Opera 中计算后则可能会小于其继承来的 ‘line-height’ 特性的计算值。</p>\n<blockquote>\n<p>解决办法：尽可能不为 BR 元素设定一个可能小于其继承值的值。</p>\n</blockquote>\n</li>\n<li><p>7、IE6 IE7 IE8(Q) 中，对于 U-A 及 A-U 元素嵌套结构，只要最内层元素的 ‘text-decoration’ 为 ‘none’ ，则其内容文本就不会出现下划线。<br>IE6 IE7 IE8(Q) 中，对于 A 元素包含 S 元素，A 元素设置了 text-decoration:line-through ，S 元素设置了 text-decoration:none，而此时对于 S 元素，浏览器不再为其渲染删除线。</p>\n<blockquote>\n<p>解决办法：U、S 元素本身是废弃元素，应避免使用，而用 CSS 相关特性来替代这些元素产生的效果。</p>\n</blockquote>\n</li>\n<li><p>8、IE6 IE7 IE8(Q) 中 cellspacing 属性在重合的边框模型的表格中仍然有效。</p>\n<blockquote>\n<p>解决办法：在使用 border-collapse:collapse 时应保证 TABLE 元素的 cellspacing 属性值为 0。</p>\n</blockquote>\n</li>\n<li><p>9、在 IE Chrome Safari 中，IFRAME 元素引入的子页面 HTML 元素的 “overflow:hidden” 会使 IFRAME 元素的 scrolling 属性失效，IFRAME 元素不会出现滚动条。<br>在 Chrome Safari 中，虽然 IFRAME 元素的 scrolling 属性为 “no”，但若其子页面的 HTML 或 BODY 元素的 ‘overflow’ 特性为 ‘scroll’，则 IFRAME 仍会被渲染上滚动条。</p>\n<blockquote>\n<p>解决办法：W3C 规范并没有说明 scrolling 属性应该控制子页面哪个元素的滚动条的生成或者 ‘overflow’ 特性，为防止在某些情况下 Chrome Safari 的 IFRAME 子页面中出现多余滚动条，应避免为 HTML 或者 BODY 元素设置 overflow:scroll。</p>\n</blockquote>\n</li>\n<li><p>10、IE 混杂模式(Q) 中给 IMG 元素设置 ‘padding’ 特性无效。</p>\n<blockquote>\n<p>解决办法：使用标准模式。<br>在 IE6(Q) IE7(Q) IE8(Q) 中如需为 IMG 元素设置 ‘padding’ 特性，需要在 IMG 元素外加一层容器标签，为该标签设置 ‘padding’。</p>\n</blockquote>\n</li>\n<li><p>11、在 IE6 IE7 IE8(Q) Firefox(Q) Opera(Q) 中，FONT 元素的 color 属性指定的颜色可以覆盖由其祖先元素生成的 ‘text-decoration’ 修饰效果的颜色。<br>在 Chrome(Q) Safari(Q) 中，FONT 元素的 CSS ‘color’ 特性指定的颜色可以将由其祖先元素生成的 ‘text-decoration’ 修饰效果的颜色覆盖。</p>\n<blockquote>\n<p>解决办法：FONT 元素本身是废弃元素，并且其所有属性均已不推荐使用，应避免使用 FONT 元素。<br>FONT 元素的 size、color、face 属性可以分别使用 SPAN 元素搭配 ‘font-size’、’color’、’font-family’ 这几个 CSS 特性实现相同的效果。</p>\n</blockquote>\n</li>\n<li><p>12、不同浏览器中 Flash 与其他元素发生覆盖时， Flash 与其他元素的层叠顺序有差异。</p>\n<blockquote>\n<p>解决办法：若有页面需求是要求其他元素遮挡 Flash</p>\n<ul>\n<li>使用 EMBED 引入Flash 。</li>\n<li>wmode的值使用 ‘transparent’ 或 ‘opaque’ 。</li>\n<li>使用的 iframe 需要设置背景色(设置为白色)。</li>\n</ul>\n</blockquote>\n</li>\n<li><p>13、在 Chrome Safari 中，若表格设定了 cellspacing 属性或者 ‘border-spacing’ 特性，则由于设定的单元格上下间隙会作用在 THEAD、TBODY、TFOOT 元素内部，会导致这些元素之间会出现双倍的间隙。</p>\n<blockquote>\n<p>解决办法：CSS 规范并没有明确说明单元格间隙的作用位置以及行组元素对其的影响，所以为了避免差异应避免在包含 THEAD、TBODY、TFOOT 这类行组元素的表格内设定非 0 的单元格间隙 (cellsping 属性或 ‘border-spacing’ 特性)。</p>\n</blockquote>\n</li>\n<li><p>14、在 IE6 IE7 IE8(Q) 中，无论容器的宽度为多大，其内所有 align 属性设置为 ‘left’ 或 ‘right’ 的 IMG、OBJECT、TABLE、IFRAME 等元素将始终显示在一行中。并不会随着其包含块宽度的缩小而发生折行现象。</p>\n<blockquote>\n<p>解决办法：align 属性已被废弃，应避免使用这类 HTML 属性。为 IMG、OBJECT、IFRAME、TABLE、APPLET、EMBED 元素使用 CSS 的 ‘float’ 特性以达到相同的效果。</p>\n</blockquote>\n</li>\n<li><p>15、IE Opera 中会将 image 选择器解释为 IMG 选择器，其他浏览器不存在此问题。</p>\n<blockquote>\n<p>解决办法：严格按照 CSS2.1 及 DOM 规范的规定书写代码，避免作为 CSS 选择子以及在脚本中需要传入 HTML 标签名的方法中使用 IMAGE 关键字。</p>\n</blockquote>\n</li>\n<li><p>16、CSS2.1 规范中并没有明确说明对于应用 “shrink-to-fit” 算法计算宽度的元素内包含 ‘width’ 特性单位为 “百分比” 的元素时究竟应该如何计算父子元素的宽度。但 IE 在此类情况下，对于宽度的计算与规范中明确说明的规定有明显出入，导致计算的宽度与其他浏览器有很大的差异。且与文档模式有关。</p>\n<blockquote>\n<p>解决办法：</p>\n<ul>\n<li>明确为浮动元素设置一个宽度值，避免其在进行 “shrink-to-fit” 计算时在不同浏览器之间出现的宽度计算差异。</li>\n<li>若浮动元素出于某些情况必须使用 “shrink-to-fit” 宽度时，则应尽量保证其内子元素的宽度不依赖其自身宽度，如使用 px 为单位的宽度值。</li>\n</ul>\n</blockquote>\n</li>\n<li><p>17、当某块级元素设置了 margin-top ，并且之前存在着可被渲染的绝对定位元素时，其 margin-top 在 IE6 IE7 IE8(Q) 会失效。</p>\n<blockquote>\n<p>解决办法：针对这类低版本 IE 浏览器的 bug，请尽量避免满足其所有触发条件。如本例中所需间隙可以采用其它设置元素的 margin-bottom或问题元素的 padding-top 等方式来弥补。</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n","excerpt":"<p>内容如题<br>","more":"</p>\n<blockquote>\n<ul>\n<li><p>1、在 IE5.0 IE5.5 IE6 中，当为一个块级元素同时设置了向左浮动（float:left）及左边距或右边距（’margin-left’ | ‘margin-right’）后，则该元素的左边距或右边距在某些情况下会是设定值的两倍。同样地，向右浮动（float:right）及右边距（’margin-right’）也存在此现象。这个是 IE 著名的 “双边距Bug”（IE Double Margin Bug）。</p>\n<blockquote>\n<p>解决办法：</p>\n<ul>\n<li>尽量避免同时使用 ‘margin-left’ 与 float:left，及 ‘margin-right’ 与 float:right；</li>\n<li>由于这个 Bug 对于 ‘display’ 特性为 ‘inline’ 的元素不会触发，所以可以通过设置 display:inline 消除此 Bug，由于此 Bug 仅在元素浮动时发生，而浮动将使该元素 ‘display’ 特性计算为 ‘block’ 或者 ‘table’（见 CSS2.1 规范第 9.7 Relationships between ‘display’, ‘position’, and ‘float’ 节），因此可以通过设置 display:inline 消除双边距 Bug。</li>\n</ul>\n</blockquote>\n</li>\n<li><p>2、对于溢出单元格的内容，IE6 IE7 IE8 混杂模式始终会对溢出部分进行隐藏，而不考虑单元格的 ‘overflow’ 特性，就好像单元格始终设置了 “overflow:hidden” 一样。</p>\n<blockquote>\n<p>解决办法：遵照 W3C 规范所描述的，为单元格元素设置 “overflow:hidden” ，在所有浏览器中均会裁切溢出单元格的内容。</p>\n</blockquote>\n</li>\n<li><p>3、在 IE6 IE7 IE8(Q)中，若 TD 元素没有明确设定 ‘white-space’ 特性，其值为继承自其父元素的值，则其内的子元素不再能够自动继承 TD 的 ‘white-space’ 特性。并且若 TD 元素明确设定了 ‘width’ 特性，则 TD 元素本身的 ‘white-space’ 特性自动变为了初始值 ‘normal’。</p>\n<blockquote>\n<p>解决办法：明确地为 TD 的子元素设置 ‘white-space’ 特性，避免使 TD 元素自动继承父元素的 ‘white-space’ 特性。或者避免同时为 TD 元素设置宽度及 white-space:nowrap（或是 nowrap 属性）。</p>\n</blockquote>\n</li>\n<li><p>4、明确地为 TD 的子元素设置 ‘white-space’ 特性，避免使 TD 元素自动继承父元素的 ‘white-space’ 特性。或者避免同时为 TD 元素设置宽度及 white-space:nowrap（或是 nowrap 属性）。</p>\n<blockquote>\n<p>解决办法：由于 TABLE 元素的 align 属性已经被 W3C 废弃，所以在考虑 TABLE 元素对齐问题上应避免使用 align 属性，而改用 CSS。</p>\n<ul>\n<li>使用CSS的 float:left 代替 align=”left”；</li>\n<li>使用CSS的 float:right 代替 align=”right”；</li>\n<li>使用CSS的 margin-left:auto 及 margin-right:auto 代替 align=”center”。</li>\n</ul>\n</blockquote>\n</li>\n<li><p>5、A 元素缺少 href 属性时，在 IE6 IE7 IE8(Q) Chrome(Q) Safari(Q) 中 ‘:hover’ 和 ‘:active’ 伪类会失效。</p>\n<blockquote>\n<p>解决办法：如果需要一个 A 元素能根据用户的行为改变样式，请添加 A 元素的 ‘href’ 属性使伪类生效。</p>\n</blockquote>\n</li>\n<li><p>6、当为 BR 元素设置 ‘line-height’ 特性时，在 IE8(S) Firefox(S) Chrome Safari 中 BR 元素的 ‘line-height’ 特性的计算值不会小于其继承值。在 IE6 IE7 IE8(Q) Firefox(Q) Opera 中计算后则可能会小于其继承来的 ‘line-height’ 特性的计算值。</p>\n<blockquote>\n<p>解决办法：尽可能不为 BR 元素设定一个可能小于其继承值的值。</p>\n</blockquote>\n</li>\n<li><p>7、IE6 IE7 IE8(Q) 中，对于 U-A 及 A-U 元素嵌套结构，只要最内层元素的 ‘text-decoration’ 为 ‘none’ ，则其内容文本就不会出现下划线。<br>IE6 IE7 IE8(Q) 中，对于 A 元素包含 S 元素，A 元素设置了 text-decoration:line-through ，S 元素设置了 text-decoration:none，而此时对于 S 元素，浏览器不再为其渲染删除线。</p>\n<blockquote>\n<p>解决办法：U、S 元素本身是废弃元素，应避免使用，而用 CSS 相关特性来替代这些元素产生的效果。</p>\n</blockquote>\n</li>\n<li><p>8、IE6 IE7 IE8(Q) 中 cellspacing 属性在重合的边框模型的表格中仍然有效。</p>\n<blockquote>\n<p>解决办法：在使用 border-collapse:collapse 时应保证 TABLE 元素的 cellspacing 属性值为 0。</p>\n</blockquote>\n</li>\n<li><p>9、在 IE Chrome Safari 中，IFRAME 元素引入的子页面 HTML 元素的 “overflow:hidden” 会使 IFRAME 元素的 scrolling 属性失效，IFRAME 元素不会出现滚动条。<br>在 Chrome Safari 中，虽然 IFRAME 元素的 scrolling 属性为 “no”，但若其子页面的 HTML 或 BODY 元素的 ‘overflow’ 特性为 ‘scroll’，则 IFRAME 仍会被渲染上滚动条。</p>\n<blockquote>\n<p>解决办法：W3C 规范并没有说明 scrolling 属性应该控制子页面哪个元素的滚动条的生成或者 ‘overflow’ 特性，为防止在某些情况下 Chrome Safari 的 IFRAME 子页面中出现多余滚动条，应避免为 HTML 或者 BODY 元素设置 overflow:scroll。</p>\n</blockquote>\n</li>\n<li><p>10、IE 混杂模式(Q) 中给 IMG 元素设置 ‘padding’ 特性无效。</p>\n<blockquote>\n<p>解决办法：使用标准模式。<br>在 IE6(Q) IE7(Q) IE8(Q) 中如需为 IMG 元素设置 ‘padding’ 特性，需要在 IMG 元素外加一层容器标签，为该标签设置 ‘padding’。</p>\n</blockquote>\n</li>\n<li><p>11、在 IE6 IE7 IE8(Q) Firefox(Q) Opera(Q) 中，FONT 元素的 color 属性指定的颜色可以覆盖由其祖先元素生成的 ‘text-decoration’ 修饰效果的颜色。<br>在 Chrome(Q) Safari(Q) 中，FONT 元素的 CSS ‘color’ 特性指定的颜色可以将由其祖先元素生成的 ‘text-decoration’ 修饰效果的颜色覆盖。</p>\n<blockquote>\n<p>解决办法：FONT 元素本身是废弃元素，并且其所有属性均已不推荐使用，应避免使用 FONT 元素。<br>FONT 元素的 size、color、face 属性可以分别使用 SPAN 元素搭配 ‘font-size’、’color’、’font-family’ 这几个 CSS 特性实现相同的效果。</p>\n</blockquote>\n</li>\n<li><p>12、不同浏览器中 Flash 与其他元素发生覆盖时， Flash 与其他元素的层叠顺序有差异。</p>\n<blockquote>\n<p>解决办法：若有页面需求是要求其他元素遮挡 Flash</p>\n<ul>\n<li>使用 EMBED 引入Flash 。</li>\n<li>wmode的值使用 ‘transparent’ 或 ‘opaque’ 。</li>\n<li>使用的 iframe 需要设置背景色(设置为白色)。</li>\n</ul>\n</blockquote>\n</li>\n<li><p>13、在 Chrome Safari 中，若表格设定了 cellspacing 属性或者 ‘border-spacing’ 特性，则由于设定的单元格上下间隙会作用在 THEAD、TBODY、TFOOT 元素内部，会导致这些元素之间会出现双倍的间隙。</p>\n<blockquote>\n<p>解决办法：CSS 规范并没有明确说明单元格间隙的作用位置以及行组元素对其的影响，所以为了避免差异应避免在包含 THEAD、TBODY、TFOOT 这类行组元素的表格内设定非 0 的单元格间隙 (cellsping 属性或 ‘border-spacing’ 特性)。</p>\n</blockquote>\n</li>\n<li><p>14、在 IE6 IE7 IE8(Q) 中，无论容器的宽度为多大，其内所有 align 属性设置为 ‘left’ 或 ‘right’ 的 IMG、OBJECT、TABLE、IFRAME 等元素将始终显示在一行中。并不会随着其包含块宽度的缩小而发生折行现象。</p>\n<blockquote>\n<p>解决办法：align 属性已被废弃，应避免使用这类 HTML 属性。为 IMG、OBJECT、IFRAME、TABLE、APPLET、EMBED 元素使用 CSS 的 ‘float’ 特性以达到相同的效果。</p>\n</blockquote>\n</li>\n<li><p>15、IE Opera 中会将 image 选择器解释为 IMG 选择器，其他浏览器不存在此问题。</p>\n<blockquote>\n<p>解决办法：严格按照 CSS2.1 及 DOM 规范的规定书写代码，避免作为 CSS 选择子以及在脚本中需要传入 HTML 标签名的方法中使用 IMAGE 关键字。</p>\n</blockquote>\n</li>\n<li><p>16、CSS2.1 规范中并没有明确说明对于应用 “shrink-to-fit” 算法计算宽度的元素内包含 ‘width’ 特性单位为 “百分比” 的元素时究竟应该如何计算父子元素的宽度。但 IE 在此类情况下，对于宽度的计算与规范中明确说明的规定有明显出入，导致计算的宽度与其他浏览器有很大的差异。且与文档模式有关。</p>\n<blockquote>\n<p>解决办法：</p>\n<ul>\n<li>明确为浮动元素设置一个宽度值，避免其在进行 “shrink-to-fit” 计算时在不同浏览器之间出现的宽度计算差异。</li>\n<li>若浮动元素出于某些情况必须使用 “shrink-to-fit” 宽度时，则应尽量保证其内子元素的宽度不依赖其自身宽度，如使用 px 为单位的宽度值。</li>\n</ul>\n</blockquote>\n</li>\n<li><p>17、当某块级元素设置了 margin-top ，并且之前存在着可被渲染的绝对定位元素时，其 margin-top 在 IE6 IE7 IE8(Q) 会失效。</p>\n<blockquote>\n<p>解决办法：针对这类低版本 IE 浏览器的 bug，请尽量避免满足其所有触发条件。如本例中所需间隙可以采用其它设置元素的 margin-bottom或问题元素的 padding-top 等方式来弥补。</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>"},{"title":"与脚本相关的兼容性问题","date":"2015-08-19T15:19:47.000Z","keywords":"javascript兼容性, js兼容性, 浏览器兼容性","_content":"内容如题\n<!-- more -->\n---\n一、JavaScript 核心\n===\n\n> - 1、在 ECMAScript 中，变量名、对象的属性或方法名都是标识符，标识符可以包含英文字母、数字、美元符号 '$' 和下划线 '_'，但不能以数字开头，不能是保留字。换句话说，'+'，'.' 等符号是不能出现在标识符中的。关于标识符的更多信息，请参考 ECMAScript 规范 7.6 Identifier Names and Identifiers 的内容。\n>> 解决办法：避免使用 IE 的这些“特性”，以保证兼容所有浏览器。\n\n> - 2、Firefox 的 TraceMonkey 引擎对函数声明的处理与 ECMAScript 规范的要求不符，TraceMonkey 将块中的函数声明作为“函数语句”来处理。而其他浏览器的引擎仍将这类块中的函数声明当作该块之外的函数声明来解析。\n>> 解决办法：将条件语句中的函数声明替换为函数表达式，如：\n\t\n\tfunction foo(){\n\t  if(window===parent){\n\t    var bar=function(){alert(1);}\n\t  }\n\t  else{\n\t    var bar=function(){alert(2);}\n\t  }\n\t  bar();\n\t}\n\tfoo();\n\n> - 3、改变 Date、Array 或 String 等对象的原型对象中的属性或方法的引用后，再用 for in 遍历一个 Date、Array 或 String 对象时，在 Safari Chrome 中可以遍历出这个修改过的属性或方法名。\n>> 解决办法：对于数组，避免用 for...in 方式而采用索引即数字下标的形式枚举数组成员。对于 Date String 以及其他对象，没有必要使用 for...in 来枚举它们的成员，因此一般不会有兼容性问题。\n\n> - 4、Date 对象的 toLocaleString 方法在各浏览器下的返回值存在格式上的差异。\n>> 解决办法：要获得相同格式的时间字符串，请不要使用 Date.prototype.toLocaleString() 方法，可以通过分别使用 getFullYear、getMonth、getDate 和 getDay 分别获得各关键字符串并拼装\n\n> - 5、在 IE6 IE7 IE8 中，JavaScript 代码中语句块结束符号“}”之后的第一个分号“;”会被忽略。\n>> 解决办法：按照规范书写正确的代码。\n\n> - 6、JSON 字符串或对象直接量的最后一个键值对后加 ',' 在 IE6 IE7 IE8(Q) 浏览器中会导致脚本中断。\n>> 解决办法：即便规范没有强调最后一个键值对的后边不能出现 ','，也要确保最后一个键值对之后没有多余的 ','，以兼容各浏览器。\n\n> - 7、当数组直接量以 ',' 结尾时，IE 和非 IE 得到的数组对象的长度不一致。IE 会以 ECMAScript 规范第三版中规定的方式解析该数组。即该数组的长度将比其他浏览器多 1。\n>> 解决办法：数组直接量的最后不要出现 ','，以保证兼容各浏览器。\n\n> - 8、IE 中允许变量名中出现 '，' 等中文标点符号，而其他浏览器则不允许。\n>> 解决办法：避免在变量名（即标识符）中出现中文标点，以保证兼容各浏览器。\n\n> - 9、在一个元素的属性中绑定事件，实际上就创建了一个内联事件处理函数（如<h1 onclick=\"alert(this);\"...>...</h1>）,内联事件处理函数有其特殊的作用域链，并且各浏览器的实现细节也有差异。\n>> 解决办法：\n>> -  尽量不要使用内联事件处理函数，使用 DOM 标准的事件注册方式为该元素注册事件处理函数\n>> -  必须使用内联事件处理函数时，要保证该函数内试图访问的变量是位于全局作用域内的，而不会因该函数独特的作用域链而引用到非预期的对象。最简单的办法是使用前缀，如 'my_onsearch'。\n\n> - 10、Date 对象的 getYear 方法在各浏览器下的返回值存在差异。\n>> 解决办法：要获得一个具体时间的年份，请不要使用 Date.prototype.getYear() 方法，使用 Date.prototype.getFullYear() 代替，以在各浏览器下获得相同的表现。另外，要给一个 Date 对象设置年份，也请不要使用 Date.prototype.setYear() 方法，使用 Date.prototype.setFullYear() 代替。\n\n> - 11、Chrome Opera 中使用 for-in 语句遍历对象的属性时，遍历出的属性顺序与对象定义时不同。\n>> 解决办法：for-in 语句无法保证遍历顺序，应尽量避免编写依赖对象属性顺序的代码。如果想顺序遍历一组数据，请使用数组并使用 for 语句遍历。 如果想按照定义的次序遍历对象属性，请参考本文针对各浏览器编写特殊代码。\n\n> - 12、IE6 IE7 IE8(Q) 不支持 JSON 对象。\n>> 解决办法：可以使用 window.eval() 或 new Function(){} 的方式解析 JSON 格式字符串\n\n\t<script type=\"text/javascript\">\n\t  window.onload = function(){\n\t    var info = document.getElementById(\"info\"),\n\t      jsonStr = '{\"name\": \"w3help\", \"url\": \"www.w3help.org\", \"tech\": [\"js\", \"HTML\", \"CSS\", 5, 4.01, 2.1],'\n\t          + '\"online\": true, \"category\": {\"RCA\": \"Root Cause Artical\", \"KB\":\"Knowledge Base\"},'\n\t          + '\"version\": 1}', p, w3help;\n\n\t    //使用两种简单的方式解析 JSON 格式字符串\n\t    json1 = eval(\"(\" + jsonStr + \")\"),\n\t    json2 = (new Function(\"return \" + jsonStr))();\n\n\t    for(p in json1)\n\t      info.innerHTML += p + \" : \" + json1[p] + \"<br/>\";\n\t    info.innerHTML += \"-----------------------<br />\";\n\t    for(p in json2)\n\t      info.innerHTML += p + \" : \" + json2[p] + \"<br/>\";\n\t  }\n\t</script>\n\t<div id=\"info\" style=\"width:350px;\"></div>\n\n> - 13、ECMAScript 中并没有明确说明 comparefn 返回值是布尔型时应该如何处理，它仅仅描述 comparefn 调用的返回值应当是 -1、0、1 这三种情况之一。comparefn 的返回值规范实现约束是 “引擎开发者” 还是 “脚本使用者” 并没有明确表述.这导致不同引擎对于 comparefn 返回值为非 -1、0、1 范围时具体处理不一致，从而使排序结果非预期。\n>> 解决办法：调用 Array.prototype.sort 函数并需要依赖 comparefn 处理排序结果时，应遵循规将 comparefn 函数返回值约束在 -1、0、1 范围内。\n\n---\n二、文本对象模型\n===\n\n> - 1、在 IE6 IE7 IE8(Q) 中，支持以 document.getElementById(elementName) 的方式获取 name 属性值为 elementName 的 A APPLET BUTTON FORM IFRAME IMG INPUT MAP META OBJECT EMBED SELECT TEXTAREA 元素。\n>> 解决办法：在使用 document.getElementById 方法获取页面元素时，应传入元素的 id 属性值，而不能使用元素的 name 属性值。同时需注意页面中的元素的 id 属性值不能与其他元素的 name 属性值有重复。\n\n\n> - 2、使用 document.getElementById 方法获取页面内的元素时，在 IE6 IE7 IE8(Q) 中的 id 是大小写不敏感的。\n>> 解决办法：在使用 document.getElementById 获取页面元素时，应保证作为参数的 id 与目标元素的实际 id 值完全一致。\n\n> - 3、IE 在创建 DOM 树时，会忽略某些空白字符，因此会比其他浏览器少创建一些文本节点。反过来说，同样的一篇文档，其他浏览器将比 IE 多创建一些文本节点。\n>> 解决办法： \n>> - 没有必要时尽量去掉各标签之间的空白字符。\n>> - 在获取节点时做类型判断。\n\n> - 4、各浏览器中的 NodeList 接口存的实现有差异。\n>> 解决办法：要从 NodeList 中获取元素，请使用 NodeList[index]、NodeList[name] 或 NodeList.item(index)，以保证兼容各浏览器。\n\n> - 5、在非 IE 浏览器中可能导致脚本异常，停止解析。\n>> 解决办法：使用方式 1 达到简写一些 DOM 和 BOM 对象原生方法的目的。\n\n\t//方式1\n\tvar println1 = function(str){document.writeln(str);};\n\n> - 6、IE6 IE7 IE8(Q) 混淆了 DOM 对象的属性（property）及 HTML 标签属性（attribute）这两个概念。其对于 getAttribute 及 setAttribute 方法的实现与 HTML DOM 对象的属性的 getter 与 setter 操作等价，这个错误的实现方式导致了一系列的兼容性问题。而在 IE8(S) 中，导致的大多数兼容性问题已不存在，但是仍然可以通过 \"Element.PropertyName\" 访问到这个 HTML 元素的自定义属性。\n>> 解决办法：\n>> - 避免使用 \"Element.setAttribute(\"style\", \"XXX\")\" 在所有浏览器中设置元素的 style 属性，可以改用符合规范的 \"Element.style.cssText = \"XXX\"\"；\n>> - 避免使用 \"Element.setAttribute(\"class\", \"XXX\")\" 在所有浏览器中设置元素的 class 属性，可以改用符合规范的 \"Element.className = \"XXX\"\"；\n>> - 避免使用诸如 \"Element.setAttribute(\"onclick\", \"alert('ok')\")\" 为元素绑定事件，可以使用符合规范的 Element.onclick = function () { [code] } 或 IE 的 attachEvent 方法等；\n避免使用诸如 \"Element.getAttibute(\"innerHTML\")\" 的方式获取 innerHTML 属性值；\n>> - 针对表单元素，使用 Element.value 获取控件的 \"当前值\"，而不要用 getAttribute(\"value\") 获取；\n>> - 针对自定义的 HTML 属性，一律使用 getAttribute 方法获取属性值。\n\n> - 7、各浏览器对 DOMImplementation 接口的支持程度不同。\n>> 解决办法：避免使用各浏览器支持程度不同的 DOMImplementation 的接口\n\n> - 8、DocumnetLS 是 DOM3 中一个过时的接口。\n>> 解决办法：由于 W3C 推荐的标准中，已经放弃了 DocumentLS 接口，为更好的兼容各浏览器，建议采用 XMLHttpRequest 方式载入xml文件，示例代码如下：\n\t\n\tvar xhr = window.XMLHttpRequest ?\n\t                  new window.XMLHttpRequest():\n\t                  new window.ActiveXObject(\"Microsoft.XMLHTTP\")\n\txhr.onreadystatechange = function(){\n\t    if(xhr.readyState == 4){\n\t        var xmlDoc = xhr.responseXML\n\t        // do something what you want ...\n\t    }\n\t};\n\txhr.open('GET', 'test.xml', true);\n\txhr.send();\n\n\n> - 9、Firefox Opera 不支持 \"document.styleSheets\" 通过 STYLE 元素 id 获取 CSSStyleSheet 对象，仅支持整数作为下标获取。\n>> 解决办法：避免使用 \"document.styleSheets\" 通过 STYLE 元素 id 获取 CSSStyleSheet 对象，使用 W3C 规范中的整数下标方式获取。\n\n> - 10、在 IE6 IE7 IE8 中，createElement 方法不仅可以通过合法的标签名创建节点对象，还可以通过传入一段合法的 HTML 代码字符串作为参数创建节点对象。\n>> 解决办法：对于一般的非替换元素，在各浏览器中均使用 W3C 规范中的标准的为 createElement 方法传入标签名的做法。\n对于一些 IE 处理有问题的替换元素，则注意判断浏览器，针对 IE 使用其特有的通过为 createElement 传入一段合法的 HTML 代码字符串作为参数的方法，非 IE 浏览器仍然使用 W3C 规范的标准方法。\n\n> - 11、各浏览器对元素绑定、解绑事件监听器的方法，事件对象的获取，以及 Event 对象的实现上存在差异。\n>> 解决办法：\n>> - 使用特性判断创建无兼容性问题的事件监听器绑定和解绑函数\n>> - 使用特性判断获得有效的事件对象\n>> - 使用特性判断使用与标准对应的非标准方法及属性\n\n> - 12、使用 document.getElementsByName 方法获取页面内的元素时，在 IE6 IE7 IE8 中的 name 是大小写不敏感的。\n>> 解决办法：在使用 document.getElementsByName 方法获取页面元素时，应保证作为参数的 name 与目标元素的实际 name 值完全一致。\n\n> - 13、各浏览器 document、document.body、document.documentElement 对象的 onscroll 事件的支持存在差异。\n>> 解决办法：在给整个浏览器窗口绑定滚动事件 (scroll) 的时候，绑定到 window 对象上。\n\n> - 14、IE 标准模式下 BODY 元素的高度发生变化时就会触发 window.onresize 事件。\n>> 解决办法：\n>> - 不期望触发 window.onresize 事件时：\n>> - 期望触发 window.onresize 事件时：\n\n> - 16、使用这两个方法将在 Firefox 浏览器内报错。\n>> 解决办法：在 Firefox 中，可通过扩展 HTMLElement 的原型 (prototype) 来实现这两个方法\n\n\n> - 17、Firefox 不支持 DOM 对象的 outerHTML innerText outerText 属性。\n>> 解决办法：在 Firefox 中，可通过扩展 HTMLElement 的原型 (prototype) 来实现相关属性。\n\n> - 18、在 IE6 IE7 IE8(Q) 中，一个 'position' 特性值为 'static' 的元素的 offsetParent 可能会是其最近的、触发了 hasLayout 的父元素。\n同时其 offsetTop、offsetLeft 的返回值参照元素也是距离其最近的触发了 hasLayout 的祖先级元素。\n>> 解决办法：可考虑对于为在 IE 中触发了 hasLayout 特性的元素设置 'position' 特性值为非 'static' 值，如 'relative'，或避免使用元素的 offsetTop、offsetLeft、offsetParent 属性。\n\n> - 19、插入空白页面 IFRAME 元素时 Chrome Safari Opera 浏览器中会触发 load 事件。\n>> 解决办法：为 IFRAME 标签的 src 属性指定具体 URL 后再将节点插入 DOM 树中 。\n\n> - 20、IE 和 Firefox 提供了对 window.onerror 事件的支持，当页面内的 JavaScript 脚本出现错误时，window.onerror 被触发。\n>> 解决办法：放弃使用 window.onerror，通过合理使用 try-catch 来达到近似的效果。\n\n> - 21、各浏览器中，原生可以触发 onfocus 事件以及通过其 focus() 方法获得焦点的元素不相同，而在元素设置了 tabindex 属性后焦点获取情况也不相同。\n在 IE 中，DIV 和 SPAN 元素若在当前的 IE 中触发了 hasLayout 则也可以触发 onfocus 事件以及通过其 focus() 方法获得焦点。\n>> 解决办法：对于一般常见的可视元素，若需要元素可触发 onfocus 事件以及通过其 focus() 方法获得焦点，则应为其设置 tabindex 属性。\n\n> - 22、页面加载完成后会触发 onload 事件，通常下会使用 window.onload 、 document.body.onload、 HTMLIFrame.onload 方法来处理他；但是各浏览器对页面 onload 事件处理方式并不一致，这些方法可能会导致页面加载完成后无法触事件处理函数。\n>> 解决办法：\n>> - 统一为 window 对象的 onload 事件绑定函数，避免在 Firefox 中产生 document.body.onload 事件理解歧义。\n>> - 统一使用 DOM 规范的事件监听方法（或 IE 专有事件绑定方法）为 IFRAME 标记绑定 onload 事件处理函数。\n\n> - 23、各浏览器计算不包含在普通流中的内容元素的 scrollHeight 值时结果有差异。\n>> 解决办法：确保读取 scrollHeight 属性的元素均创建了新的 block formatting context，或者此容器与内部子容器处于同一文档流中，以此避免各浏览器中读数不同。\n\n\n> - 24、在 IE6 IE7 IE8(Q) 中，无法通过脚本检测到 DOM 接口原型，故无法获得其接口继承关系。\n在 IE8(S) 中，只能检测到部分 DOM 接口原型，但这些原型不可枚举，故无法获得其接口继承关系。\n在 Firefox 中，部分 DOM 接口原型不可枚举，接口继承关系与 DOM 规范中的描述不符。\n在 Chrome Safari Opera 中，DOM 接口继承关系遵照了 DOM 规范中的描述。\n>> 解决办法：由于各浏览器中 DOM 接口实现的不一致性，这里建议应尽量避免修改浏览器脚本引擎内 DOM 接口的原生方法。\n\n> - 25、IE6 IE7 IE8 Opera 支持除 INPUT 和 BUTTON 元素以外的其他元素的 \"click\" 方法，这使得各浏览器对除 INPUT 和 BUTTON 元素以外的其他元素的 \"click\" 的支持情况存在差异。\n>> 解决办法：建议尽量避免对除 INPUT 和 BUTTON 元素以外的其他元素通过 \"click\" 方法模拟鼠标点击事件。\n\n> - 26、当 document 从 window 中移除，将触发 onunload 事件，各浏览器对 onunload 事件的支持与触发条件实现有差异。\n>> 解决办法：各浏览器的支持以及事件触发条件差异较多，需谨慎使用。\n\n> - 27、在用户通过鼠标操作触发 click 事件时，基本的事件触发流程为：MouseDown 事件 --> MouseUp 事件 --> Click 事件。\n如果用户点击的元素可以获得焦点，并且当前还没有获得焦点时，会在 MouseUp 事件前先触发 Focus 事件，再依次触发其后事件。\n此时就会出现问题，如果被点击的元素无法通过点击操作获得焦点，则 Focus 事件不会被触发，他的事件函数也不会因点击操作而运行，这就有可能导致功作者设计的功能无法按预期效果执行。\n>> 解决办法：\n>> - 只在 INPUT[type=text] INPUT[type=password] SELECT TEXTAREA 元素中，使用 Focus 事件替代 click 事件触发相关业务逻辑处理程序。\n>> - 其他标记中的 Focus 事件无法使用鼠标指针的 click 操作触发，仅能通过 TAB 键切到可触发 Focus 事件的元素中才会生效。\n\n> - 28、typeof 运算符存在兼容性问题\n>> 解决办法：由于以上几点的各浏览器实现差异，我们建议用户在充分了解 typeof 运算符含义时再使用。\n下面的代码封装了名为 realtypeof 的方法，用来消除已知的各浏览器之间原生 typeof 运算符差异，仅作参考：\n\n\tfunction realtypeof(source){\n\t  return (source === undefined)\n\t    ? \"undefined\"\n\t    : (\"object\" === typeof source)\n\t      ? (/function/i.test( source + \"\" ))\n\t        ? \"function\"\n\t        : \"object\"\n\t      : (source.constructor == RegExp || !(source.constructor instanceof Function))\n\t        ? \"object\"\n\t        : typeof source;\n\t}\n\n> - 29、各浏览器下在向文档树中插入通过 cloneNode(true) 创建的节点时，其内的 SCRIPT 元素中的脚本在 Chrome 和 Safari 中会执行，在 IE Firefox Opera 中没有执行。\n>> 解决办法：避免深度复制 \"cloneNode(true)\" 包含 SCRIPT 元素的节点。\n\n> - 30、各浏览器对标准的支持有差异，并且他们实现了非标准的添加和删除 OPTION 元素的方法，在使用这些方法时，可能造成兼容性问题。\n>> 解决办法：\n>> 1. 在添加 OPTION 元素时\n>> - 如果需要向指定索引前插入 OPTION，可以使用 options.add(option, index)；\n>> - 如果需要向 SELECT 尾部添加 OPTION，可以使用 options.add(option)；\n>> - 如果需要向指定索引处添加（或更改） OPTION，可以使用 options[index] = option。\n>>2. 在删除 OPTION 元素时\n>> - 如果想删除指定索引处的 OPTION 元素，可以使用 select.remove(index) 或 options[index] = null；\n>> - 如果想删除某个指定的 OPTION 元素，可以使用 select.remove(option)；\n>> - 如果想删除 SELECT 中所有 OPTION，可以使用 select.length = 0 或 options.length = 0。\n\n\n> - 31、各浏览器对 Range 接口的实现存在差异。IE6 IE7 IE8 实现了独有的类似 Range 的 TextRange 对象，该对象拥有一些与标准 Range 接口中类似的属性及方法， 并且在创建 TextRange 时也与标准存在差异；而 Firefox Chrome Safari Opera 除了实现标准的 Range 接口外，还在此基础上扩展了一些属性及方法。 在创建 Range 时，也可以使用各自实现的 Selection 对象的 getRangeAt() 方法。\n>> 解决办法：通过浏览器特性检测针对 IE6 IE7 IE8 正确创建 TextRange，对其它浏览器创建 Range。虽然 IE6 IE7 IE8 没有实现 Range 接口，但 TextRange 对象中也提供了许多能够实现类似功能的属性和方法。\n\n> - 32、IE6 IE7 IE8 IE9(Q) 中 change、select、submit、reset 事件均不产生事件冒泡。\n>> 解决办法：为了兼容低版本的 IE 浏览器，建议 change、select、submit、reset 事件均不要依赖事件冒泡机制委托给其祖先元素处理。\n\n---","source":"_posts/与脚本相关的兼容性问题.md","raw":"title: 与脚本相关的兼容性问题\ndate: 2015-08-19 23:19:47\ntags: 兼容性\ncategories: 与脚本相关的兼容性问题\nkeywords: javascript兼容性, js兼容性, 浏览器兼容性\n---\n内容如题\n<!-- more -->\n---\n一、JavaScript 核心\n===\n\n> - 1、在 ECMAScript 中，变量名、对象的属性或方法名都是标识符，标识符可以包含英文字母、数字、美元符号 '$' 和下划线 '_'，但不能以数字开头，不能是保留字。换句话说，'+'，'.' 等符号是不能出现在标识符中的。关于标识符的更多信息，请参考 ECMAScript 规范 7.6 Identifier Names and Identifiers 的内容。\n>> 解决办法：避免使用 IE 的这些“特性”，以保证兼容所有浏览器。\n\n> - 2、Firefox 的 TraceMonkey 引擎对函数声明的处理与 ECMAScript 规范的要求不符，TraceMonkey 将块中的函数声明作为“函数语句”来处理。而其他浏览器的引擎仍将这类块中的函数声明当作该块之外的函数声明来解析。\n>> 解决办法：将条件语句中的函数声明替换为函数表达式，如：\n\t\n\tfunction foo(){\n\t  if(window===parent){\n\t    var bar=function(){alert(1);}\n\t  }\n\t  else{\n\t    var bar=function(){alert(2);}\n\t  }\n\t  bar();\n\t}\n\tfoo();\n\n> - 3、改变 Date、Array 或 String 等对象的原型对象中的属性或方法的引用后，再用 for in 遍历一个 Date、Array 或 String 对象时，在 Safari Chrome 中可以遍历出这个修改过的属性或方法名。\n>> 解决办法：对于数组，避免用 for...in 方式而采用索引即数字下标的形式枚举数组成员。对于 Date String 以及其他对象，没有必要使用 for...in 来枚举它们的成员，因此一般不会有兼容性问题。\n\n> - 4、Date 对象的 toLocaleString 方法在各浏览器下的返回值存在格式上的差异。\n>> 解决办法：要获得相同格式的时间字符串，请不要使用 Date.prototype.toLocaleString() 方法，可以通过分别使用 getFullYear、getMonth、getDate 和 getDay 分别获得各关键字符串并拼装\n\n> - 5、在 IE6 IE7 IE8 中，JavaScript 代码中语句块结束符号“}”之后的第一个分号“;”会被忽略。\n>> 解决办法：按照规范书写正确的代码。\n\n> - 6、JSON 字符串或对象直接量的最后一个键值对后加 ',' 在 IE6 IE7 IE8(Q) 浏览器中会导致脚本中断。\n>> 解决办法：即便规范没有强调最后一个键值对的后边不能出现 ','，也要确保最后一个键值对之后没有多余的 ','，以兼容各浏览器。\n\n> - 7、当数组直接量以 ',' 结尾时，IE 和非 IE 得到的数组对象的长度不一致。IE 会以 ECMAScript 规范第三版中规定的方式解析该数组。即该数组的长度将比其他浏览器多 1。\n>> 解决办法：数组直接量的最后不要出现 ','，以保证兼容各浏览器。\n\n> - 8、IE 中允许变量名中出现 '，' 等中文标点符号，而其他浏览器则不允许。\n>> 解决办法：避免在变量名（即标识符）中出现中文标点，以保证兼容各浏览器。\n\n> - 9、在一个元素的属性中绑定事件，实际上就创建了一个内联事件处理函数（如<h1 onclick=\"alert(this);\"...>...</h1>）,内联事件处理函数有其特殊的作用域链，并且各浏览器的实现细节也有差异。\n>> 解决办法：\n>> -  尽量不要使用内联事件处理函数，使用 DOM 标准的事件注册方式为该元素注册事件处理函数\n>> -  必须使用内联事件处理函数时，要保证该函数内试图访问的变量是位于全局作用域内的，而不会因该函数独特的作用域链而引用到非预期的对象。最简单的办法是使用前缀，如 'my_onsearch'。\n\n> - 10、Date 对象的 getYear 方法在各浏览器下的返回值存在差异。\n>> 解决办法：要获得一个具体时间的年份，请不要使用 Date.prototype.getYear() 方法，使用 Date.prototype.getFullYear() 代替，以在各浏览器下获得相同的表现。另外，要给一个 Date 对象设置年份，也请不要使用 Date.prototype.setYear() 方法，使用 Date.prototype.setFullYear() 代替。\n\n> - 11、Chrome Opera 中使用 for-in 语句遍历对象的属性时，遍历出的属性顺序与对象定义时不同。\n>> 解决办法：for-in 语句无法保证遍历顺序，应尽量避免编写依赖对象属性顺序的代码。如果想顺序遍历一组数据，请使用数组并使用 for 语句遍历。 如果想按照定义的次序遍历对象属性，请参考本文针对各浏览器编写特殊代码。\n\n> - 12、IE6 IE7 IE8(Q) 不支持 JSON 对象。\n>> 解决办法：可以使用 window.eval() 或 new Function(){} 的方式解析 JSON 格式字符串\n\n\t<script type=\"text/javascript\">\n\t  window.onload = function(){\n\t    var info = document.getElementById(\"info\"),\n\t      jsonStr = '{\"name\": \"w3help\", \"url\": \"www.w3help.org\", \"tech\": [\"js\", \"HTML\", \"CSS\", 5, 4.01, 2.1],'\n\t          + '\"online\": true, \"category\": {\"RCA\": \"Root Cause Artical\", \"KB\":\"Knowledge Base\"},'\n\t          + '\"version\": 1}', p, w3help;\n\n\t    //使用两种简单的方式解析 JSON 格式字符串\n\t    json1 = eval(\"(\" + jsonStr + \")\"),\n\t    json2 = (new Function(\"return \" + jsonStr))();\n\n\t    for(p in json1)\n\t      info.innerHTML += p + \" : \" + json1[p] + \"<br/>\";\n\t    info.innerHTML += \"-----------------------<br />\";\n\t    for(p in json2)\n\t      info.innerHTML += p + \" : \" + json2[p] + \"<br/>\";\n\t  }\n\t</script>\n\t<div id=\"info\" style=\"width:350px;\"></div>\n\n> - 13、ECMAScript 中并没有明确说明 comparefn 返回值是布尔型时应该如何处理，它仅仅描述 comparefn 调用的返回值应当是 -1、0、1 这三种情况之一。comparefn 的返回值规范实现约束是 “引擎开发者” 还是 “脚本使用者” 并没有明确表述.这导致不同引擎对于 comparefn 返回值为非 -1、0、1 范围时具体处理不一致，从而使排序结果非预期。\n>> 解决办法：调用 Array.prototype.sort 函数并需要依赖 comparefn 处理排序结果时，应遵循规将 comparefn 函数返回值约束在 -1、0、1 范围内。\n\n---\n二、文本对象模型\n===\n\n> - 1、在 IE6 IE7 IE8(Q) 中，支持以 document.getElementById(elementName) 的方式获取 name 属性值为 elementName 的 A APPLET BUTTON FORM IFRAME IMG INPUT MAP META OBJECT EMBED SELECT TEXTAREA 元素。\n>> 解决办法：在使用 document.getElementById 方法获取页面元素时，应传入元素的 id 属性值，而不能使用元素的 name 属性值。同时需注意页面中的元素的 id 属性值不能与其他元素的 name 属性值有重复。\n\n\n> - 2、使用 document.getElementById 方法获取页面内的元素时，在 IE6 IE7 IE8(Q) 中的 id 是大小写不敏感的。\n>> 解决办法：在使用 document.getElementById 获取页面元素时，应保证作为参数的 id 与目标元素的实际 id 值完全一致。\n\n> - 3、IE 在创建 DOM 树时，会忽略某些空白字符，因此会比其他浏览器少创建一些文本节点。反过来说，同样的一篇文档，其他浏览器将比 IE 多创建一些文本节点。\n>> 解决办法： \n>> - 没有必要时尽量去掉各标签之间的空白字符。\n>> - 在获取节点时做类型判断。\n\n> - 4、各浏览器中的 NodeList 接口存的实现有差异。\n>> 解决办法：要从 NodeList 中获取元素，请使用 NodeList[index]、NodeList[name] 或 NodeList.item(index)，以保证兼容各浏览器。\n\n> - 5、在非 IE 浏览器中可能导致脚本异常，停止解析。\n>> 解决办法：使用方式 1 达到简写一些 DOM 和 BOM 对象原生方法的目的。\n\n\t//方式1\n\tvar println1 = function(str){document.writeln(str);};\n\n> - 6、IE6 IE7 IE8(Q) 混淆了 DOM 对象的属性（property）及 HTML 标签属性（attribute）这两个概念。其对于 getAttribute 及 setAttribute 方法的实现与 HTML DOM 对象的属性的 getter 与 setter 操作等价，这个错误的实现方式导致了一系列的兼容性问题。而在 IE8(S) 中，导致的大多数兼容性问题已不存在，但是仍然可以通过 \"Element.PropertyName\" 访问到这个 HTML 元素的自定义属性。\n>> 解决办法：\n>> - 避免使用 \"Element.setAttribute(\"style\", \"XXX\")\" 在所有浏览器中设置元素的 style 属性，可以改用符合规范的 \"Element.style.cssText = \"XXX\"\"；\n>> - 避免使用 \"Element.setAttribute(\"class\", \"XXX\")\" 在所有浏览器中设置元素的 class 属性，可以改用符合规范的 \"Element.className = \"XXX\"\"；\n>> - 避免使用诸如 \"Element.setAttribute(\"onclick\", \"alert('ok')\")\" 为元素绑定事件，可以使用符合规范的 Element.onclick = function () { [code] } 或 IE 的 attachEvent 方法等；\n避免使用诸如 \"Element.getAttibute(\"innerHTML\")\" 的方式获取 innerHTML 属性值；\n>> - 针对表单元素，使用 Element.value 获取控件的 \"当前值\"，而不要用 getAttribute(\"value\") 获取；\n>> - 针对自定义的 HTML 属性，一律使用 getAttribute 方法获取属性值。\n\n> - 7、各浏览器对 DOMImplementation 接口的支持程度不同。\n>> 解决办法：避免使用各浏览器支持程度不同的 DOMImplementation 的接口\n\n> - 8、DocumnetLS 是 DOM3 中一个过时的接口。\n>> 解决办法：由于 W3C 推荐的标准中，已经放弃了 DocumentLS 接口，为更好的兼容各浏览器，建议采用 XMLHttpRequest 方式载入xml文件，示例代码如下：\n\t\n\tvar xhr = window.XMLHttpRequest ?\n\t                  new window.XMLHttpRequest():\n\t                  new window.ActiveXObject(\"Microsoft.XMLHTTP\")\n\txhr.onreadystatechange = function(){\n\t    if(xhr.readyState == 4){\n\t        var xmlDoc = xhr.responseXML\n\t        // do something what you want ...\n\t    }\n\t};\n\txhr.open('GET', 'test.xml', true);\n\txhr.send();\n\n\n> - 9、Firefox Opera 不支持 \"document.styleSheets\" 通过 STYLE 元素 id 获取 CSSStyleSheet 对象，仅支持整数作为下标获取。\n>> 解决办法：避免使用 \"document.styleSheets\" 通过 STYLE 元素 id 获取 CSSStyleSheet 对象，使用 W3C 规范中的整数下标方式获取。\n\n> - 10、在 IE6 IE7 IE8 中，createElement 方法不仅可以通过合法的标签名创建节点对象，还可以通过传入一段合法的 HTML 代码字符串作为参数创建节点对象。\n>> 解决办法：对于一般的非替换元素，在各浏览器中均使用 W3C 规范中的标准的为 createElement 方法传入标签名的做法。\n对于一些 IE 处理有问题的替换元素，则注意判断浏览器，针对 IE 使用其特有的通过为 createElement 传入一段合法的 HTML 代码字符串作为参数的方法，非 IE 浏览器仍然使用 W3C 规范的标准方法。\n\n> - 11、各浏览器对元素绑定、解绑事件监听器的方法，事件对象的获取，以及 Event 对象的实现上存在差异。\n>> 解决办法：\n>> - 使用特性判断创建无兼容性问题的事件监听器绑定和解绑函数\n>> - 使用特性判断获得有效的事件对象\n>> - 使用特性判断使用与标准对应的非标准方法及属性\n\n> - 12、使用 document.getElementsByName 方法获取页面内的元素时，在 IE6 IE7 IE8 中的 name 是大小写不敏感的。\n>> 解决办法：在使用 document.getElementsByName 方法获取页面元素时，应保证作为参数的 name 与目标元素的实际 name 值完全一致。\n\n> - 13、各浏览器 document、document.body、document.documentElement 对象的 onscroll 事件的支持存在差异。\n>> 解决办法：在给整个浏览器窗口绑定滚动事件 (scroll) 的时候，绑定到 window 对象上。\n\n> - 14、IE 标准模式下 BODY 元素的高度发生变化时就会触发 window.onresize 事件。\n>> 解决办法：\n>> - 不期望触发 window.onresize 事件时：\n>> - 期望触发 window.onresize 事件时：\n\n> - 16、使用这两个方法将在 Firefox 浏览器内报错。\n>> 解决办法：在 Firefox 中，可通过扩展 HTMLElement 的原型 (prototype) 来实现这两个方法\n\n\n> - 17、Firefox 不支持 DOM 对象的 outerHTML innerText outerText 属性。\n>> 解决办法：在 Firefox 中，可通过扩展 HTMLElement 的原型 (prototype) 来实现相关属性。\n\n> - 18、在 IE6 IE7 IE8(Q) 中，一个 'position' 特性值为 'static' 的元素的 offsetParent 可能会是其最近的、触发了 hasLayout 的父元素。\n同时其 offsetTop、offsetLeft 的返回值参照元素也是距离其最近的触发了 hasLayout 的祖先级元素。\n>> 解决办法：可考虑对于为在 IE 中触发了 hasLayout 特性的元素设置 'position' 特性值为非 'static' 值，如 'relative'，或避免使用元素的 offsetTop、offsetLeft、offsetParent 属性。\n\n> - 19、插入空白页面 IFRAME 元素时 Chrome Safari Opera 浏览器中会触发 load 事件。\n>> 解决办法：为 IFRAME 标签的 src 属性指定具体 URL 后再将节点插入 DOM 树中 。\n\n> - 20、IE 和 Firefox 提供了对 window.onerror 事件的支持，当页面内的 JavaScript 脚本出现错误时，window.onerror 被触发。\n>> 解决办法：放弃使用 window.onerror，通过合理使用 try-catch 来达到近似的效果。\n\n> - 21、各浏览器中，原生可以触发 onfocus 事件以及通过其 focus() 方法获得焦点的元素不相同，而在元素设置了 tabindex 属性后焦点获取情况也不相同。\n在 IE 中，DIV 和 SPAN 元素若在当前的 IE 中触发了 hasLayout 则也可以触发 onfocus 事件以及通过其 focus() 方法获得焦点。\n>> 解决办法：对于一般常见的可视元素，若需要元素可触发 onfocus 事件以及通过其 focus() 方法获得焦点，则应为其设置 tabindex 属性。\n\n> - 22、页面加载完成后会触发 onload 事件，通常下会使用 window.onload 、 document.body.onload、 HTMLIFrame.onload 方法来处理他；但是各浏览器对页面 onload 事件处理方式并不一致，这些方法可能会导致页面加载完成后无法触事件处理函数。\n>> 解决办法：\n>> - 统一为 window 对象的 onload 事件绑定函数，避免在 Firefox 中产生 document.body.onload 事件理解歧义。\n>> - 统一使用 DOM 规范的事件监听方法（或 IE 专有事件绑定方法）为 IFRAME 标记绑定 onload 事件处理函数。\n\n> - 23、各浏览器计算不包含在普通流中的内容元素的 scrollHeight 值时结果有差异。\n>> 解决办法：确保读取 scrollHeight 属性的元素均创建了新的 block formatting context，或者此容器与内部子容器处于同一文档流中，以此避免各浏览器中读数不同。\n\n\n> - 24、在 IE6 IE7 IE8(Q) 中，无法通过脚本检测到 DOM 接口原型，故无法获得其接口继承关系。\n在 IE8(S) 中，只能检测到部分 DOM 接口原型，但这些原型不可枚举，故无法获得其接口继承关系。\n在 Firefox 中，部分 DOM 接口原型不可枚举，接口继承关系与 DOM 规范中的描述不符。\n在 Chrome Safari Opera 中，DOM 接口继承关系遵照了 DOM 规范中的描述。\n>> 解决办法：由于各浏览器中 DOM 接口实现的不一致性，这里建议应尽量避免修改浏览器脚本引擎内 DOM 接口的原生方法。\n\n> - 25、IE6 IE7 IE8 Opera 支持除 INPUT 和 BUTTON 元素以外的其他元素的 \"click\" 方法，这使得各浏览器对除 INPUT 和 BUTTON 元素以外的其他元素的 \"click\" 的支持情况存在差异。\n>> 解决办法：建议尽量避免对除 INPUT 和 BUTTON 元素以外的其他元素通过 \"click\" 方法模拟鼠标点击事件。\n\n> - 26、当 document 从 window 中移除，将触发 onunload 事件，各浏览器对 onunload 事件的支持与触发条件实现有差异。\n>> 解决办法：各浏览器的支持以及事件触发条件差异较多，需谨慎使用。\n\n> - 27、在用户通过鼠标操作触发 click 事件时，基本的事件触发流程为：MouseDown 事件 --> MouseUp 事件 --> Click 事件。\n如果用户点击的元素可以获得焦点，并且当前还没有获得焦点时，会在 MouseUp 事件前先触发 Focus 事件，再依次触发其后事件。\n此时就会出现问题，如果被点击的元素无法通过点击操作获得焦点，则 Focus 事件不会被触发，他的事件函数也不会因点击操作而运行，这就有可能导致功作者设计的功能无法按预期效果执行。\n>> 解决办法：\n>> - 只在 INPUT[type=text] INPUT[type=password] SELECT TEXTAREA 元素中，使用 Focus 事件替代 click 事件触发相关业务逻辑处理程序。\n>> - 其他标记中的 Focus 事件无法使用鼠标指针的 click 操作触发，仅能通过 TAB 键切到可触发 Focus 事件的元素中才会生效。\n\n> - 28、typeof 运算符存在兼容性问题\n>> 解决办法：由于以上几点的各浏览器实现差异，我们建议用户在充分了解 typeof 运算符含义时再使用。\n下面的代码封装了名为 realtypeof 的方法，用来消除已知的各浏览器之间原生 typeof 运算符差异，仅作参考：\n\n\tfunction realtypeof(source){\n\t  return (source === undefined)\n\t    ? \"undefined\"\n\t    : (\"object\" === typeof source)\n\t      ? (/function/i.test( source + \"\" ))\n\t        ? \"function\"\n\t        : \"object\"\n\t      : (source.constructor == RegExp || !(source.constructor instanceof Function))\n\t        ? \"object\"\n\t        : typeof source;\n\t}\n\n> - 29、各浏览器下在向文档树中插入通过 cloneNode(true) 创建的节点时，其内的 SCRIPT 元素中的脚本在 Chrome 和 Safari 中会执行，在 IE Firefox Opera 中没有执行。\n>> 解决办法：避免深度复制 \"cloneNode(true)\" 包含 SCRIPT 元素的节点。\n\n> - 30、各浏览器对标准的支持有差异，并且他们实现了非标准的添加和删除 OPTION 元素的方法，在使用这些方法时，可能造成兼容性问题。\n>> 解决办法：\n>> 1. 在添加 OPTION 元素时\n>> - 如果需要向指定索引前插入 OPTION，可以使用 options.add(option, index)；\n>> - 如果需要向 SELECT 尾部添加 OPTION，可以使用 options.add(option)；\n>> - 如果需要向指定索引处添加（或更改） OPTION，可以使用 options[index] = option。\n>>2. 在删除 OPTION 元素时\n>> - 如果想删除指定索引处的 OPTION 元素，可以使用 select.remove(index) 或 options[index] = null；\n>> - 如果想删除某个指定的 OPTION 元素，可以使用 select.remove(option)；\n>> - 如果想删除 SELECT 中所有 OPTION，可以使用 select.length = 0 或 options.length = 0。\n\n\n> - 31、各浏览器对 Range 接口的实现存在差异。IE6 IE7 IE8 实现了独有的类似 Range 的 TextRange 对象，该对象拥有一些与标准 Range 接口中类似的属性及方法， 并且在创建 TextRange 时也与标准存在差异；而 Firefox Chrome Safari Opera 除了实现标准的 Range 接口外，还在此基础上扩展了一些属性及方法。 在创建 Range 时，也可以使用各自实现的 Selection 对象的 getRangeAt() 方法。\n>> 解决办法：通过浏览器特性检测针对 IE6 IE7 IE8 正确创建 TextRange，对其它浏览器创建 Range。虽然 IE6 IE7 IE8 没有实现 Range 接口，但 TextRange 对象中也提供了许多能够实现类似功能的属性和方法。\n\n> - 32、IE6 IE7 IE8 IE9(Q) 中 change、select、submit、reset 事件均不产生事件冒泡。\n>> 解决办法：为了兼容低版本的 IE 浏览器，建议 change、select、submit、reset 事件均不要依赖事件冒泡机制委托给其祖先元素处理。\n\n---","slug":"与脚本相关的兼容性问题","published":1,"updated":"2016-10-31T07:25:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciuyzlut50006e6tba56fanwy","content":"<p>内容如题</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><a id=\"more\"></a></h2><h1 id=\"一、JavaScript-核心\"><a href=\"#一、JavaScript-核心\" class=\"headerlink\" title=\"一、JavaScript 核心\"></a>一、JavaScript 核心</h1><blockquote>\n<ul>\n<li><p>1、在 ECMAScript 中，变量名、对象的属性或方法名都是标识符，标识符可以包含英文字母、数字、美元符号 ‘$’ 和下划线 ‘_’，但不能以数字开头，不能是保留字。换句话说，’+’，’.’ 等符号是不能出现在标识符中的。关于标识符的更多信息，请参考 ECMAScript 规范 7.6 Identifier Names and Identifiers 的内容。</p>\n<blockquote>\n<p>解决办法：避免使用 IE 的这些“特性”，以保证兼容所有浏览器。</p>\n</blockquote>\n</li>\n<li><p>2、Firefox 的 TraceMonkey 引擎对函数声明的处理与 ECMAScript 规范的要求不符，TraceMonkey 将块中的函数声明作为“函数语句”来处理。而其他浏览器的引擎仍将这类块中的函数声明当作该块之外的函数声明来解析。</p>\n<blockquote>\n<p>解决办法：将条件语句中的函数声明替换为函数表达式，如：</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<pre><code>function foo(){\n  if(window===parent){\n    var bar=function(){alert(1);}\n  }\n  else{\n    var bar=function(){alert(2);}\n  }\n  bar();\n}\nfoo();\n</code></pre><blockquote>\n<ul>\n<li><p>3、改变 Date、Array 或 String 等对象的原型对象中的属性或方法的引用后，再用 for in 遍历一个 Date、Array 或 String 对象时，在 Safari Chrome 中可以遍历出这个修改过的属性或方法名。</p>\n<blockquote>\n<p>解决办法：对于数组，避免用 for…in 方式而采用索引即数字下标的形式枚举数组成员。对于 Date String 以及其他对象，没有必要使用 for…in 来枚举它们的成员，因此一般不会有兼容性问题。</p>\n</blockquote>\n</li>\n<li><p>4、Date 对象的 toLocaleString 方法在各浏览器下的返回值存在格式上的差异。</p>\n<blockquote>\n<p>解决办法：要获得相同格式的时间字符串，请不要使用 Date.prototype.toLocaleString() 方法，可以通过分别使用 getFullYear、getMonth、getDate 和 getDay 分别获得各关键字符串并拼装</p>\n</blockquote>\n</li>\n<li><p>5、在 IE6 IE7 IE8 中，JavaScript 代码中语句块结束符号“}”之后的第一个分号“;”会被忽略。</p>\n<blockquote>\n<p>解决办法：按照规范书写正确的代码。</p>\n</blockquote>\n</li>\n<li><p>6、JSON 字符串或对象直接量的最后一个键值对后加 ‘,’ 在 IE6 IE7 IE8(Q) 浏览器中会导致脚本中断。</p>\n<blockquote>\n<p>解决办法：即便规范没有强调最后一个键值对的后边不能出现 ‘,’，也要确保最后一个键值对之后没有多余的 ‘,’，以兼容各浏览器。</p>\n</blockquote>\n</li>\n<li><p>7、当数组直接量以 ‘,’ 结尾时，IE 和非 IE 得到的数组对象的长度不一致。IE 会以 ECMAScript 规范第三版中规定的方式解析该数组。即该数组的长度将比其他浏览器多 1。</p>\n<blockquote>\n<p>解决办法：数组直接量的最后不要出现 ‘,’，以保证兼容各浏览器。</p>\n</blockquote>\n</li>\n<li><p>8、IE 中允许变量名中出现 ‘，’ 等中文标点符号，而其他浏览器则不允许。</p>\n<blockquote>\n<p>解决办法：避免在变量名（即标识符）中出现中文标点，以保证兼容各浏览器。</p>\n</blockquote>\n</li>\n<li><p>9、在一个元素的属性中绑定事件，实际上就创建了一个内联事件处理函数（如</p><h1 onclick=\"alert(this);\" ...=\"\">…</h1>）,内联事件处理函数有其特殊的作用域链，并且各浏览器的实现细节也有差异。<p></p>\n<blockquote>\n<p>解决办法：</p>\n<ul>\n<li>尽量不要使用内联事件处理函数，使用 DOM 标准的事件注册方式为该元素注册事件处理函数</li>\n<li>必须使用内联事件处理函数时，要保证该函数内试图访问的变量是位于全局作用域内的，而不会因该函数独特的作用域链而引用到非预期的对象。最简单的办法是使用前缀，如 ‘my_onsearch’。</li>\n</ul>\n</blockquote>\n</li>\n<li><p>10、Date 对象的 getYear 方法在各浏览器下的返回值存在差异。</p>\n<blockquote>\n<p>解决办法：要获得一个具体时间的年份，请不要使用 Date.prototype.getYear() 方法，使用 Date.prototype.getFullYear() 代替，以在各浏览器下获得相同的表现。另外，要给一个 Date 对象设置年份，也请不要使用 Date.prototype.setYear() 方法，使用 Date.prototype.setFullYear() 代替。</p>\n</blockquote>\n</li>\n<li><p>11、Chrome Opera 中使用 for-in 语句遍历对象的属性时，遍历出的属性顺序与对象定义时不同。</p>\n<blockquote>\n<p>解决办法：for-in 语句无法保证遍历顺序，应尽量避免编写依赖对象属性顺序的代码。如果想顺序遍历一组数据，请使用数组并使用 for 语句遍历。 如果想按照定义的次序遍历对象属性，请参考本文针对各浏览器编写特殊代码。</p>\n</blockquote>\n</li>\n<li><p>12、IE6 IE7 IE8(Q) 不支持 JSON 对象。</p>\n<blockquote>\n<p>解决办法：可以使用 window.eval() 或 new Function(){} 的方式解析 JSON 格式字符串</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\n  window.onload = function(){\n    var info = document.getElementById(&quot;info&quot;),\n      jsonStr = &apos;{&quot;name&quot;: &quot;w3help&quot;, &quot;url&quot;: &quot;www.w3help.org&quot;, &quot;tech&quot;: [&quot;js&quot;, &quot;HTML&quot;, &quot;CSS&quot;, 5, 4.01, 2.1],&apos;\n          + &apos;&quot;online&quot;: true, &quot;category&quot;: {&quot;RCA&quot;: &quot;Root Cause Artical&quot;, &quot;KB&quot;:&quot;Knowledge Base&quot;},&apos;\n          + &apos;&quot;version&quot;: 1}&apos;, p, w3help;\n\n    //使用两种简单的方式解析 JSON 格式字符串\n    json1 = eval(&quot;(&quot; + jsonStr + &quot;)&quot;),\n    json2 = (new Function(&quot;return &quot; + jsonStr))();\n\n    for(p in json1)\n      info.innerHTML += p + &quot; : &quot; + json1[p] + &quot;&lt;br/&gt;&quot;;\n    info.innerHTML += &quot;-----------------------&lt;br /&gt;&quot;;\n    for(p in json2)\n      info.innerHTML += p + &quot; : &quot; + json2[p] + &quot;&lt;br/&gt;&quot;;\n  }\n&lt;/script&gt;\n&lt;div id=&quot;info&quot; style=&quot;width:350px;&quot;&gt;&lt;/div&gt;\n</code></pre><blockquote>\n<ul>\n<li>13、ECMAScript 中并没有明确说明 comparefn 返回值是布尔型时应该如何处理，它仅仅描述 comparefn 调用的返回值应当是 -1、0、1 这三种情况之一。comparefn 的返回值规范实现约束是 “引擎开发者” 还是 “脚本使用者” 并没有明确表述.这导致不同引擎对于 comparefn 返回值为非 -1、0、1 范围时具体处理不一致，从而使排序结果非预期。<blockquote>\n<p>解决办法：调用 Array.prototype.sort 函数并需要依赖 comparefn 处理排序结果时，应遵循规将 comparefn 函数返回值约束在 -1、0、1 范围内。</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<hr>\n<h1 id=\"二、文本对象模型\"><a href=\"#二、文本对象模型\" class=\"headerlink\" title=\"二、文本对象模型\"></a>二、文本对象模型</h1><blockquote>\n<ul>\n<li>1、在 IE6 IE7 IE8(Q) 中，支持以 document.getElementById(elementName) 的方式获取 name 属性值为 elementName 的 A APPLET BUTTON FORM IFRAME IMG INPUT MAP META OBJECT EMBED SELECT TEXTAREA 元素。<blockquote>\n<p>解决办法：在使用 document.getElementById 方法获取页面元素时，应传入元素的 id 属性值，而不能使用元素的 name 属性值。同时需注意页面中的元素的 id 属性值不能与其他元素的 name 属性值有重复。</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>2、使用 document.getElementById 方法获取页面内的元素时，在 IE6 IE7 IE8(Q) 中的 id 是大小写不敏感的。</p>\n<blockquote>\n<p>解决办法：在使用 document.getElementById 获取页面元素时，应保证作为参数的 id 与目标元素的实际 id 值完全一致。</p>\n</blockquote>\n</li>\n<li><p>3、IE 在创建 DOM 树时，会忽略某些空白字符，因此会比其他浏览器少创建一些文本节点。反过来说，同样的一篇文档，其他浏览器将比 IE 多创建一些文本节点。</p>\n<blockquote>\n<p>解决办法： </p>\n<ul>\n<li>没有必要时尽量去掉各标签之间的空白字符。</li>\n<li>在获取节点时做类型判断。</li>\n</ul>\n</blockquote>\n</li>\n<li><p>4、各浏览器中的 NodeList 接口存的实现有差异。</p>\n<blockquote>\n<p>解决办法：要从 NodeList 中获取元素，请使用 NodeList[index]、NodeList[name] 或 NodeList.item(index)，以保证兼容各浏览器。</p>\n</blockquote>\n</li>\n<li><p>5、在非 IE 浏览器中可能导致脚本异常，停止解析。</p>\n<blockquote>\n<p>解决办法：使用方式 1 达到简写一些 DOM 和 BOM 对象原生方法的目的。</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<pre><code>//方式1\nvar println1 = function(str){document.writeln(str);};\n</code></pre><blockquote>\n<ul>\n<li><p>6、IE6 IE7 IE8(Q) 混淆了 DOM 对象的属性（property）及 HTML 标签属性（attribute）这两个概念。其对于 getAttribute 及 setAttribute 方法的实现与 HTML DOM 对象的属性的 getter 与 setter 操作等价，这个错误的实现方式导致了一系列的兼容性问题。而在 IE8(S) 中，导致的大多数兼容性问题已不存在，但是仍然可以通过 “Element.PropertyName” 访问到这个 HTML 元素的自定义属性。</p>\n<blockquote>\n<p>解决办法：</p>\n<ul>\n<li>避免使用 “Element.setAttribute(“style”, “XXX”)” 在所有浏览器中设置元素的 style 属性，可以改用符合规范的 “Element.style.cssText = “XXX””；</li>\n<li>避免使用 “Element.setAttribute(“class”, “XXX”)” 在所有浏览器中设置元素的 class 属性，可以改用符合规范的 “Element.className = “XXX””；</li>\n<li>避免使用诸如 “Element.setAttribute(“onclick”, “alert(‘ok’)”)” 为元素绑定事件，可以使用符合规范的 Element.onclick = function () { [code] } 或 IE 的 attachEvent 方法等；<br>避免使用诸如 “Element.getAttibute(“innerHTML”)” 的方式获取 innerHTML 属性值；</li>\n<li>针对表单元素，使用 Element.value 获取控件的 “当前值”，而不要用 getAttribute(“value”) 获取；</li>\n<li>针对自定义的 HTML 属性，一律使用 getAttribute 方法获取属性值。</li>\n</ul>\n</blockquote>\n</li>\n<li><p>7、各浏览器对 DOMImplementation 接口的支持程度不同。</p>\n<blockquote>\n<p>解决办法：避免使用各浏览器支持程度不同的 DOMImplementation 的接口</p>\n</blockquote>\n</li>\n<li><p>8、DocumnetLS 是 DOM3 中一个过时的接口。</p>\n<blockquote>\n<p>解决办法：由于 W3C 推荐的标准中，已经放弃了 DocumentLS 接口，为更好的兼容各浏览器，建议采用 XMLHttpRequest 方式载入xml文件，示例代码如下：</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<pre><code>var xhr = window.XMLHttpRequest ?\n                  new window.XMLHttpRequest():\n                  new window.ActiveXObject(&quot;Microsoft.XMLHTTP&quot;)\nxhr.onreadystatechange = function(){\n    if(xhr.readyState == 4){\n        var xmlDoc = xhr.responseXML\n        // do something what you want ...\n    }\n};\nxhr.open(&apos;GET&apos;, &apos;test.xml&apos;, true);\nxhr.send();\n</code></pre><blockquote>\n<ul>\n<li><p>9、Firefox Opera 不支持 “document.styleSheets” 通过 STYLE 元素 id 获取 CSSStyleSheet 对象，仅支持整数作为下标获取。</p>\n<blockquote>\n<p>解决办法：避免使用 “document.styleSheets” 通过 STYLE 元素 id 获取 CSSStyleSheet 对象，使用 W3C 规范中的整数下标方式获取。</p>\n</blockquote>\n</li>\n<li><p>10、在 IE6 IE7 IE8 中，createElement 方法不仅可以通过合法的标签名创建节点对象，还可以通过传入一段合法的 HTML 代码字符串作为参数创建节点对象。</p>\n<blockquote>\n<p>解决办法：对于一般的非替换元素，在各浏览器中均使用 W3C 规范中的标准的为 createElement 方法传入标签名的做法。<br>对于一些 IE 处理有问题的替换元素，则注意判断浏览器，针对 IE 使用其特有的通过为 createElement 传入一段合法的 HTML 代码字符串作为参数的方法，非 IE 浏览器仍然使用 W3C 规范的标准方法。</p>\n</blockquote>\n</li>\n<li><p>11、各浏览器对元素绑定、解绑事件监听器的方法，事件对象的获取，以及 Event 对象的实现上存在差异。</p>\n<blockquote>\n<p>解决办法：</p>\n<ul>\n<li>使用特性判断创建无兼容性问题的事件监听器绑定和解绑函数</li>\n<li>使用特性判断获得有效的事件对象</li>\n<li>使用特性判断使用与标准对应的非标准方法及属性</li>\n</ul>\n</blockquote>\n</li>\n<li><p>12、使用 document.getElementsByName 方法获取页面内的元素时，在 IE6 IE7 IE8 中的 name 是大小写不敏感的。</p>\n<blockquote>\n<p>解决办法：在使用 document.getElementsByName 方法获取页面元素时，应保证作为参数的 name 与目标元素的实际 name 值完全一致。</p>\n</blockquote>\n</li>\n<li><p>13、各浏览器 document、document.body、document.documentElement 对象的 onscroll 事件的支持存在差异。</p>\n<blockquote>\n<p>解决办法：在给整个浏览器窗口绑定滚动事件 (scroll) 的时候，绑定到 window 对象上。</p>\n</blockquote>\n</li>\n<li><p>14、IE 标准模式下 BODY 元素的高度发生变化时就会触发 window.onresize 事件。</p>\n<blockquote>\n<p>解决办法：</p>\n<ul>\n<li>不期望触发 window.onresize 事件时：</li>\n<li>期望触发 window.onresize 事件时：</li>\n</ul>\n</blockquote>\n</li>\n<li><p>16、使用这两个方法将在 Firefox 浏览器内报错。</p>\n<blockquote>\n<p>解决办法：在 Firefox 中，可通过扩展 HTMLElement 的原型 (prototype) 来实现这两个方法</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>17、Firefox 不支持 DOM 对象的 outerHTML innerText outerText 属性。</p>\n<blockquote>\n<p>解决办法：在 Firefox 中，可通过扩展 HTMLElement 的原型 (prototype) 来实现相关属性。</p>\n</blockquote>\n</li>\n<li><p>18、在 IE6 IE7 IE8(Q) 中，一个 ‘position’ 特性值为 ‘static’ 的元素的 offsetParent 可能会是其最近的、触发了 hasLayout 的父元素。<br>同时其 offsetTop、offsetLeft 的返回值参照元素也是距离其最近的触发了 hasLayout 的祖先级元素。</p>\n<blockquote>\n<p>解决办法：可考虑对于为在 IE 中触发了 hasLayout 特性的元素设置 ‘position’ 特性值为非 ‘static’ 值，如 ‘relative’，或避免使用元素的 offsetTop、offsetLeft、offsetParent 属性。</p>\n</blockquote>\n</li>\n<li><p>19、插入空白页面 IFRAME 元素时 Chrome Safari Opera 浏览器中会触发 load 事件。</p>\n<blockquote>\n<p>解决办法：为 IFRAME 标签的 src 属性指定具体 URL 后再将节点插入 DOM 树中 。</p>\n</blockquote>\n</li>\n<li><p>20、IE 和 Firefox 提供了对 window.onerror 事件的支持，当页面内的 JavaScript 脚本出现错误时，window.onerror 被触发。</p>\n<blockquote>\n<p>解决办法：放弃使用 window.onerror，通过合理使用 try-catch 来达到近似的效果。</p>\n</blockquote>\n</li>\n<li><p>21、各浏览器中，原生可以触发 onfocus 事件以及通过其 focus() 方法获得焦点的元素不相同，而在元素设置了 tabindex 属性后焦点获取情况也不相同。<br>在 IE 中，DIV 和 SPAN 元素若在当前的 IE 中触发了 hasLayout 则也可以触发 onfocus 事件以及通过其 focus() 方法获得焦点。</p>\n<blockquote>\n<p>解决办法：对于一般常见的可视元素，若需要元素可触发 onfocus 事件以及通过其 focus() 方法获得焦点，则应为其设置 tabindex 属性。</p>\n</blockquote>\n</li>\n<li><p>22、页面加载完成后会触发 onload 事件，通常下会使用 window.onload 、 document.body.onload、 HTMLIFrame.onload 方法来处理他；但是各浏览器对页面 onload 事件处理方式并不一致，这些方法可能会导致页面加载完成后无法触事件处理函数。</p>\n<blockquote>\n<p>解决办法：</p>\n<ul>\n<li>统一为 window 对象的 onload 事件绑定函数，避免在 Firefox 中产生 document.body.onload 事件理解歧义。</li>\n<li>统一使用 DOM 规范的事件监听方法（或 IE 专有事件绑定方法）为 IFRAME 标记绑定 onload 事件处理函数。</li>\n</ul>\n</blockquote>\n</li>\n<li><p>23、各浏览器计算不包含在普通流中的内容元素的 scrollHeight 值时结果有差异。</p>\n<blockquote>\n<p>解决办法：确保读取 scrollHeight 属性的元素均创建了新的 block formatting context，或者此容器与内部子容器处于同一文档流中，以此避免各浏览器中读数不同。</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>24、在 IE6 IE7 IE8(Q) 中，无法通过脚本检测到 DOM 接口原型，故无法获得其接口继承关系。<br>在 IE8(S) 中，只能检测到部分 DOM 接口原型，但这些原型不可枚举，故无法获得其接口继承关系。<br>在 Firefox 中，部分 DOM 接口原型不可枚举，接口继承关系与 DOM 规范中的描述不符。<br>在 Chrome Safari Opera 中，DOM 接口继承关系遵照了 DOM 规范中的描述。</p>\n<blockquote>\n<p>解决办法：由于各浏览器中 DOM 接口实现的不一致性，这里建议应尽量避免修改浏览器脚本引擎内 DOM 接口的原生方法。</p>\n</blockquote>\n</li>\n<li><p>25、IE6 IE7 IE8 Opera 支持除 INPUT 和 BUTTON 元素以外的其他元素的 “click” 方法，这使得各浏览器对除 INPUT 和 BUTTON 元素以外的其他元素的 “click” 的支持情况存在差异。</p>\n<blockquote>\n<p>解决办法：建议尽量避免对除 INPUT 和 BUTTON 元素以外的其他元素通过 “click” 方法模拟鼠标点击事件。</p>\n</blockquote>\n</li>\n<li><p>26、当 document 从 window 中移除，将触发 onunload 事件，各浏览器对 onunload 事件的支持与触发条件实现有差异。</p>\n<blockquote>\n<p>解决办法：各浏览器的支持以及事件触发条件差异较多，需谨慎使用。</p>\n</blockquote>\n</li>\n<li><p>27、在用户通过鼠标操作触发 click 事件时，基本的事件触发流程为：MouseDown 事件 –&gt; MouseUp 事件 –&gt; Click 事件。<br>如果用户点击的元素可以获得焦点，并且当前还没有获得焦点时，会在 MouseUp 事件前先触发 Focus 事件，再依次触发其后事件。<br>此时就会出现问题，如果被点击的元素无法通过点击操作获得焦点，则 Focus 事件不会被触发，他的事件函数也不会因点击操作而运行，这就有可能导致功作者设计的功能无法按预期效果执行。</p>\n<blockquote>\n<p>解决办法：</p>\n<ul>\n<li>只在 INPUT[type=text] INPUT[type=password] SELECT TEXTAREA 元素中，使用 Focus 事件替代 click 事件触发相关业务逻辑处理程序。</li>\n<li>其他标记中的 Focus 事件无法使用鼠标指针的 click 操作触发，仅能通过 TAB 键切到可触发 Focus 事件的元素中才会生效。</li>\n</ul>\n</blockquote>\n</li>\n<li><p>28、typeof 运算符存在兼容性问题</p>\n<blockquote>\n<p>解决办法：由于以上几点的各浏览器实现差异，我们建议用户在充分了解 typeof 运算符含义时再使用。<br>下面的代码封装了名为 realtypeof 的方法，用来消除已知的各浏览器之间原生 typeof 运算符差异，仅作参考：</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<pre><code>function realtypeof(source){\n  return (source === undefined)\n    ? &quot;undefined&quot;\n    : (&quot;object&quot; === typeof source)\n      ? (/function/i.test( source + &quot;&quot; ))\n        ? &quot;function&quot;\n        : &quot;object&quot;\n      : (source.constructor == RegExp || !(source.constructor instanceof Function))\n        ? &quot;object&quot;\n        : typeof source;\n}\n</code></pre><blockquote>\n<ul>\n<li><p>29、各浏览器下在向文档树中插入通过 cloneNode(true) 创建的节点时，其内的 SCRIPT 元素中的脚本在 Chrome 和 Safari 中会执行，在 IE Firefox Opera 中没有执行。</p>\n<blockquote>\n<p>解决办法：避免深度复制 “cloneNode(true)” 包含 SCRIPT 元素的节点。</p>\n</blockquote>\n</li>\n<li><p>30、各浏览器对标准的支持有差异，并且他们实现了非标准的添加和删除 OPTION 元素的方法，在使用这些方法时，可能造成兼容性问题。</p>\n<blockquote>\n<p>解决办法：</p>\n<ol>\n<li>在添加 OPTION 元素时</li>\n</ol>\n<ul>\n<li>如果需要向指定索引前插入 OPTION，可以使用 options.add(option, index)；</li>\n<li>如果需要向 SELECT 尾部添加 OPTION，可以使用 options.add(option)；</li>\n<li>如果需要向指定索引处添加（或更改） OPTION，可以使用 options[index] = option。</li>\n</ul>\n<ol>\n<li>在删除 OPTION 元素时</li>\n</ol>\n<ul>\n<li>如果想删除指定索引处的 OPTION 元素，可以使用 select.remove(index) 或 options[index] = null；</li>\n<li>如果想删除某个指定的 OPTION 元素，可以使用 select.remove(option)；</li>\n<li>如果想删除 SELECT 中所有 OPTION，可以使用 select.length = 0 或 options.length = 0。</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>31、各浏览器对 Range 接口的实现存在差异。IE6 IE7 IE8 实现了独有的类似 Range 的 TextRange 对象，该对象拥有一些与标准 Range 接口中类似的属性及方法， 并且在创建 TextRange 时也与标准存在差异；而 Firefox Chrome Safari Opera 除了实现标准的 Range 接口外，还在此基础上扩展了一些属性及方法。 在创建 Range 时，也可以使用各自实现的 Selection 对象的 getRangeAt() 方法。</p>\n<blockquote>\n<p>解决办法：通过浏览器特性检测针对 IE6 IE7 IE8 正确创建 TextRange，对其它浏览器创建 Range。虽然 IE6 IE7 IE8 没有实现 Range 接口，但 TextRange 对象中也提供了许多能够实现类似功能的属性和方法。</p>\n</blockquote>\n</li>\n<li><p>32、IE6 IE7 IE8 IE9(Q) 中 change、select、submit、reset 事件均不产生事件冒泡。</p>\n<blockquote>\n<p>解决办法：为了兼容低版本的 IE 浏览器，建议 change、select、submit、reset 事件均不要依赖事件冒泡机制委托给其祖先元素处理。</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<hr>\n","excerpt":"<p>内容如题</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a>","more":"</h2><h1 id=\"一、JavaScript-核心\"><a href=\"#一、JavaScript-核心\" class=\"headerlink\" title=\"一、JavaScript 核心\"></a>一、JavaScript 核心</h1><blockquote>\n<ul>\n<li><p>1、在 ECMAScript 中，变量名、对象的属性或方法名都是标识符，标识符可以包含英文字母、数字、美元符号 ‘$’ 和下划线 ‘_’，但不能以数字开头，不能是保留字。换句话说，’+’，’.’ 等符号是不能出现在标识符中的。关于标识符的更多信息，请参考 ECMAScript 规范 7.6 Identifier Names and Identifiers 的内容。</p>\n<blockquote>\n<p>解决办法：避免使用 IE 的这些“特性”，以保证兼容所有浏览器。</p>\n</blockquote>\n</li>\n<li><p>2、Firefox 的 TraceMonkey 引擎对函数声明的处理与 ECMAScript 规范的要求不符，TraceMonkey 将块中的函数声明作为“函数语句”来处理。而其他浏览器的引擎仍将这类块中的函数声明当作该块之外的函数声明来解析。</p>\n<blockquote>\n<p>解决办法：将条件语句中的函数声明替换为函数表达式，如：</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<pre><code>function foo(){\n  if(window===parent){\n    var bar=function(){alert(1);}\n  }\n  else{\n    var bar=function(){alert(2);}\n  }\n  bar();\n}\nfoo();\n</code></pre><blockquote>\n<ul>\n<li><p>3、改变 Date、Array 或 String 等对象的原型对象中的属性或方法的引用后，再用 for in 遍历一个 Date、Array 或 String 对象时，在 Safari Chrome 中可以遍历出这个修改过的属性或方法名。</p>\n<blockquote>\n<p>解决办法：对于数组，避免用 for…in 方式而采用索引即数字下标的形式枚举数组成员。对于 Date String 以及其他对象，没有必要使用 for…in 来枚举它们的成员，因此一般不会有兼容性问题。</p>\n</blockquote>\n</li>\n<li><p>4、Date 对象的 toLocaleString 方法在各浏览器下的返回值存在格式上的差异。</p>\n<blockquote>\n<p>解决办法：要获得相同格式的时间字符串，请不要使用 Date.prototype.toLocaleString() 方法，可以通过分别使用 getFullYear、getMonth、getDate 和 getDay 分别获得各关键字符串并拼装</p>\n</blockquote>\n</li>\n<li><p>5、在 IE6 IE7 IE8 中，JavaScript 代码中语句块结束符号“}”之后的第一个分号“;”会被忽略。</p>\n<blockquote>\n<p>解决办法：按照规范书写正确的代码。</p>\n</blockquote>\n</li>\n<li><p>6、JSON 字符串或对象直接量的最后一个键值对后加 ‘,’ 在 IE6 IE7 IE8(Q) 浏览器中会导致脚本中断。</p>\n<blockquote>\n<p>解决办法：即便规范没有强调最后一个键值对的后边不能出现 ‘,’，也要确保最后一个键值对之后没有多余的 ‘,’，以兼容各浏览器。</p>\n</blockquote>\n</li>\n<li><p>7、当数组直接量以 ‘,’ 结尾时，IE 和非 IE 得到的数组对象的长度不一致。IE 会以 ECMAScript 规范第三版中规定的方式解析该数组。即该数组的长度将比其他浏览器多 1。</p>\n<blockquote>\n<p>解决办法：数组直接量的最后不要出现 ‘,’，以保证兼容各浏览器。</p>\n</blockquote>\n</li>\n<li><p>8、IE 中允许变量名中出现 ‘，’ 等中文标点符号，而其他浏览器则不允许。</p>\n<blockquote>\n<p>解决办法：避免在变量名（即标识符）中出现中文标点，以保证兼容各浏览器。</p>\n</blockquote>\n</li>\n<li><p>9、在一个元素的属性中绑定事件，实际上就创建了一个内联事件处理函数（如<h1 onclick=\"alert(this);\"...>…</h1>）,内联事件处理函数有其特殊的作用域链，并且各浏览器的实现细节也有差异。</p>\n<blockquote>\n<p>解决办法：</p>\n<ul>\n<li>尽量不要使用内联事件处理函数，使用 DOM 标准的事件注册方式为该元素注册事件处理函数</li>\n<li>必须使用内联事件处理函数时，要保证该函数内试图访问的变量是位于全局作用域内的，而不会因该函数独特的作用域链而引用到非预期的对象。最简单的办法是使用前缀，如 ‘my_onsearch’。</li>\n</ul>\n</blockquote>\n</li>\n<li><p>10、Date 对象的 getYear 方法在各浏览器下的返回值存在差异。</p>\n<blockquote>\n<p>解决办法：要获得一个具体时间的年份，请不要使用 Date.prototype.getYear() 方法，使用 Date.prototype.getFullYear() 代替，以在各浏览器下获得相同的表现。另外，要给一个 Date 对象设置年份，也请不要使用 Date.prototype.setYear() 方法，使用 Date.prototype.setFullYear() 代替。</p>\n</blockquote>\n</li>\n<li><p>11、Chrome Opera 中使用 for-in 语句遍历对象的属性时，遍历出的属性顺序与对象定义时不同。</p>\n<blockquote>\n<p>解决办法：for-in 语句无法保证遍历顺序，应尽量避免编写依赖对象属性顺序的代码。如果想顺序遍历一组数据，请使用数组并使用 for 语句遍历。 如果想按照定义的次序遍历对象属性，请参考本文针对各浏览器编写特殊代码。</p>\n</blockquote>\n</li>\n<li><p>12、IE6 IE7 IE8(Q) 不支持 JSON 对象。</p>\n<blockquote>\n<p>解决办法：可以使用 window.eval() 或 new Function(){} 的方式解析 JSON 格式字符串</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\n  window.onload = function(){\n    var info = document.getElementById(&quot;info&quot;),\n      jsonStr = &apos;{&quot;name&quot;: &quot;w3help&quot;, &quot;url&quot;: &quot;www.w3help.org&quot;, &quot;tech&quot;: [&quot;js&quot;, &quot;HTML&quot;, &quot;CSS&quot;, 5, 4.01, 2.1],&apos;\n          + &apos;&quot;online&quot;: true, &quot;category&quot;: {&quot;RCA&quot;: &quot;Root Cause Artical&quot;, &quot;KB&quot;:&quot;Knowledge Base&quot;},&apos;\n          + &apos;&quot;version&quot;: 1}&apos;, p, w3help;\n\n    //使用两种简单的方式解析 JSON 格式字符串\n    json1 = eval(&quot;(&quot; + jsonStr + &quot;)&quot;),\n    json2 = (new Function(&quot;return &quot; + jsonStr))();\n\n    for(p in json1)\n      info.innerHTML += p + &quot; : &quot; + json1[p] + &quot;&lt;br/&gt;&quot;;\n    info.innerHTML += &quot;-----------------------&lt;br /&gt;&quot;;\n    for(p in json2)\n      info.innerHTML += p + &quot; : &quot; + json2[p] + &quot;&lt;br/&gt;&quot;;\n  }\n&lt;/script&gt;\n&lt;div id=&quot;info&quot; style=&quot;width:350px;&quot;&gt;&lt;/div&gt;\n</code></pre><blockquote>\n<ul>\n<li>13、ECMAScript 中并没有明确说明 comparefn 返回值是布尔型时应该如何处理，它仅仅描述 comparefn 调用的返回值应当是 -1、0、1 这三种情况之一。comparefn 的返回值规范实现约束是 “引擎开发者” 还是 “脚本使用者” 并没有明确表述.这导致不同引擎对于 comparefn 返回值为非 -1、0、1 范围时具体处理不一致，从而使排序结果非预期。<blockquote>\n<p>解决办法：调用 Array.prototype.sort 函数并需要依赖 comparefn 处理排序结果时，应遵循规将 comparefn 函数返回值约束在 -1、0、1 范围内。</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<hr>\n<h1 id=\"二、文本对象模型\"><a href=\"#二、文本对象模型\" class=\"headerlink\" title=\"二、文本对象模型\"></a>二、文本对象模型</h1><blockquote>\n<ul>\n<li>1、在 IE6 IE7 IE8(Q) 中，支持以 document.getElementById(elementName) 的方式获取 name 属性值为 elementName 的 A APPLET BUTTON FORM IFRAME IMG INPUT MAP META OBJECT EMBED SELECT TEXTAREA 元素。<blockquote>\n<p>解决办法：在使用 document.getElementById 方法获取页面元素时，应传入元素的 id 属性值，而不能使用元素的 name 属性值。同时需注意页面中的元素的 id 属性值不能与其他元素的 name 属性值有重复。</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>2、使用 document.getElementById 方法获取页面内的元素时，在 IE6 IE7 IE8(Q) 中的 id 是大小写不敏感的。</p>\n<blockquote>\n<p>解决办法：在使用 document.getElementById 获取页面元素时，应保证作为参数的 id 与目标元素的实际 id 值完全一致。</p>\n</blockquote>\n</li>\n<li><p>3、IE 在创建 DOM 树时，会忽略某些空白字符，因此会比其他浏览器少创建一些文本节点。反过来说，同样的一篇文档，其他浏览器将比 IE 多创建一些文本节点。</p>\n<blockquote>\n<p>解决办法： </p>\n<ul>\n<li>没有必要时尽量去掉各标签之间的空白字符。</li>\n<li>在获取节点时做类型判断。</li>\n</ul>\n</blockquote>\n</li>\n<li><p>4、各浏览器中的 NodeList 接口存的实现有差异。</p>\n<blockquote>\n<p>解决办法：要从 NodeList 中获取元素，请使用 NodeList[index]、NodeList[name] 或 NodeList.item(index)，以保证兼容各浏览器。</p>\n</blockquote>\n</li>\n<li><p>5、在非 IE 浏览器中可能导致脚本异常，停止解析。</p>\n<blockquote>\n<p>解决办法：使用方式 1 达到简写一些 DOM 和 BOM 对象原生方法的目的。</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<pre><code>//方式1\nvar println1 = function(str){document.writeln(str);};\n</code></pre><blockquote>\n<ul>\n<li><p>6、IE6 IE7 IE8(Q) 混淆了 DOM 对象的属性（property）及 HTML 标签属性（attribute）这两个概念。其对于 getAttribute 及 setAttribute 方法的实现与 HTML DOM 对象的属性的 getter 与 setter 操作等价，这个错误的实现方式导致了一系列的兼容性问题。而在 IE8(S) 中，导致的大多数兼容性问题已不存在，但是仍然可以通过 “Element.PropertyName” 访问到这个 HTML 元素的自定义属性。</p>\n<blockquote>\n<p>解决办法：</p>\n<ul>\n<li>避免使用 “Element.setAttribute(“style”, “XXX”)” 在所有浏览器中设置元素的 style 属性，可以改用符合规范的 “Element.style.cssText = “XXX””；</li>\n<li>避免使用 “Element.setAttribute(“class”, “XXX”)” 在所有浏览器中设置元素的 class 属性，可以改用符合规范的 “Element.className = “XXX””；</li>\n<li>避免使用诸如 “Element.setAttribute(“onclick”, “alert(‘ok’)”)” 为元素绑定事件，可以使用符合规范的 Element.onclick = function () { [code] } 或 IE 的 attachEvent 方法等；<br>避免使用诸如 “Element.getAttibute(“innerHTML”)” 的方式获取 innerHTML 属性值；</li>\n<li>针对表单元素，使用 Element.value 获取控件的 “当前值”，而不要用 getAttribute(“value”) 获取；</li>\n<li>针对自定义的 HTML 属性，一律使用 getAttribute 方法获取属性值。</li>\n</ul>\n</blockquote>\n</li>\n<li><p>7、各浏览器对 DOMImplementation 接口的支持程度不同。</p>\n<blockquote>\n<p>解决办法：避免使用各浏览器支持程度不同的 DOMImplementation 的接口</p>\n</blockquote>\n</li>\n<li><p>8、DocumnetLS 是 DOM3 中一个过时的接口。</p>\n<blockquote>\n<p>解决办法：由于 W3C 推荐的标准中，已经放弃了 DocumentLS 接口，为更好的兼容各浏览器，建议采用 XMLHttpRequest 方式载入xml文件，示例代码如下：</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<pre><code>var xhr = window.XMLHttpRequest ?\n                  new window.XMLHttpRequest():\n                  new window.ActiveXObject(&quot;Microsoft.XMLHTTP&quot;)\nxhr.onreadystatechange = function(){\n    if(xhr.readyState == 4){\n        var xmlDoc = xhr.responseXML\n        // do something what you want ...\n    }\n};\nxhr.open(&apos;GET&apos;, &apos;test.xml&apos;, true);\nxhr.send();\n</code></pre><blockquote>\n<ul>\n<li><p>9、Firefox Opera 不支持 “document.styleSheets” 通过 STYLE 元素 id 获取 CSSStyleSheet 对象，仅支持整数作为下标获取。</p>\n<blockquote>\n<p>解决办法：避免使用 “document.styleSheets” 通过 STYLE 元素 id 获取 CSSStyleSheet 对象，使用 W3C 规范中的整数下标方式获取。</p>\n</blockquote>\n</li>\n<li><p>10、在 IE6 IE7 IE8 中，createElement 方法不仅可以通过合法的标签名创建节点对象，还可以通过传入一段合法的 HTML 代码字符串作为参数创建节点对象。</p>\n<blockquote>\n<p>解决办法：对于一般的非替换元素，在各浏览器中均使用 W3C 规范中的标准的为 createElement 方法传入标签名的做法。<br>对于一些 IE 处理有问题的替换元素，则注意判断浏览器，针对 IE 使用其特有的通过为 createElement 传入一段合法的 HTML 代码字符串作为参数的方法，非 IE 浏览器仍然使用 W3C 规范的标准方法。</p>\n</blockquote>\n</li>\n<li><p>11、各浏览器对元素绑定、解绑事件监听器的方法，事件对象的获取，以及 Event 对象的实现上存在差异。</p>\n<blockquote>\n<p>解决办法：</p>\n<ul>\n<li>使用特性判断创建无兼容性问题的事件监听器绑定和解绑函数</li>\n<li>使用特性判断获得有效的事件对象</li>\n<li>使用特性判断使用与标准对应的非标准方法及属性</li>\n</ul>\n</blockquote>\n</li>\n<li><p>12、使用 document.getElementsByName 方法获取页面内的元素时，在 IE6 IE7 IE8 中的 name 是大小写不敏感的。</p>\n<blockquote>\n<p>解决办法：在使用 document.getElementsByName 方法获取页面元素时，应保证作为参数的 name 与目标元素的实际 name 值完全一致。</p>\n</blockquote>\n</li>\n<li><p>13、各浏览器 document、document.body、document.documentElement 对象的 onscroll 事件的支持存在差异。</p>\n<blockquote>\n<p>解决办法：在给整个浏览器窗口绑定滚动事件 (scroll) 的时候，绑定到 window 对象上。</p>\n</blockquote>\n</li>\n<li><p>14、IE 标准模式下 BODY 元素的高度发生变化时就会触发 window.onresize 事件。</p>\n<blockquote>\n<p>解决办法：</p>\n<ul>\n<li>不期望触发 window.onresize 事件时：</li>\n<li>期望触发 window.onresize 事件时：</li>\n</ul>\n</blockquote>\n</li>\n<li><p>16、使用这两个方法将在 Firefox 浏览器内报错。</p>\n<blockquote>\n<p>解决办法：在 Firefox 中，可通过扩展 HTMLElement 的原型 (prototype) 来实现这两个方法</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>17、Firefox 不支持 DOM 对象的 outerHTML innerText outerText 属性。</p>\n<blockquote>\n<p>解决办法：在 Firefox 中，可通过扩展 HTMLElement 的原型 (prototype) 来实现相关属性。</p>\n</blockquote>\n</li>\n<li><p>18、在 IE6 IE7 IE8(Q) 中，一个 ‘position’ 特性值为 ‘static’ 的元素的 offsetParent 可能会是其最近的、触发了 hasLayout 的父元素。<br>同时其 offsetTop、offsetLeft 的返回值参照元素也是距离其最近的触发了 hasLayout 的祖先级元素。</p>\n<blockquote>\n<p>解决办法：可考虑对于为在 IE 中触发了 hasLayout 特性的元素设置 ‘position’ 特性值为非 ‘static’ 值，如 ‘relative’，或避免使用元素的 offsetTop、offsetLeft、offsetParent 属性。</p>\n</blockquote>\n</li>\n<li><p>19、插入空白页面 IFRAME 元素时 Chrome Safari Opera 浏览器中会触发 load 事件。</p>\n<blockquote>\n<p>解决办法：为 IFRAME 标签的 src 属性指定具体 URL 后再将节点插入 DOM 树中 。</p>\n</blockquote>\n</li>\n<li><p>20、IE 和 Firefox 提供了对 window.onerror 事件的支持，当页面内的 JavaScript 脚本出现错误时，window.onerror 被触发。</p>\n<blockquote>\n<p>解决办法：放弃使用 window.onerror，通过合理使用 try-catch 来达到近似的效果。</p>\n</blockquote>\n</li>\n<li><p>21、各浏览器中，原生可以触发 onfocus 事件以及通过其 focus() 方法获得焦点的元素不相同，而在元素设置了 tabindex 属性后焦点获取情况也不相同。<br>在 IE 中，DIV 和 SPAN 元素若在当前的 IE 中触发了 hasLayout 则也可以触发 onfocus 事件以及通过其 focus() 方法获得焦点。</p>\n<blockquote>\n<p>解决办法：对于一般常见的可视元素，若需要元素可触发 onfocus 事件以及通过其 focus() 方法获得焦点，则应为其设置 tabindex 属性。</p>\n</blockquote>\n</li>\n<li><p>22、页面加载完成后会触发 onload 事件，通常下会使用 window.onload 、 document.body.onload、 HTMLIFrame.onload 方法来处理他；但是各浏览器对页面 onload 事件处理方式并不一致，这些方法可能会导致页面加载完成后无法触事件处理函数。</p>\n<blockquote>\n<p>解决办法：</p>\n<ul>\n<li>统一为 window 对象的 onload 事件绑定函数，避免在 Firefox 中产生 document.body.onload 事件理解歧义。</li>\n<li>统一使用 DOM 规范的事件监听方法（或 IE 专有事件绑定方法）为 IFRAME 标记绑定 onload 事件处理函数。</li>\n</ul>\n</blockquote>\n</li>\n<li><p>23、各浏览器计算不包含在普通流中的内容元素的 scrollHeight 值时结果有差异。</p>\n<blockquote>\n<p>解决办法：确保读取 scrollHeight 属性的元素均创建了新的 block formatting context，或者此容器与内部子容器处于同一文档流中，以此避免各浏览器中读数不同。</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>24、在 IE6 IE7 IE8(Q) 中，无法通过脚本检测到 DOM 接口原型，故无法获得其接口继承关系。<br>在 IE8(S) 中，只能检测到部分 DOM 接口原型，但这些原型不可枚举，故无法获得其接口继承关系。<br>在 Firefox 中，部分 DOM 接口原型不可枚举，接口继承关系与 DOM 规范中的描述不符。<br>在 Chrome Safari Opera 中，DOM 接口继承关系遵照了 DOM 规范中的描述。</p>\n<blockquote>\n<p>解决办法：由于各浏览器中 DOM 接口实现的不一致性，这里建议应尽量避免修改浏览器脚本引擎内 DOM 接口的原生方法。</p>\n</blockquote>\n</li>\n<li><p>25、IE6 IE7 IE8 Opera 支持除 INPUT 和 BUTTON 元素以外的其他元素的 “click” 方法，这使得各浏览器对除 INPUT 和 BUTTON 元素以外的其他元素的 “click” 的支持情况存在差异。</p>\n<blockquote>\n<p>解决办法：建议尽量避免对除 INPUT 和 BUTTON 元素以外的其他元素通过 “click” 方法模拟鼠标点击事件。</p>\n</blockquote>\n</li>\n<li><p>26、当 document 从 window 中移除，将触发 onunload 事件，各浏览器对 onunload 事件的支持与触发条件实现有差异。</p>\n<blockquote>\n<p>解决办法：各浏览器的支持以及事件触发条件差异较多，需谨慎使用。</p>\n</blockquote>\n</li>\n<li><p>27、在用户通过鼠标操作触发 click 事件时，基本的事件触发流程为：MouseDown 事件 –&gt; MouseUp 事件 –&gt; Click 事件。<br>如果用户点击的元素可以获得焦点，并且当前还没有获得焦点时，会在 MouseUp 事件前先触发 Focus 事件，再依次触发其后事件。<br>此时就会出现问题，如果被点击的元素无法通过点击操作获得焦点，则 Focus 事件不会被触发，他的事件函数也不会因点击操作而运行，这就有可能导致功作者设计的功能无法按预期效果执行。</p>\n<blockquote>\n<p>解决办法：</p>\n<ul>\n<li>只在 INPUT[type=text] INPUT[type=password] SELECT TEXTAREA 元素中，使用 Focus 事件替代 click 事件触发相关业务逻辑处理程序。</li>\n<li>其他标记中的 Focus 事件无法使用鼠标指针的 click 操作触发，仅能通过 TAB 键切到可触发 Focus 事件的元素中才会生效。</li>\n</ul>\n</blockquote>\n</li>\n<li><p>28、typeof 运算符存在兼容性问题</p>\n<blockquote>\n<p>解决办法：由于以上几点的各浏览器实现差异，我们建议用户在充分了解 typeof 运算符含义时再使用。<br>下面的代码封装了名为 realtypeof 的方法，用来消除已知的各浏览器之间原生 typeof 运算符差异，仅作参考：</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<pre><code>function realtypeof(source){\n  return (source === undefined)\n    ? &quot;undefined&quot;\n    : (&quot;object&quot; === typeof source)\n      ? (/function/i.test( source + &quot;&quot; ))\n        ? &quot;function&quot;\n        : &quot;object&quot;\n      : (source.constructor == RegExp || !(source.constructor instanceof Function))\n        ? &quot;object&quot;\n        : typeof source;\n}\n</code></pre><blockquote>\n<ul>\n<li><p>29、各浏览器下在向文档树中插入通过 cloneNode(true) 创建的节点时，其内的 SCRIPT 元素中的脚本在 Chrome 和 Safari 中会执行，在 IE Firefox Opera 中没有执行。</p>\n<blockquote>\n<p>解决办法：避免深度复制 “cloneNode(true)” 包含 SCRIPT 元素的节点。</p>\n</blockquote>\n</li>\n<li><p>30、各浏览器对标准的支持有差异，并且他们实现了非标准的添加和删除 OPTION 元素的方法，在使用这些方法时，可能造成兼容性问题。</p>\n<blockquote>\n<p>解决办法：</p>\n<ol>\n<li>在添加 OPTION 元素时</li>\n</ol>\n<ul>\n<li>如果需要向指定索引前插入 OPTION，可以使用 options.add(option, index)；</li>\n<li>如果需要向 SELECT 尾部添加 OPTION，可以使用 options.add(option)；</li>\n<li>如果需要向指定索引处添加（或更改） OPTION，可以使用 options[index] = option。</li>\n</ul>\n<ol>\n<li>在删除 OPTION 元素时</li>\n</ol>\n<ul>\n<li>如果想删除指定索引处的 OPTION 元素，可以使用 select.remove(index) 或 options[index] = null；</li>\n<li>如果想删除某个指定的 OPTION 元素，可以使用 select.remove(option)；</li>\n<li>如果想删除 SELECT 中所有 OPTION，可以使用 select.length = 0 或 options.length = 0。</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>31、各浏览器对 Range 接口的实现存在差异。IE6 IE7 IE8 实现了独有的类似 Range 的 TextRange 对象，该对象拥有一些与标准 Range 接口中类似的属性及方法， 并且在创建 TextRange 时也与标准存在差异；而 Firefox Chrome Safari Opera 除了实现标准的 Range 接口外，还在此基础上扩展了一些属性及方法。 在创建 Range 时，也可以使用各自实现的 Selection 对象的 getRangeAt() 方法。</p>\n<blockquote>\n<p>解决办法：通过浏览器特性检测针对 IE6 IE7 IE8 正确创建 TextRange，对其它浏览器创建 Range。虽然 IE6 IE7 IE8 没有实现 Range 接口，但 TextRange 对象中也提供了许多能够实现类似功能的属性和方法。</p>\n</blockquote>\n</li>\n<li><p>32、IE6 IE7 IE8 IE9(Q) 中 change、select、submit、reset 事件均不产生事件冒泡。</p>\n<blockquote>\n<p>解决办法：为了兼容低版本的 IE 浏览器，建议 change、select、submit、reset 事件均不要依赖事件冒泡机制委托给其祖先元素处理。</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<hr>"},{"title":"与 CSS 相关的兼容性问题","date":"2015-08-20T17:25:32.000Z","keywords":"CSS, CSS兼容性, 前端兼容性, 兼容性","_content":"不同浏览器的兼容问题一直是前端开发工程师最头疼的问题，本系列文章记录一些常见和不常见的兼容性问题，因为兼容性问题太多了，所以内容可能有些杂乱，涉及的方面也肯定非常广,这里大多数只叙述问题和解决办法，而不细说原理，想了解原理的可以自行在网上查找。下面开始正文，本系列先从CSS开始。\n<!--more-->\n\n---\n一：语法和基本数据类型\n===\n> - 1、@charset 一定要放在样式表的最前面，否则在 Chrome和Safari中，@charset后面的规则集(样式)将失效。\n> - 2、如果一个外部 CSS 文件的编码与引入该文件的 HTML 文件的编码不一致，并且没有显式的声明该 CSS 文件的编码，在某些情况下会造成 CSS 的解析错误。解决办法：统一编码。\n\n{% codeblock lang:css %}\n\th1 {\n\t  margin:0;\n\t  width:100px;\n\t  height:100px;\n\t  background:blue;\n\t  font:20px/100px \"黑体\";\n\t  text-decoration:underline;\n\t  color:red;\n\t}\n{% endcodeblock %}\n如果上述CSS文件编码为GB2312，而引入的页面编码为UTF-8，在IE6中会从“黑体”往后的所有都被忽略（包括“黑体”），在其他浏览器只会将“黑体”忽略。\n![CSS兼容性](http://7xkj1z.com1.z0.glb.clouddn.com/CSS兼容性1.png)\n解决办法之一就是在CSS文件头部添加@charset \"UTF-8\"。\n> - 3、url中出现空白，在大部分浏览器中无法正确读取地址。但是IE6和IE7可以识别(经测试IE6/7也只能识别TAB和回车，空格也识别不出)。解决办法：避免url中出现空白。\n\n{% codeblock lang:html %}\n\t<!DOCTYPE html>\n\t<html>\n\t<head>\n\t<style>\n\t\tdiv.text { font-size:40px; float:left; border:1px solid black; color:navy; }\n\t\t#text2 { background-image:url(go    ogle.\n\t\tgif); }\n\t</style>\n\t\t</head>\n\t\t<body style=\"font:12px/1.2 'Trebuchet MS';\">\n\t\t<div id=\"text1\" class=\"text\" style=\"background-image:url(goo  gle_s\n\t\tmall.gif);\">some text 1</div>\n\t\t<br /><br /><br /><br /><br />\n\t\t<div id=\"text2\" class=\"text\">some text 2</div>\n\t</body>\n\t</html>\n{% endcodeblock %}\n![CSS兼容性](http://7xkj1z.com1.z0.glb.clouddn.com/CSS兼容性2.png)\n> - 4、正确地使用 CSS 的空白字符，避免使用表意空格 (U+3000)（表意空格（Ideographic Space），也可以叫全角空格（Full-width Space），对应的 HTML 实体字符为“&#12288”。在相同的等宽中文字体下，全角空格的宽度与普通汉字的宽度相等）。这个不一一列举了，每个浏览器支持情况不同，避免使用就好。\n\n---\n二：选择器\n===\n> - 1、IE6/IE7(Q)/IE8(Q)中不支持子选择器(如 ul>li)、兄弟选择器(如 div+p)、属性选择器([att]、[att=val]、[att~=val]、[att|=val])、 ':first-child'伪元素，避免在上述情况使用。\n> - 2、a标签的四个常用的伪类：':link'、':visited'、':hover'、':active',使用的顺序一定要是：L-V-H-A 来排序，虽然这一问题在IE6/IE7(Q)/IE8(Q)没有影响，但是其它的浏览器还是会有各种问题。\n> - 3、IE6/IE7(Q)/IE8(Q)中不支持a元素以外的元素使用':hover'伪类。\n>>解决办法：使用 JavaScript 绑定 'onmouseover' 和 'onmouseout'（模仿 ':hover'）；使用 Whatever:hover 插件，该插件利用 IE 特有的 CSS 行为（behavior）及通过 JavaScript 来模拟 ':hover' 伪类的效果。\n> - 4、IE6/IE7/IE8(Q)中不支持a元素以外的元素使用':active'伪类。\n>>解决办法：使用 JavaScript 绑定 'onmousedown' 和 'onmouseup'（模仿 ':active'）；同样的你可以使用 Whatever:hover 插件。\n> - 5、IE6/IE7/IE8(Q)不支持':focus'伪类。\n>>解决办法：使用 JavaScript 绑定 onfocus onblur 事件模仿 ':focus'效果；\n或者使用 Whatever:hover。\n> - 6、IE6/IE7/IE8(Q)不支持 ':before' 和 ':after' 伪元素\t\n>>解决办法：使用 JavaScript 判断 IE6 IE7 IE8(Q) 并在其中通过脚本实现 ':before' 及 ':after' 伪元素的效果；使用 jQuery 的插件 Pseudo Plugin，该组件利用 IE 特有的 CSS 行为（behavior）及 CSS 表达式来模拟 ':before' 及 ':after' 伪元素的效果。\n\n---\n三、指定特性值，层叠和继承\n===\n> - 1、IE6/IE7/IE8/Opera 中不支持'inherit'这个继承属性。\n\nIE8(S)中，块级元素无法通过设置'display:inherit'、特性值，显式性继承绝大部分行内元素的默认'display'特性值，但却可以显示性继承 BUTTON 元素的默认 'display' 特性。在Opera 中，P 元素无法通过设置 'border:inherit' 特性值，显式性继承 BUTTON 元素的默认 'border' 特性。\n解决办法：\n使用标准模式渲染页面；\n在 IE6 IE7 退出舞台之前避免使用 'inherit' 值显式性的继承样式设定；\n在 IE8 内不使用 'inherit' 值显式性继承行内元素的默认 'display' 特性值；\n在 Opera 内，不对使用 'inherit' 值显式性继承 BUTTON 元素默认 'border' 特性值。\n> - 2、在 Chrome 和 Safari 中，默认样式下的 B、STRONG 元素的 'font-weight' 特性计算值可能会受到其继承来的 'font-weight' 特性影响，在 IE8(S) 中，除 B、STRONG 外，H1~H6、TH 元素的'font-weight'特性也会受影响。在其他浏览器中，则完全不受影响。\n>>解决办法：尽量为元素设置绝对明确的 'font-weight' 特性的值，避免使用 bolder、lighter 这类相对量以及浏览器的默认样式。\n> - 3、 IE6 IE7(Q) IE8(Q) 不完全支持 !important 规则。不支持位于同一个选择器内的 '!important' 规则。\n\n{% codeblock lang:html %}\n\t<style type=\"text/css\">\n\t    div{\n\t        width:100px;\n\t        height:30px;\n\t        background-color:gold !important;\n\t        background-color:silver;\n\t    }\n\t</style>\n\t<div></div>\n{% endcodeblock %}\n![CSS兼容性](http://7xkj1z.com1.z0.glb.clouddn.com/CSS兼容性3.png)\n{% codeblock lang:html %}\n\t<style>\n\t  .c1 { background:blue !important; }\n\t  .c2 { background:green; }\n\t</style>\n\t<div style=\"width:100px; height:100px;\" class=\"c1 c2\"></div>\n{% endcodeblock %}\n![CSS兼容性](http://7xkj1z.com1.z0.glb.clouddn.com/CSS兼容性4.png)\n\n解决办法：这是浏览器的 Bug 导致，无法通过常规方式解决。不过，一般 '!important' 规则常常用于 CSS hack 以区分 IE6 与其他浏览器，其作为 hack 存在的意义已大于其本身的含义。\n\n---\n四、盒模型\n===\n> - 1、IE6 IE7 IE8(Q) 负边距 (margin) 导致元素溢出 hasLayout 容器时显示异常。\n>> 解决办法：在确保元素的容器触发 hasLayout 的前提下，为该元素同时设置 'position:relative' 和 'zoom:1'。\n首先需要保证容器在IE中触发 hasLayout 属性，可以通过zoom:1实现。在 IE7(S) 中，当使设置了负值 'margin' 的元素的 hasLayout 属性为 'true' ，即触发该元素的hasLayout特性后，此Bug现象消失，例如为该元素设置宽度或高度，或者在完全不影响该元素盒模型的情况下使用zoom:1 来触发 hasLayout 从而消除此 Bug 。在 IE6 IE7(Q) IE8(Q) 中，仅仅触发 hasLayout 特性并不一定能消除此 Bug ，同时还需要为该元素设置 'position:relative'，即在完全不影响该元素盒模型的情况下使用 zoom:1 'position:relative' 。\n> - 2、Chrome Safari ，在 WebKit 内核的浏览器中，当元素满足三个条件时，宽度计算不符合规范：\n元素的兄弟元素是浮动元素；元素的 'width' 特性值为 'auto'，'overflow' 特性值不是 'visible'；元素设置了与浮动同方向的 'margin' 值(如：当 'float:left' 时，设置 'margin-left' 值，当 'float:right' 时，设置 'margin-right')。\n>>解决办法：\n>>- 为该创建了 BFC 的元素设置一个明确的宽度; \n>>- 如果 'margin' 值不小于浮动元素的 margin box 的宽时，去掉'overflow:hidden'。\n> - 3、Firefox 中 'display:table' 的元素的外边距不会与包含块的外边距折叠(也就是margin塌陷)。\n\n{% codeblock lang:html %}\n\t<div style=\"background:gold;\">Top line</div>\n\t<div style=\"background:gray; width:300px; margin:20px 0;\">\n\t    <table cellpadding=\"0\" cellspacing=\"0\" style=\"background:pink; width:200px; margin:10px 0;\">\n\t        <tr>\n\t            <td>TD</td>\n\t        </tr>\n\t    </table>\n\t</div>\n\t<div style=\"background:gold;\">Bottom line</div>\n{% endcodeblock %}\n![CSS兼容性](http://7xkj1z.com1.z0.glb.clouddn.com/CSS兼容性5.png)\n>> 解决办法：由于 IE6 IE7 IE8(Q) Firefox 元素的 'margin' 处理与 W3C 规范中的差异，若我们需要利用 \"margin collapse\" 达到某些布局效果时，在这几种浏览器中可能会由于没有发生 \"margin collapse\" 而出现 \"额外边距\" 的情况。所以应避免为表格设置上下边距，以及导致其 \"margin collapse\" 的发生，可以使用为表格的父元素使用 'padding' 代替表格元素的 'margin' 。\n\n> - 4、IE6 IE7 IE8(Q) 中浮动元素和定位元素某些情况下会影响普通流中毗邻 'margin' 的折叠。\n>> 解决办法：\n>> - 根据具体需求，调整 'margin' 的位置和大小；\n>> - 使用 CSS hack 设置 IE 中的 'margin' 大小，以避免 IE 跟其他浏览器的布局差异。\n> - 5、在 IE6 IE7 IE8(Q)下，容器触发 hasLayout 导致其左浮动子元素 'margin-bottom' 消失。\n\n{% codeblock lang:html %}\n\t<span>content_text</span>\n\t<div style=\"zoom:1; overflow:hidden; background:lightgrey;\">\n\t    <div style=\"float:left; width:50px; height:50px; margin:20px; background:dimgray;\"></div>\n\t</div>\n\t<span>content_text</span>\n{% endcodeblock %}\n![CSS兼容性](http://7xkj1z.com1.z0.glb.clouddn.com/CSS兼容性6.png)\n>> 解决办法：为容器显式地设置高度。若容器高度不定，则要避免在触发了 hasLayout 的容器内的浮动子元素上设置 'margin-bottom' 特性，可以通过为容器设置 'padding-bottom' 达到相似的效果。只要不同时触发父元素hasLayout、子元素左浮动、左浮动子元素拥有非零的 margin-bottom 值，这三个条件中任意一项，均可解决此问题。\n\n> - 6、IE6 IE7 IE8(Q) 中，若一个触发了 hasLayout 的元素其内第一个非空白节点 (即 children[0]) 为 TEXTAREA 元素 或者 type 属性值为 text、password、submit、reset、button、file 的 INPUT 元素，并且这个元素设定了 'margin-left'、'margin-right' 特性，则 'margin-left'、'margin-right' 特性指定的值会应用于其相应方向的 padding 上。\n>> 解决办法：在 INPUT、TEXTAREA 元素之前放一个触发了 hasLayout 的空 SPAN 元素。\n\n---\n五、渲染模型\n===\n> - 1、各浏览器对 'display' 特性值的支持程度不同。\n>> 解决办法：尽量仅使用所有浏览器都支持的 'display' 特性值：'inline'、'block'、'list-item'、'none'。在 IE6 IE7 IE8(Q) 中实现块元素的 'display:inline-block' 特性值支持，需要先将块元素设置为行内元素，并设置可以在 IE6 IE7 IE8(Q) 内触发 haslayout 特性的专有特性 'zoom:1'。行内元素实现 'display:inline-block' 特性值支持只需直接设置此特性值或同样使用 'zoom:1' 即可。\n\n> - 2、在IE早期版本中的元素触发了haslayout，但是没有触发BFC，会导致在IE和其它浏览器中的布局有差异。（如何触发haslayout和BFC在这里不细说）\n>> 解决办法：仅当一个元素即在 IE 早期版本中触发了 hasLayout，又在其他浏览器中创建了 block formatting context 时，才能避免上述问题的发生。即同时启用上述两者以保证各浏览器的兼容，或者相反，两者皆不启用。\n\n> - 3、BFC在各浏览器中的问题：\n1.当容器有足够的剩余空间容纳 BFC 的宽度时，所有浏览器都会将 BFC 放置在浮动元素所在行的剩余空间内。\n2.在 IE6 IE7 IE8 Chrome Opera 中，当 BFC 的宽度介于 \"容器剩余宽度\" 与 \"容器宽度\" 之间时，BFC 会显示在浮动元素的下一行；在 Safari 中，BFC 则仍然保持显示在浮动元素所在行，并且 BFC 溢出容器；在 Firefox 中，当容器本身也创建了 BFC 或者容器的 'padding-top'、'border-top-width' 这些特性不都为 0 时表现与 IE8(S)、Chrome 类似，否则表现与 Safari 类似。\n3.在 IE6 IE7 IE8 Opera 中，当 BFC 的宽度大于 \"容器宽度\" 时，BFC 会显示在浮动元素的下一行；在 Chrome Safari 中，BFC 则仍然保持显示在浮动元素所在行，并且 BFC 溢出容器；在 Firefox 中，当容器本身也创建了 BFC 或者容器的 'padding- top'、'border-top-width' 这些特性不都为 0 时表现与 IE8(S) 类似，否则表现与 Chrome 类似。\n>> 解决办法：合理地设置容器的宽度、浮动元素的宽度、BFC 的宽度的值，尽量保证 BFC 的宽度小于 \"容器的剩余空间宽度\" 。若需要 BFC 折行显示在新的一行上，可以通过 BFC 设置 'clear' 特性等手段使其换行。\n\n> - 4、在 IE6 IE7 IE8(Q) 中，一个零高度的浮动元素仍能阻挡与其向相同方向浮动的兄弟元素。\n>> 解决办法：如果希望一个浮动元素能阻挡与其向相同方向浮动的兄弟元素，请确保其高度不为零；否则，请隐藏该元素，以使页面布局在各浏览器中的表现一致。\n\n> - 5、IE6 IE7 IE8(Q) 下，若浮动元素之前存在兄弟行内非浮动元素，IE 会将浮动元素所在的“当前行”认为是其前边的兄弟行内元素所产生的匿名框的底边，导致该浮动元素折行。\n>> 解决办法：依具体情况可以使用三种方法：使用绝对定位模拟右浮动、使用 IE hack 专门在IE6 IE7 中设置负的上外边距、将右浮动的 SPAN 元素调整到所有非浮动 SPAN 元素之前。\n\n> - 6、在 IE6 IE7 IE8(Q) 下，为 'clear' 元素设置负的 'margin-top' 时， 'clear' 元素的顶部 'border-box' 出现在了其之前浮动元素的底部 'margin-box' 之上。\n>> 解决办法：尽量避免为 'clear' 特性不为 none 的元素（即清理元素）设置 'margin-top' 特性，尤其是负值。若需要为该元素设置正的 'margin-top' 特性，可以将 'clear' 元素当做容器，在其内部加入设置了 'margin-top' 的元素。若需要为该元素设置负的 'margin-top' ，可以为浮动元素设置负的 'margin-bottom' 以缩小其 'margin-box' ，提高了其底部 'margin-box' 的位置，从而使 'clear' 元素可以产生向上移动的效果。\n\n> - 7、IE6 IE7 IE8(Q) 中，使用 'clear' 特性清除浮动后，浮动元素的容器若没有触发 hasLayout，则其背景将会丢失。\n>> 解决办法：使丢失背景的容器触发 IE 浏览器特有的 hasLayout，如 'zoom:1'，或者设置宽度和高度。\n\n> - 8、在IE6 IE7 IE8(Q)中，如果 clear 特性被设置在一个浮动的元素上，该浮动元素会与其前边的浮动元素放置在同一行。位于其后的浮动元素的外顶边高于该元素的外顶边。\n>> 解决办法：不要将 'clear' 特性应用在浮动元素上，以免出现上述不兼容的问题。\n\n> - 9、IE6 IE7 IE8(Q) 中一些拥有默认上下外边距的块级元素（浏览器设置的）在浮动，或触碰到触发了 hasLayout 特性的容器后，上下外边距会消失。\n>> 解决办法：用自定义的 'margin' 取代浏览器的默认外边距样式。\n\n> - 10、IE 中触发了 hasLayout 的容器同时使用 'clear' 特性清除浮动在某些情况下导致 'padding-top' 渲染异常。\n>> 解决办法：\n>> - 不触发容器的 hasLayout 特性；\n>> - 若容器触发了hasLayout 特性，尽量不为其设置 'padding-top' 特性；\n>> - 若容器触发了hasLayout 特性，且必须为容器设置 'padding-top' 特性，可以考虑使用 ':after' 的清除方式。\n\n> - 11、Firefox 浏览器对 'display:table' 中绝对定位元素包含块的判定有错误，可能会导致绝对定位元素位置跟其他浏览器中有差异。\n>> 解决办法：这是 Firefox 的一个 bug，绝对定位元素无法根据 'display' 特性是 'table' 且是绝对定位的祖先元素定位。为达到相同的效果可以改变元素的 containing block 或者改变元素的定位方式。为达到相同的效果，可以采用如下方式替代：\n改变元素的 containing block：让绝对定位元素相对于 TABLE 元素的单元格定位，即，在 TD 上设置 'position:absolute' ；或者改变元素的定位方式：把绝对定位元素的 'absolute' 改为 'relative' ，用相对定位。\n\n> - 12、 IE6 IE7 IE8(Q) Firefox Opera 中若绝对定位元素没有设置其 'top' 、 'right' 、 'bottom' 、 'left' 特性，则这四个特性的值为默认的 'auto' ，由于各浏览器对规范理解的差异，会导致页面布局差异。\n>> 解决办法：首先对于绝对定位元素，应尽可能避免使其 'top'、'right'、'bottom'、'left' 特性的值均为 'auto'。若必须这么做，则尽可能的保证绝对定位元素之前的兄弟元素为非浮动的块级元素。\n\n> - 13、IE6 IE7(Q) IE8(Q) 不支持固定定位（position:fixed）。\n>> 解决办法：在 IE6 IE7(Q) IE8(Q) 中为固定定位元素设置 'position:absolute'，再通过 JavaScript 脚本或者 CSS Expression 动态设置其偏移量。参考代码如下：\n\n\t<body style=\"font:12px Arial; _background-attachment:fixed; _background-image:url(about:blank);\">\n\t<div style=\"width:10000px; height:10000px;\"></div>\n\t<div id=\"d\" style=\"position:fixed; top:0; left:0; _position:absolute; _top:expression(offsetParent.scrollTop); _left:expression(offsetParent.scrollLeft); background:#ddd; width:100px; height:100px;\"></div>\n\t</body>\n\n> - 14、在 IE6 IE7 IE8(Q) 下，对于宽度超过容器的浮动元素，浏览器违背了浮动基本规则，导致其在浮动方向上溢出包含块。\n>> 解决办法：当文字方向为 'ltr' 时应避免使右浮动元素的宽度超出其包含块的宽度。同样地，当文字方向为 'rtl' 时应避免使左浮动元素的宽度超出其包含块的宽度。\n\n> - 15、当定位元素的 'z-index' 未设置时（默认为 auto），在 IE6 IE7 IE8(Q) 下将会创建一个新的局部层叠上下文。而在其它浏览器下，则严格按照规范，不产生新的局部层叠上下文。\n>> 解决办法：理解层叠上下文、层叠级别与 'z-index' 之间的关系。在可能出现定位元素相互覆盖的情况时，明确指定定位元素的 'z-index' 特性，避免此问题的出现。\n\n> - 16、IE6 IE7 IE8(Q) 中溢出容器的浮动元素导致容器兄弟元素文本定位错误。\n>> 解决办法：及时地为容器清除浮动，并且确保浮动元素没有溢出容器。\n\n\n> - 17、在 IE7(S) 中一个元素溢出的部分会被触发了 hasLayout 特性的元素遮盖。\n>> 解决办法：合理设置元素的 'width'、'height' 和 'overflow' 特性，避免内容溢出容器。\n\n> - 18、在 IE6 IE7(Q) IE8(Q) 下，若包含块没有触发 hasLayout 特性，则其内参照其定位的绝对定位元素的偏移位置计算会出现问题。\n>> 解决办法：使包含块触发 hasLayout 特性。如 'zoom:1' 或者设置明确的宽度、高度。\n\n> - 19、IE6 IE7 IE8(Q) Firefox 不支持 'display:run-in'。\n>> 解决办法：'display:run-in' 特性目前用的地方不多，应用此特性的元素的最终状态 (inline-level 或 block-level) 要根据其上下文来判断，目前建议直接使用 'display:inline' 或 'display:block' 来固定元素的状态。\n\n> - 20、包含块是行内元素，行内元素的绝对定位子元素位置，在各浏览器有差异。\n>> 解决办法：各浏览器对于行内元素的包含块范围计算有误，因此建议，应尽可能避免将行内元素边界作为计算包含块边界的情况出现。\n\n\n> - 21、在 IE6 IE7 IE8(Q) 中，TD/TH 及 TD 元素对设定 'position:relative' 特性及偏移有效，其他均无效；\n在 IE8(S) 中，TD/TH 及 CAPTION 元素及它们相对于 CSS 中 display 特性值对设定 'position:relative' 特性及偏移有效，其他均无效；\n在 Firefox 中，除 TABLE 之外的所有表格类元素以及它们相对于 CSS 中 display 特性值对设定 'position:relative' 特性及偏移均无效\n在 Chrome Safari 中，CAPTION 元素及它相对于 CSS 中 display 特性值 'caption' 对设定 'position:relative' 特性及偏移有效，其他均无效；\n在 Opera 中，COL、COLGROUP 元素以及它们相对于 CSS 中 display 特性值对设定 'position:relative' 特性及偏移无效，其他均有效。\n>> 解决办法：由于除 TABLE 之外的表格类元素以及它们相对于 CSS 中 display 特性值设定了相对定位后的效果 CSS2.1 规范中没有明确定义，而各浏览器的实现又存在很大差异。所以应避免为这些元素设定 'position:relative'。若需要实现如冻结表格行或列的效果，可以考虑使用绝对定位其他 TABLE 元素的方式模拟。\n\n> - 22、在 Safari Chrome 等使用 webkit 渲染引擎的浏览器中，'float:center' 是合法值，他等同于 'float:none' 设置，而其他浏览器则认为 ‘float’ 特性中 'center' 是个非法值，遵循规范应忽略此处的 'float' 特性设置。\n>> 解决办法：避免使用非法的 'float' 特性值。\n\n---\n六、渲染模型的细节\n===\n\n> - 1、如果一个页面使浏览器工作在混杂模式下，那么当给一个设置了 'padding' 或 'border-width' 的非替换元素设置 'width' 或 'height' 以控制其尺寸时，这个元素在 IE 和其他览器中的实际尺寸将是不同的。\n>> 解决办法：- 使用能触发标准模式 (S) 的 DTD\n- 使用 CSS 3 的新特性：box-sizing\n\n\n> - 2、在 IE6 IE7(Q) IE8(Q) 中，如果一个非替换元素的 'overflow' 为 'visible'，当该元素无法完全容纳其非绝对定位的内容时，该元素的尺寸将被其内容撑大。\n在上述情况发生时，为这个非替换元素设置的 'width' 和 'height' 与 CSS 2.1 中的 'min-width' 和 'min-height' 的作用类似：设定值不是最终的实际值，实际值可能更大。\n>> 解决办法：使用能触发标准模式 (S) 的 DTD，以将受此问题影响的浏览器的范围缩小到仅 IE6(S)。\n如果不能保证一个希望尺寸固定的非替换元素总是能容纳其内容，请将该元素的 'overflow' 设置为非 'visible' 的值。\n\n\n> - 3、在 IE6 IE7 IE8 中，'width' 或 'height' 任意一个或两个都设置为 '0' 的 IFRAME 元素是不可见的，而在其它浏览器中这样设置后的 IFRAME 元素仍可见。\n>> 解决办法：根据实际情况选择使用 'visibility:hidden' 或者 'display:none' 隐藏 IFRAME 。\n\n\n> - 4、在 IE6 IE7 IE8(Q) 中，如果一个浮动元素的宽度是 shrink-to-fit，该元素的最终宽度可能比预期的小，并被尽可能的向上布局。\n>> 解决办法：这个问题的影响较大，避免该问题的最直接的方式是给浮动非替换元素指定一个宽度，而不使用其默认值 'auto'，从而避免其宽度为 shrink-to-fit，以使页面布局在各浏览器中的表现一致。\n\n> - 5、在 Chrome Safari 中，若浮动元素之前存在一个非 inline 级元素（包括 block、table 等），且它们的包含块 'width' 特性计算值为 auto，则包含块的 shrink-to-fit 宽度计算会出现错误。\n>> 解决办法：在容器为绝对定位、浮动或行内块元素且没有明确设定宽度时，若浮动元素之前出现非 inline 级元素，则要小心这个元素对容器 shrink-to-fit 宽度的影响。可以为容器明确的设定一个宽度。\n\n> - 6、在 IE6 IE7 IE8(Q) 中，一个右浮动元素将尽可能的向右布局，并撑大其所有宽度为 'auto' 的祖先级元素的宽度，直到遇到一个明确设定了宽度的祖先级元素为止。\n注：这种现象仅在该元素有宽度为 shrink-to-fit 的的祖先级元素时才可以看到。\n>> 解决办法：如果有一个右浮动元素，应注意避免其祖先级元素的宽度为 shrink-to-fit，即给它们设定一个明确的宽度。以使页面布局在各浏览器中的表现一致。\n\n> - 7、IE6 IE7 IE8 Opera 中对 shrink-to-fit 计算时会考虑浮动元素的宽度，这其中包含非替换浮动元素、非替换绝对定位元素、为替换行内块元素。\n>> 解决办法：尽量为非替换浮动元素、非替换绝对定位元素、非替换行内块元素显式地设置一个宽度，防止浏览器在 'width:auto' 时对于 shrink-to-fit 的宽度计算方式不同造成布局上的差异。\n\n> - 8、IE6 及 IE7/8 的混杂模式下，非替换绝度定位元素当指定了 'left' 及 'right'，而 'width' 为默认值 \"auto\" 。此时浏览器无法正确地计算出 'width' 的值，对于高度的计算也是如此。\n>> 解决办法：若能为非替换绝对定位元素设定固定的宽度及高度，则尽量不使用此方式自动计算绝对定位元素的 'width' 及 'height'；若无法避免使用此方式，则可以通过判断浏览器，仅在 IE6 中使用 CSS Expression 控制绝对定位元素的宽度及高度。\n\n> - 9、IE6 IE7 IE8(Q) 在超过一个行内元素排列生成行框时，识别行框的顶边和底边位置时会参照文本实际高度的顶边和底边尺寸，而不是行框内最高行内框的顶边和最底行内框的底边位置。\n>> 解决办法：为了取得正常布局，建议 'line-height' 计算值设置永远大于 'font-size' 计算值设置。\n\n> - 10、IE6 IE7(Q) IE8(Q)不支持 'min-width' 和 'max-width' 特性。\n>> 解决办法：使用 Javascript 实现 'min-width' 和 'max-width' 特性功能。\n\n> - 11、IE6 IE7 IE8(Q) 中行内非替换元素中的非文本文字可能会撑高其高度。\n>> 解决办法：针对不同的需求，可以采取不同的解决方案，例如，将外层的行内元素改为一个块级元素、给外层行内元素设置 'display:inline-block'、给外层行内元素设置合适的 'font-size' 值等。\n\n> - 12、不同浏览器内 'line-height' 样式设置会影响 INPUT BUTTON 元素的显示高度。\n>> 解决办法：尽量避免使用 'line-height' 为 INPUT[type=text]、INPUT[type=password]、INPUT[type=button]、INPUT[type=file]、input[type=submit] 和 BUTTON 标记设置 ‘line-height’，而应改用规范内说明的 'height' 属性。\n\n> - 13、IE6 IE7 IE8(Q) 中触发 hasLayout 的空块级非替换元素的高度不为 0。\n>> 解决办法：如果想让一个触发了 hasLayout 的块级非替换元素的高度为 0，可以给这个空的块级非替换元素增加一个空的注释块：\n\n\t<div style=\"zoom:1\"><!-- --></div>\n另外，不让元素在 IE 中触发 hasLayout 也可以避免此 BUG 。\n\n> - 14、IE 的混杂模式中行内非替换元素的宽高可设置。\n>> 解决办法：在页面上添加<!DOCTYPE HTML>，使页面工作在标准模式下。\n\n> - 15、IE6 IE7(Q) IE8(Q) 不支持 'min-height' 和 'max-height' 特性。\n>> 解决办法：使用 Javascript 实现 'min-height' 和 'max-height' 特性功能。\n\n> - 16、不同浏览器对单行文本输入框和显示为按钮的控件基线位置理解不同。\n>> 解决办法：避免使用 'baseline' 对齐方式，为元素指定 'vertical-align' 值非 'baseline'，推荐使用 'vertical-align:bottom' 或 'vertical-align:top'。\n\n> - 17、Webkit 浏览器下行框高度计算还依赖于 'font-size' 属性值，在 'line-height' 属性值明显小于 'font-size' 属性值设置时，将导致实际计算出的行框高度大于其他浏览器。\n>> 解决办法：为了取得正常布局，建议 'line-height' 计算值永远大于 'font-size' 计算值设置。\n\n> - 18、容器高度被明确设定，容器内容高度仅由行高累加决定的情况下，Safari Chrome 中容器元素的 'overflow' 值为非默认值时，其最后一个内联子元素的半差异高度可能会被忽略。\n>> 解决办法：为了准确得到容器高度，建议避免使用行高为行内元素指定高度，而应改用块标记，并且明确的指定其 'height' 值。\n\n> - 19、对于行内元素绝对定位后静态位置中的 'top' 特性的计算值，IE6 IE7 IE8(Q) 会将其计算为静态位置下 content area 距包含块顶边的距离（即半差异的高度），其他浏览器则计算为 0。\n>> 解决办法：在使行内元素绝对定位的时候，要注意其行高对静态位置带来的影响，明确设置定位的元素偏移位置。\n\n> - 20、在非标准文档模式中（包括混杂模式和近乎标准模式），当唯一的非表单控件类行内替换元素存在于其包容块中时，其父框的行高并不一定会计算文本基线高度。\n>> 解决办法：如果在非标准模式中，需要父容器在仅有行内替换元素的情况下计算出包含文本基线高度的行高值，则必须加入其他行内文本元素。相反的，如果在标准模式中，需要行内替换元素与其父容器底部无间隙，请修改 'vertical-align' 值为非 'baseline' 。\n\n> - 21、若容器中包含 MARQUEE 元素，且容器遵循 shrink-to-fit 宽度算法，则容器及 MARQUEE 元素的宽度在不同浏览器中存在差异。\n>> 解决办法：给 MARQUEE 元素及替换元素定义具体的宽度，保证各浏览器兼容。\n\n> - 22、对于宽度为 0% 的 IMG 元素的包含块的 shrink-to-fit 算法，Firefox Chrome Safari 与 IE6 IE7 IE8 Opera 存在差异。\n>> 解决办法：尽量避免设置 IMG 元素的宽度为 0%，可以用 0px 替代。\n\n> - 23、IE6 IE7(Q) IE8(Q) 中，如果父需要使用 shrink-to-fit 算法，并且其子元素触发了 hasLayout 特性以及 'width' 特性值为默认的 'auto'，那么会导致父元素 shrink-to-fit 计算值有误。\n>> 解决办法：由于在 IE 浏览器中很难避免不触发 hasLayout 特性，因此建议在使用 ‘float’ ‘position:absolute' 这两个样式时，为 'width' 特性设置具体值。这样可以从根源上避免触发 shrink-to-fit 计算规则，由此来规避 IE6 IE7(Q) IE8(Q) 中由于 hasLayout 特性带来的渲染问题。\n\n> - 24、在 IE7(S) Firefox 中，若元素的高度出于某种原因使用了其 'min-height' 或 'max-height' 设定的值，则其生成的包含块的高度为元素的实际高度；而在 IE8(S) Chrome Safari Opera 中，生成的包含块的高度仍然为元素原始的高度。\n>> 解决办法：在子孙元素参照设定并在计算值上应用了 'min-height'、'max-height' 特性的元素生成的包含块的高度时需格外注意，此时尽量避免使用百分比等需要参照包含块计算的单位。\n\n> - 25、当采用如下布局方法时，各浏览器可能会造成 shrink-to-fit 计算规则处理差异：\n1.父元素采用浮动或绝对定位样式，宽度值为 'auto'；\n2.子元素存在两个以上连续的行内元素；\n3.两个行内元素之间存在空文本节点而非标记首尾紧密相连；\n4.第二个行内元素采用绝对定位样式，且 'top' 'left' 'bottom' 'right' 都为 'auto' 。\n此时，Safari 和 Chrome 中的父元素采用 shrink-to-fit 计算规则时，可能使用了 preferred minimum width 来作为 preferred width ，导致在空文本节点处产生换行，使依赖元素普通流位置的绝对定位元素显示位置产生差异。\n>> 解决办法：建议在使用 ‘float’ ‘position:absolute' 这两个样式时，为 'width' 特性设置具体值。这样可以从根源上避免触发 shrink-to-fit 计算规则带来的差异。\n\n> - 26、各浏览器对于未明确设定高度的包含块内包含百分比单位高度的块级元素的高度计算存在差异。\n>> 解决办法：要对设置有百分比高度的块级元素的包含块设置明确的 'height' 属性值。\n\n> - 27、当 IMG 元素没有设置 'width' 特性且设置了值单位为百分比的 'min-width' 或 'max-width' 特性， 则在各浏览器中该 IMG 元素的包含块的 'shrink-to-fit' 算法存在差异。\n>> 解决办法：在包含块的宽度计算需要依赖其内 IMG 元素时，尽量避免给 IMG 元素的 'min-width' 和 'max-width' 特性设置百分比单位的值。\n\n> - 28、在正常文档流中，当包含块宽度为 0，其内未设定明确宽度的块级元素由于设定了 'margin' 溢出包含块时，则该块级元素的宽度计算在 Chrome Safari 中会计算为 0。\n>> 解决办法：尽量避免出现未明确设定宽度 (值为 'auto') 的块级元素由于设定了 'margin' 导致其溢出其宽度为 0 的包含块，应为其设定一个明确的宽度。\n\n> - 29、当页面中存在一个空的非替换行内元素时，如果给这个元素设置了边框或者背景样式，那么在 IE6 IE7 IE8(Q) 中这些样式将无法显示出来。\n>> 解决办法：应尽量避免使用的空的非替换行内元素，以及避免为空元素添加显示用样式。\n\n---\n七、可视效果\n===\n\n> - 1、当一个元素的 'overflow-x' 或 'overflow-y' 指定值为 'hidden'，另一个特性的指定值为 'visible' 时， 该元素最终渲染使用的 'overflow-y' 或 'overflow-x' 值不同。IE6 IE7 IE8 使用 'hidden'，其它浏览器使用 'auto'。\n>> 解决办法：\n- 同时设置 'overflow-x' 和 'overflow-y' 的值，不要出现其中之一为 'hidden' 时，而另一个是 'visible' 的情况；\n- 避免编写依赖指定值为 'visible' 的 'overflow-x' 和 'overflow-y' 特性的计算值的代码。\n\n> - 2、在 IE6(S) IE7(S) 中，若一个 'overflow' 特性不为 'visible' 的非定位元素内包含了可能溢出其的相对定位元素，则溢出部分不会被剪裁。\n在 IE6(Q) IE7(Q) IE8(Q) 中，若一个 'overflow' 特性不为 'visible' 的非定位元素内包含可能其溢出的绝对定位元素，则仍然会剪裁溢出的绝对定位元素。\n>> 解决办法：根据实际需求可以去掉包含块的 'overflow:hidden' 或采用其他定位方案，避免在 IE 中触发此问题，实现在各浏览器表现一致。\n\n> - 3、在 IE6 IE7 IE8 中，若在同一条规则中同时首先定义了 'overflow-x' 或 'overflow-y' 特性，然后又定义了 'overflow' 特性，则作为简写的 'overflow' 特性的值不会覆盖之前的 'overflow-x' 或 'overflow-y' 特性的值。\n>> 解决办法：根据实际需求尽可能同时设定明确的 'overflow-x' 以及 'overflow-y' 特性，或者直接使用简写的 'overflow'，避免在同一条 CSS 规则内在 'overflow-x' 或 'overflow-y' 特性之后再定义 'overflow' 特性。\n\n---\n - 未完待续\n===\n","source":"_posts/与 CSS 相关的兼容性问题.md","raw":"title: 与 CSS 相关的兼容性问题\ndate: 2015-08-21 01:25:32\ntags: 兼容性\ncategories: 与 CSS 相关的兼容性问题\nkeywords: CSS, CSS兼容性, 前端兼容性, 兼容性\n---\n不同浏览器的兼容问题一直是前端开发工程师最头疼的问题，本系列文章记录一些常见和不常见的兼容性问题，因为兼容性问题太多了，所以内容可能有些杂乱，涉及的方面也肯定非常广,这里大多数只叙述问题和解决办法，而不细说原理，想了解原理的可以自行在网上查找。下面开始正文，本系列先从CSS开始。\n<!--more-->\n\n---\n一：语法和基本数据类型\n===\n> - 1、@charset 一定要放在样式表的最前面，否则在 Chrome和Safari中，@charset后面的规则集(样式)将失效。\n> - 2、如果一个外部 CSS 文件的编码与引入该文件的 HTML 文件的编码不一致，并且没有显式的声明该 CSS 文件的编码，在某些情况下会造成 CSS 的解析错误。解决办法：统一编码。\n\n{% codeblock lang:css %}\n\th1 {\n\t  margin:0;\n\t  width:100px;\n\t  height:100px;\n\t  background:blue;\n\t  font:20px/100px \"黑体\";\n\t  text-decoration:underline;\n\t  color:red;\n\t}\n{% endcodeblock %}\n如果上述CSS文件编码为GB2312，而引入的页面编码为UTF-8，在IE6中会从“黑体”往后的所有都被忽略（包括“黑体”），在其他浏览器只会将“黑体”忽略。\n![CSS兼容性](http://7xkj1z.com1.z0.glb.clouddn.com/CSS兼容性1.png)\n解决办法之一就是在CSS文件头部添加@charset \"UTF-8\"。\n> - 3、url中出现空白，在大部分浏览器中无法正确读取地址。但是IE6和IE7可以识别(经测试IE6/7也只能识别TAB和回车，空格也识别不出)。解决办法：避免url中出现空白。\n\n{% codeblock lang:html %}\n\t<!DOCTYPE html>\n\t<html>\n\t<head>\n\t<style>\n\t\tdiv.text { font-size:40px; float:left; border:1px solid black; color:navy; }\n\t\t#text2 { background-image:url(go    ogle.\n\t\tgif); }\n\t</style>\n\t\t</head>\n\t\t<body style=\"font:12px/1.2 'Trebuchet MS';\">\n\t\t<div id=\"text1\" class=\"text\" style=\"background-image:url(goo  gle_s\n\t\tmall.gif);\">some text 1</div>\n\t\t<br /><br /><br /><br /><br />\n\t\t<div id=\"text2\" class=\"text\">some text 2</div>\n\t</body>\n\t</html>\n{% endcodeblock %}\n![CSS兼容性](http://7xkj1z.com1.z0.glb.clouddn.com/CSS兼容性2.png)\n> - 4、正确地使用 CSS 的空白字符，避免使用表意空格 (U+3000)（表意空格（Ideographic Space），也可以叫全角空格（Full-width Space），对应的 HTML 实体字符为“&#12288”。在相同的等宽中文字体下，全角空格的宽度与普通汉字的宽度相等）。这个不一一列举了，每个浏览器支持情况不同，避免使用就好。\n\n---\n二：选择器\n===\n> - 1、IE6/IE7(Q)/IE8(Q)中不支持子选择器(如 ul>li)、兄弟选择器(如 div+p)、属性选择器([att]、[att=val]、[att~=val]、[att|=val])、 ':first-child'伪元素，避免在上述情况使用。\n> - 2、a标签的四个常用的伪类：':link'、':visited'、':hover'、':active',使用的顺序一定要是：L-V-H-A 来排序，虽然这一问题在IE6/IE7(Q)/IE8(Q)没有影响，但是其它的浏览器还是会有各种问题。\n> - 3、IE6/IE7(Q)/IE8(Q)中不支持a元素以外的元素使用':hover'伪类。\n>>解决办法：使用 JavaScript 绑定 'onmouseover' 和 'onmouseout'（模仿 ':hover'）；使用 Whatever:hover 插件，该插件利用 IE 特有的 CSS 行为（behavior）及通过 JavaScript 来模拟 ':hover' 伪类的效果。\n> - 4、IE6/IE7/IE8(Q)中不支持a元素以外的元素使用':active'伪类。\n>>解决办法：使用 JavaScript 绑定 'onmousedown' 和 'onmouseup'（模仿 ':active'）；同样的你可以使用 Whatever:hover 插件。\n> - 5、IE6/IE7/IE8(Q)不支持':focus'伪类。\n>>解决办法：使用 JavaScript 绑定 onfocus onblur 事件模仿 ':focus'效果；\n或者使用 Whatever:hover。\n> - 6、IE6/IE7/IE8(Q)不支持 ':before' 和 ':after' 伪元素\t\n>>解决办法：使用 JavaScript 判断 IE6 IE7 IE8(Q) 并在其中通过脚本实现 ':before' 及 ':after' 伪元素的效果；使用 jQuery 的插件 Pseudo Plugin，该组件利用 IE 特有的 CSS 行为（behavior）及 CSS 表达式来模拟 ':before' 及 ':after' 伪元素的效果。\n\n---\n三、指定特性值，层叠和继承\n===\n> - 1、IE6/IE7/IE8/Opera 中不支持'inherit'这个继承属性。\n\nIE8(S)中，块级元素无法通过设置'display:inherit'、特性值，显式性继承绝大部分行内元素的默认'display'特性值，但却可以显示性继承 BUTTON 元素的默认 'display' 特性。在Opera 中，P 元素无法通过设置 'border:inherit' 特性值，显式性继承 BUTTON 元素的默认 'border' 特性。\n解决办法：\n使用标准模式渲染页面；\n在 IE6 IE7 退出舞台之前避免使用 'inherit' 值显式性的继承样式设定；\n在 IE8 内不使用 'inherit' 值显式性继承行内元素的默认 'display' 特性值；\n在 Opera 内，不对使用 'inherit' 值显式性继承 BUTTON 元素默认 'border' 特性值。\n> - 2、在 Chrome 和 Safari 中，默认样式下的 B、STRONG 元素的 'font-weight' 特性计算值可能会受到其继承来的 'font-weight' 特性影响，在 IE8(S) 中，除 B、STRONG 外，H1~H6、TH 元素的'font-weight'特性也会受影响。在其他浏览器中，则完全不受影响。\n>>解决办法：尽量为元素设置绝对明确的 'font-weight' 特性的值，避免使用 bolder、lighter 这类相对量以及浏览器的默认样式。\n> - 3、 IE6 IE7(Q) IE8(Q) 不完全支持 !important 规则。不支持位于同一个选择器内的 '!important' 规则。\n\n{% codeblock lang:html %}\n\t<style type=\"text/css\">\n\t    div{\n\t        width:100px;\n\t        height:30px;\n\t        background-color:gold !important;\n\t        background-color:silver;\n\t    }\n\t</style>\n\t<div></div>\n{% endcodeblock %}\n![CSS兼容性](http://7xkj1z.com1.z0.glb.clouddn.com/CSS兼容性3.png)\n{% codeblock lang:html %}\n\t<style>\n\t  .c1 { background:blue !important; }\n\t  .c2 { background:green; }\n\t</style>\n\t<div style=\"width:100px; height:100px;\" class=\"c1 c2\"></div>\n{% endcodeblock %}\n![CSS兼容性](http://7xkj1z.com1.z0.glb.clouddn.com/CSS兼容性4.png)\n\n解决办法：这是浏览器的 Bug 导致，无法通过常规方式解决。不过，一般 '!important' 规则常常用于 CSS hack 以区分 IE6 与其他浏览器，其作为 hack 存在的意义已大于其本身的含义。\n\n---\n四、盒模型\n===\n> - 1、IE6 IE7 IE8(Q) 负边距 (margin) 导致元素溢出 hasLayout 容器时显示异常。\n>> 解决办法：在确保元素的容器触发 hasLayout 的前提下，为该元素同时设置 'position:relative' 和 'zoom:1'。\n首先需要保证容器在IE中触发 hasLayout 属性，可以通过zoom:1实现。在 IE7(S) 中，当使设置了负值 'margin' 的元素的 hasLayout 属性为 'true' ，即触发该元素的hasLayout特性后，此Bug现象消失，例如为该元素设置宽度或高度，或者在完全不影响该元素盒模型的情况下使用zoom:1 来触发 hasLayout 从而消除此 Bug 。在 IE6 IE7(Q) IE8(Q) 中，仅仅触发 hasLayout 特性并不一定能消除此 Bug ，同时还需要为该元素设置 'position:relative'，即在完全不影响该元素盒模型的情况下使用 zoom:1 'position:relative' 。\n> - 2、Chrome Safari ，在 WebKit 内核的浏览器中，当元素满足三个条件时，宽度计算不符合规范：\n元素的兄弟元素是浮动元素；元素的 'width' 特性值为 'auto'，'overflow' 特性值不是 'visible'；元素设置了与浮动同方向的 'margin' 值(如：当 'float:left' 时，设置 'margin-left' 值，当 'float:right' 时，设置 'margin-right')。\n>>解决办法：\n>>- 为该创建了 BFC 的元素设置一个明确的宽度; \n>>- 如果 'margin' 值不小于浮动元素的 margin box 的宽时，去掉'overflow:hidden'。\n> - 3、Firefox 中 'display:table' 的元素的外边距不会与包含块的外边距折叠(也就是margin塌陷)。\n\n{% codeblock lang:html %}\n\t<div style=\"background:gold;\">Top line</div>\n\t<div style=\"background:gray; width:300px; margin:20px 0;\">\n\t    <table cellpadding=\"0\" cellspacing=\"0\" style=\"background:pink; width:200px; margin:10px 0;\">\n\t        <tr>\n\t            <td>TD</td>\n\t        </tr>\n\t    </table>\n\t</div>\n\t<div style=\"background:gold;\">Bottom line</div>\n{% endcodeblock %}\n![CSS兼容性](http://7xkj1z.com1.z0.glb.clouddn.com/CSS兼容性5.png)\n>> 解决办法：由于 IE6 IE7 IE8(Q) Firefox 元素的 'margin' 处理与 W3C 规范中的差异，若我们需要利用 \"margin collapse\" 达到某些布局效果时，在这几种浏览器中可能会由于没有发生 \"margin collapse\" 而出现 \"额外边距\" 的情况。所以应避免为表格设置上下边距，以及导致其 \"margin collapse\" 的发生，可以使用为表格的父元素使用 'padding' 代替表格元素的 'margin' 。\n\n> - 4、IE6 IE7 IE8(Q) 中浮动元素和定位元素某些情况下会影响普通流中毗邻 'margin' 的折叠。\n>> 解决办法：\n>> - 根据具体需求，调整 'margin' 的位置和大小；\n>> - 使用 CSS hack 设置 IE 中的 'margin' 大小，以避免 IE 跟其他浏览器的布局差异。\n> - 5、在 IE6 IE7 IE8(Q)下，容器触发 hasLayout 导致其左浮动子元素 'margin-bottom' 消失。\n\n{% codeblock lang:html %}\n\t<span>content_text</span>\n\t<div style=\"zoom:1; overflow:hidden; background:lightgrey;\">\n\t    <div style=\"float:left; width:50px; height:50px; margin:20px; background:dimgray;\"></div>\n\t</div>\n\t<span>content_text</span>\n{% endcodeblock %}\n![CSS兼容性](http://7xkj1z.com1.z0.glb.clouddn.com/CSS兼容性6.png)\n>> 解决办法：为容器显式地设置高度。若容器高度不定，则要避免在触发了 hasLayout 的容器内的浮动子元素上设置 'margin-bottom' 特性，可以通过为容器设置 'padding-bottom' 达到相似的效果。只要不同时触发父元素hasLayout、子元素左浮动、左浮动子元素拥有非零的 margin-bottom 值，这三个条件中任意一项，均可解决此问题。\n\n> - 6、IE6 IE7 IE8(Q) 中，若一个触发了 hasLayout 的元素其内第一个非空白节点 (即 children[0]) 为 TEXTAREA 元素 或者 type 属性值为 text、password、submit、reset、button、file 的 INPUT 元素，并且这个元素设定了 'margin-left'、'margin-right' 特性，则 'margin-left'、'margin-right' 特性指定的值会应用于其相应方向的 padding 上。\n>> 解决办法：在 INPUT、TEXTAREA 元素之前放一个触发了 hasLayout 的空 SPAN 元素。\n\n---\n五、渲染模型\n===\n> - 1、各浏览器对 'display' 特性值的支持程度不同。\n>> 解决办法：尽量仅使用所有浏览器都支持的 'display' 特性值：'inline'、'block'、'list-item'、'none'。在 IE6 IE7 IE8(Q) 中实现块元素的 'display:inline-block' 特性值支持，需要先将块元素设置为行内元素，并设置可以在 IE6 IE7 IE8(Q) 内触发 haslayout 特性的专有特性 'zoom:1'。行内元素实现 'display:inline-block' 特性值支持只需直接设置此特性值或同样使用 'zoom:1' 即可。\n\n> - 2、在IE早期版本中的元素触发了haslayout，但是没有触发BFC，会导致在IE和其它浏览器中的布局有差异。（如何触发haslayout和BFC在这里不细说）\n>> 解决办法：仅当一个元素即在 IE 早期版本中触发了 hasLayout，又在其他浏览器中创建了 block formatting context 时，才能避免上述问题的发生。即同时启用上述两者以保证各浏览器的兼容，或者相反，两者皆不启用。\n\n> - 3、BFC在各浏览器中的问题：\n1.当容器有足够的剩余空间容纳 BFC 的宽度时，所有浏览器都会将 BFC 放置在浮动元素所在行的剩余空间内。\n2.在 IE6 IE7 IE8 Chrome Opera 中，当 BFC 的宽度介于 \"容器剩余宽度\" 与 \"容器宽度\" 之间时，BFC 会显示在浮动元素的下一行；在 Safari 中，BFC 则仍然保持显示在浮动元素所在行，并且 BFC 溢出容器；在 Firefox 中，当容器本身也创建了 BFC 或者容器的 'padding-top'、'border-top-width' 这些特性不都为 0 时表现与 IE8(S)、Chrome 类似，否则表现与 Safari 类似。\n3.在 IE6 IE7 IE8 Opera 中，当 BFC 的宽度大于 \"容器宽度\" 时，BFC 会显示在浮动元素的下一行；在 Chrome Safari 中，BFC 则仍然保持显示在浮动元素所在行，并且 BFC 溢出容器；在 Firefox 中，当容器本身也创建了 BFC 或者容器的 'padding- top'、'border-top-width' 这些特性不都为 0 时表现与 IE8(S) 类似，否则表现与 Chrome 类似。\n>> 解决办法：合理地设置容器的宽度、浮动元素的宽度、BFC 的宽度的值，尽量保证 BFC 的宽度小于 \"容器的剩余空间宽度\" 。若需要 BFC 折行显示在新的一行上，可以通过 BFC 设置 'clear' 特性等手段使其换行。\n\n> - 4、在 IE6 IE7 IE8(Q) 中，一个零高度的浮动元素仍能阻挡与其向相同方向浮动的兄弟元素。\n>> 解决办法：如果希望一个浮动元素能阻挡与其向相同方向浮动的兄弟元素，请确保其高度不为零；否则，请隐藏该元素，以使页面布局在各浏览器中的表现一致。\n\n> - 5、IE6 IE7 IE8(Q) 下，若浮动元素之前存在兄弟行内非浮动元素，IE 会将浮动元素所在的“当前行”认为是其前边的兄弟行内元素所产生的匿名框的底边，导致该浮动元素折行。\n>> 解决办法：依具体情况可以使用三种方法：使用绝对定位模拟右浮动、使用 IE hack 专门在IE6 IE7 中设置负的上外边距、将右浮动的 SPAN 元素调整到所有非浮动 SPAN 元素之前。\n\n> - 6、在 IE6 IE7 IE8(Q) 下，为 'clear' 元素设置负的 'margin-top' 时， 'clear' 元素的顶部 'border-box' 出现在了其之前浮动元素的底部 'margin-box' 之上。\n>> 解决办法：尽量避免为 'clear' 特性不为 none 的元素（即清理元素）设置 'margin-top' 特性，尤其是负值。若需要为该元素设置正的 'margin-top' 特性，可以将 'clear' 元素当做容器，在其内部加入设置了 'margin-top' 的元素。若需要为该元素设置负的 'margin-top' ，可以为浮动元素设置负的 'margin-bottom' 以缩小其 'margin-box' ，提高了其底部 'margin-box' 的位置，从而使 'clear' 元素可以产生向上移动的效果。\n\n> - 7、IE6 IE7 IE8(Q) 中，使用 'clear' 特性清除浮动后，浮动元素的容器若没有触发 hasLayout，则其背景将会丢失。\n>> 解决办法：使丢失背景的容器触发 IE 浏览器特有的 hasLayout，如 'zoom:1'，或者设置宽度和高度。\n\n> - 8、在IE6 IE7 IE8(Q)中，如果 clear 特性被设置在一个浮动的元素上，该浮动元素会与其前边的浮动元素放置在同一行。位于其后的浮动元素的外顶边高于该元素的外顶边。\n>> 解决办法：不要将 'clear' 特性应用在浮动元素上，以免出现上述不兼容的问题。\n\n> - 9、IE6 IE7 IE8(Q) 中一些拥有默认上下外边距的块级元素（浏览器设置的）在浮动，或触碰到触发了 hasLayout 特性的容器后，上下外边距会消失。\n>> 解决办法：用自定义的 'margin' 取代浏览器的默认外边距样式。\n\n> - 10、IE 中触发了 hasLayout 的容器同时使用 'clear' 特性清除浮动在某些情况下导致 'padding-top' 渲染异常。\n>> 解决办法：\n>> - 不触发容器的 hasLayout 特性；\n>> - 若容器触发了hasLayout 特性，尽量不为其设置 'padding-top' 特性；\n>> - 若容器触发了hasLayout 特性，且必须为容器设置 'padding-top' 特性，可以考虑使用 ':after' 的清除方式。\n\n> - 11、Firefox 浏览器对 'display:table' 中绝对定位元素包含块的判定有错误，可能会导致绝对定位元素位置跟其他浏览器中有差异。\n>> 解决办法：这是 Firefox 的一个 bug，绝对定位元素无法根据 'display' 特性是 'table' 且是绝对定位的祖先元素定位。为达到相同的效果可以改变元素的 containing block 或者改变元素的定位方式。为达到相同的效果，可以采用如下方式替代：\n改变元素的 containing block：让绝对定位元素相对于 TABLE 元素的单元格定位，即，在 TD 上设置 'position:absolute' ；或者改变元素的定位方式：把绝对定位元素的 'absolute' 改为 'relative' ，用相对定位。\n\n> - 12、 IE6 IE7 IE8(Q) Firefox Opera 中若绝对定位元素没有设置其 'top' 、 'right' 、 'bottom' 、 'left' 特性，则这四个特性的值为默认的 'auto' ，由于各浏览器对规范理解的差异，会导致页面布局差异。\n>> 解决办法：首先对于绝对定位元素，应尽可能避免使其 'top'、'right'、'bottom'、'left' 特性的值均为 'auto'。若必须这么做，则尽可能的保证绝对定位元素之前的兄弟元素为非浮动的块级元素。\n\n> - 13、IE6 IE7(Q) IE8(Q) 不支持固定定位（position:fixed）。\n>> 解决办法：在 IE6 IE7(Q) IE8(Q) 中为固定定位元素设置 'position:absolute'，再通过 JavaScript 脚本或者 CSS Expression 动态设置其偏移量。参考代码如下：\n\n\t<body style=\"font:12px Arial; _background-attachment:fixed; _background-image:url(about:blank);\">\n\t<div style=\"width:10000px; height:10000px;\"></div>\n\t<div id=\"d\" style=\"position:fixed; top:0; left:0; _position:absolute; _top:expression(offsetParent.scrollTop); _left:expression(offsetParent.scrollLeft); background:#ddd; width:100px; height:100px;\"></div>\n\t</body>\n\n> - 14、在 IE6 IE7 IE8(Q) 下，对于宽度超过容器的浮动元素，浏览器违背了浮动基本规则，导致其在浮动方向上溢出包含块。\n>> 解决办法：当文字方向为 'ltr' 时应避免使右浮动元素的宽度超出其包含块的宽度。同样地，当文字方向为 'rtl' 时应避免使左浮动元素的宽度超出其包含块的宽度。\n\n> - 15、当定位元素的 'z-index' 未设置时（默认为 auto），在 IE6 IE7 IE8(Q) 下将会创建一个新的局部层叠上下文。而在其它浏览器下，则严格按照规范，不产生新的局部层叠上下文。\n>> 解决办法：理解层叠上下文、层叠级别与 'z-index' 之间的关系。在可能出现定位元素相互覆盖的情况时，明确指定定位元素的 'z-index' 特性，避免此问题的出现。\n\n> - 16、IE6 IE7 IE8(Q) 中溢出容器的浮动元素导致容器兄弟元素文本定位错误。\n>> 解决办法：及时地为容器清除浮动，并且确保浮动元素没有溢出容器。\n\n\n> - 17、在 IE7(S) 中一个元素溢出的部分会被触发了 hasLayout 特性的元素遮盖。\n>> 解决办法：合理设置元素的 'width'、'height' 和 'overflow' 特性，避免内容溢出容器。\n\n> - 18、在 IE6 IE7(Q) IE8(Q) 下，若包含块没有触发 hasLayout 特性，则其内参照其定位的绝对定位元素的偏移位置计算会出现问题。\n>> 解决办法：使包含块触发 hasLayout 特性。如 'zoom:1' 或者设置明确的宽度、高度。\n\n> - 19、IE6 IE7 IE8(Q) Firefox 不支持 'display:run-in'。\n>> 解决办法：'display:run-in' 特性目前用的地方不多，应用此特性的元素的最终状态 (inline-level 或 block-level) 要根据其上下文来判断，目前建议直接使用 'display:inline' 或 'display:block' 来固定元素的状态。\n\n> - 20、包含块是行内元素，行内元素的绝对定位子元素位置，在各浏览器有差异。\n>> 解决办法：各浏览器对于行内元素的包含块范围计算有误，因此建议，应尽可能避免将行内元素边界作为计算包含块边界的情况出现。\n\n\n> - 21、在 IE6 IE7 IE8(Q) 中，TD/TH 及 TD 元素对设定 'position:relative' 特性及偏移有效，其他均无效；\n在 IE8(S) 中，TD/TH 及 CAPTION 元素及它们相对于 CSS 中 display 特性值对设定 'position:relative' 特性及偏移有效，其他均无效；\n在 Firefox 中，除 TABLE 之外的所有表格类元素以及它们相对于 CSS 中 display 特性值对设定 'position:relative' 特性及偏移均无效\n在 Chrome Safari 中，CAPTION 元素及它相对于 CSS 中 display 特性值 'caption' 对设定 'position:relative' 特性及偏移有效，其他均无效；\n在 Opera 中，COL、COLGROUP 元素以及它们相对于 CSS 中 display 特性值对设定 'position:relative' 特性及偏移无效，其他均有效。\n>> 解决办法：由于除 TABLE 之外的表格类元素以及它们相对于 CSS 中 display 特性值设定了相对定位后的效果 CSS2.1 规范中没有明确定义，而各浏览器的实现又存在很大差异。所以应避免为这些元素设定 'position:relative'。若需要实现如冻结表格行或列的效果，可以考虑使用绝对定位其他 TABLE 元素的方式模拟。\n\n> - 22、在 Safari Chrome 等使用 webkit 渲染引擎的浏览器中，'float:center' 是合法值，他等同于 'float:none' 设置，而其他浏览器则认为 ‘float’ 特性中 'center' 是个非法值，遵循规范应忽略此处的 'float' 特性设置。\n>> 解决办法：避免使用非法的 'float' 特性值。\n\n---\n六、渲染模型的细节\n===\n\n> - 1、如果一个页面使浏览器工作在混杂模式下，那么当给一个设置了 'padding' 或 'border-width' 的非替换元素设置 'width' 或 'height' 以控制其尺寸时，这个元素在 IE 和其他览器中的实际尺寸将是不同的。\n>> 解决办法：- 使用能触发标准模式 (S) 的 DTD\n- 使用 CSS 3 的新特性：box-sizing\n\n\n> - 2、在 IE6 IE7(Q) IE8(Q) 中，如果一个非替换元素的 'overflow' 为 'visible'，当该元素无法完全容纳其非绝对定位的内容时，该元素的尺寸将被其内容撑大。\n在上述情况发生时，为这个非替换元素设置的 'width' 和 'height' 与 CSS 2.1 中的 'min-width' 和 'min-height' 的作用类似：设定值不是最终的实际值，实际值可能更大。\n>> 解决办法：使用能触发标准模式 (S) 的 DTD，以将受此问题影响的浏览器的范围缩小到仅 IE6(S)。\n如果不能保证一个希望尺寸固定的非替换元素总是能容纳其内容，请将该元素的 'overflow' 设置为非 'visible' 的值。\n\n\n> - 3、在 IE6 IE7 IE8 中，'width' 或 'height' 任意一个或两个都设置为 '0' 的 IFRAME 元素是不可见的，而在其它浏览器中这样设置后的 IFRAME 元素仍可见。\n>> 解决办法：根据实际情况选择使用 'visibility:hidden' 或者 'display:none' 隐藏 IFRAME 。\n\n\n> - 4、在 IE6 IE7 IE8(Q) 中，如果一个浮动元素的宽度是 shrink-to-fit，该元素的最终宽度可能比预期的小，并被尽可能的向上布局。\n>> 解决办法：这个问题的影响较大，避免该问题的最直接的方式是给浮动非替换元素指定一个宽度，而不使用其默认值 'auto'，从而避免其宽度为 shrink-to-fit，以使页面布局在各浏览器中的表现一致。\n\n> - 5、在 Chrome Safari 中，若浮动元素之前存在一个非 inline 级元素（包括 block、table 等），且它们的包含块 'width' 特性计算值为 auto，则包含块的 shrink-to-fit 宽度计算会出现错误。\n>> 解决办法：在容器为绝对定位、浮动或行内块元素且没有明确设定宽度时，若浮动元素之前出现非 inline 级元素，则要小心这个元素对容器 shrink-to-fit 宽度的影响。可以为容器明确的设定一个宽度。\n\n> - 6、在 IE6 IE7 IE8(Q) 中，一个右浮动元素将尽可能的向右布局，并撑大其所有宽度为 'auto' 的祖先级元素的宽度，直到遇到一个明确设定了宽度的祖先级元素为止。\n注：这种现象仅在该元素有宽度为 shrink-to-fit 的的祖先级元素时才可以看到。\n>> 解决办法：如果有一个右浮动元素，应注意避免其祖先级元素的宽度为 shrink-to-fit，即给它们设定一个明确的宽度。以使页面布局在各浏览器中的表现一致。\n\n> - 7、IE6 IE7 IE8 Opera 中对 shrink-to-fit 计算时会考虑浮动元素的宽度，这其中包含非替换浮动元素、非替换绝对定位元素、为替换行内块元素。\n>> 解决办法：尽量为非替换浮动元素、非替换绝对定位元素、非替换行内块元素显式地设置一个宽度，防止浏览器在 'width:auto' 时对于 shrink-to-fit 的宽度计算方式不同造成布局上的差异。\n\n> - 8、IE6 及 IE7/8 的混杂模式下，非替换绝度定位元素当指定了 'left' 及 'right'，而 'width' 为默认值 \"auto\" 。此时浏览器无法正确地计算出 'width' 的值，对于高度的计算也是如此。\n>> 解决办法：若能为非替换绝对定位元素设定固定的宽度及高度，则尽量不使用此方式自动计算绝对定位元素的 'width' 及 'height'；若无法避免使用此方式，则可以通过判断浏览器，仅在 IE6 中使用 CSS Expression 控制绝对定位元素的宽度及高度。\n\n> - 9、IE6 IE7 IE8(Q) 在超过一个行内元素排列生成行框时，识别行框的顶边和底边位置时会参照文本实际高度的顶边和底边尺寸，而不是行框内最高行内框的顶边和最底行内框的底边位置。\n>> 解决办法：为了取得正常布局，建议 'line-height' 计算值设置永远大于 'font-size' 计算值设置。\n\n> - 10、IE6 IE7(Q) IE8(Q)不支持 'min-width' 和 'max-width' 特性。\n>> 解决办法：使用 Javascript 实现 'min-width' 和 'max-width' 特性功能。\n\n> - 11、IE6 IE7 IE8(Q) 中行内非替换元素中的非文本文字可能会撑高其高度。\n>> 解决办法：针对不同的需求，可以采取不同的解决方案，例如，将外层的行内元素改为一个块级元素、给外层行内元素设置 'display:inline-block'、给外层行内元素设置合适的 'font-size' 值等。\n\n> - 12、不同浏览器内 'line-height' 样式设置会影响 INPUT BUTTON 元素的显示高度。\n>> 解决办法：尽量避免使用 'line-height' 为 INPUT[type=text]、INPUT[type=password]、INPUT[type=button]、INPUT[type=file]、input[type=submit] 和 BUTTON 标记设置 ‘line-height’，而应改用规范内说明的 'height' 属性。\n\n> - 13、IE6 IE7 IE8(Q) 中触发 hasLayout 的空块级非替换元素的高度不为 0。\n>> 解决办法：如果想让一个触发了 hasLayout 的块级非替换元素的高度为 0，可以给这个空的块级非替换元素增加一个空的注释块：\n\n\t<div style=\"zoom:1\"><!-- --></div>\n另外，不让元素在 IE 中触发 hasLayout 也可以避免此 BUG 。\n\n> - 14、IE 的混杂模式中行内非替换元素的宽高可设置。\n>> 解决办法：在页面上添加<!DOCTYPE HTML>，使页面工作在标准模式下。\n\n> - 15、IE6 IE7(Q) IE8(Q) 不支持 'min-height' 和 'max-height' 特性。\n>> 解决办法：使用 Javascript 实现 'min-height' 和 'max-height' 特性功能。\n\n> - 16、不同浏览器对单行文本输入框和显示为按钮的控件基线位置理解不同。\n>> 解决办法：避免使用 'baseline' 对齐方式，为元素指定 'vertical-align' 值非 'baseline'，推荐使用 'vertical-align:bottom' 或 'vertical-align:top'。\n\n> - 17、Webkit 浏览器下行框高度计算还依赖于 'font-size' 属性值，在 'line-height' 属性值明显小于 'font-size' 属性值设置时，将导致实际计算出的行框高度大于其他浏览器。\n>> 解决办法：为了取得正常布局，建议 'line-height' 计算值永远大于 'font-size' 计算值设置。\n\n> - 18、容器高度被明确设定，容器内容高度仅由行高累加决定的情况下，Safari Chrome 中容器元素的 'overflow' 值为非默认值时，其最后一个内联子元素的半差异高度可能会被忽略。\n>> 解决办法：为了准确得到容器高度，建议避免使用行高为行内元素指定高度，而应改用块标记，并且明确的指定其 'height' 值。\n\n> - 19、对于行内元素绝对定位后静态位置中的 'top' 特性的计算值，IE6 IE7 IE8(Q) 会将其计算为静态位置下 content area 距包含块顶边的距离（即半差异的高度），其他浏览器则计算为 0。\n>> 解决办法：在使行内元素绝对定位的时候，要注意其行高对静态位置带来的影响，明确设置定位的元素偏移位置。\n\n> - 20、在非标准文档模式中（包括混杂模式和近乎标准模式），当唯一的非表单控件类行内替换元素存在于其包容块中时，其父框的行高并不一定会计算文本基线高度。\n>> 解决办法：如果在非标准模式中，需要父容器在仅有行内替换元素的情况下计算出包含文本基线高度的行高值，则必须加入其他行内文本元素。相反的，如果在标准模式中，需要行内替换元素与其父容器底部无间隙，请修改 'vertical-align' 值为非 'baseline' 。\n\n> - 21、若容器中包含 MARQUEE 元素，且容器遵循 shrink-to-fit 宽度算法，则容器及 MARQUEE 元素的宽度在不同浏览器中存在差异。\n>> 解决办法：给 MARQUEE 元素及替换元素定义具体的宽度，保证各浏览器兼容。\n\n> - 22、对于宽度为 0% 的 IMG 元素的包含块的 shrink-to-fit 算法，Firefox Chrome Safari 与 IE6 IE7 IE8 Opera 存在差异。\n>> 解决办法：尽量避免设置 IMG 元素的宽度为 0%，可以用 0px 替代。\n\n> - 23、IE6 IE7(Q) IE8(Q) 中，如果父需要使用 shrink-to-fit 算法，并且其子元素触发了 hasLayout 特性以及 'width' 特性值为默认的 'auto'，那么会导致父元素 shrink-to-fit 计算值有误。\n>> 解决办法：由于在 IE 浏览器中很难避免不触发 hasLayout 特性，因此建议在使用 ‘float’ ‘position:absolute' 这两个样式时，为 'width' 特性设置具体值。这样可以从根源上避免触发 shrink-to-fit 计算规则，由此来规避 IE6 IE7(Q) IE8(Q) 中由于 hasLayout 特性带来的渲染问题。\n\n> - 24、在 IE7(S) Firefox 中，若元素的高度出于某种原因使用了其 'min-height' 或 'max-height' 设定的值，则其生成的包含块的高度为元素的实际高度；而在 IE8(S) Chrome Safari Opera 中，生成的包含块的高度仍然为元素原始的高度。\n>> 解决办法：在子孙元素参照设定并在计算值上应用了 'min-height'、'max-height' 特性的元素生成的包含块的高度时需格外注意，此时尽量避免使用百分比等需要参照包含块计算的单位。\n\n> - 25、当采用如下布局方法时，各浏览器可能会造成 shrink-to-fit 计算规则处理差异：\n1.父元素采用浮动或绝对定位样式，宽度值为 'auto'；\n2.子元素存在两个以上连续的行内元素；\n3.两个行内元素之间存在空文本节点而非标记首尾紧密相连；\n4.第二个行内元素采用绝对定位样式，且 'top' 'left' 'bottom' 'right' 都为 'auto' 。\n此时，Safari 和 Chrome 中的父元素采用 shrink-to-fit 计算规则时，可能使用了 preferred minimum width 来作为 preferred width ，导致在空文本节点处产生换行，使依赖元素普通流位置的绝对定位元素显示位置产生差异。\n>> 解决办法：建议在使用 ‘float’ ‘position:absolute' 这两个样式时，为 'width' 特性设置具体值。这样可以从根源上避免触发 shrink-to-fit 计算规则带来的差异。\n\n> - 26、各浏览器对于未明确设定高度的包含块内包含百分比单位高度的块级元素的高度计算存在差异。\n>> 解决办法：要对设置有百分比高度的块级元素的包含块设置明确的 'height' 属性值。\n\n> - 27、当 IMG 元素没有设置 'width' 特性且设置了值单位为百分比的 'min-width' 或 'max-width' 特性， 则在各浏览器中该 IMG 元素的包含块的 'shrink-to-fit' 算法存在差异。\n>> 解决办法：在包含块的宽度计算需要依赖其内 IMG 元素时，尽量避免给 IMG 元素的 'min-width' 和 'max-width' 特性设置百分比单位的值。\n\n> - 28、在正常文档流中，当包含块宽度为 0，其内未设定明确宽度的块级元素由于设定了 'margin' 溢出包含块时，则该块级元素的宽度计算在 Chrome Safari 中会计算为 0。\n>> 解决办法：尽量避免出现未明确设定宽度 (值为 'auto') 的块级元素由于设定了 'margin' 导致其溢出其宽度为 0 的包含块，应为其设定一个明确的宽度。\n\n> - 29、当页面中存在一个空的非替换行内元素时，如果给这个元素设置了边框或者背景样式，那么在 IE6 IE7 IE8(Q) 中这些样式将无法显示出来。\n>> 解决办法：应尽量避免使用的空的非替换行内元素，以及避免为空元素添加显示用样式。\n\n---\n七、可视效果\n===\n\n> - 1、当一个元素的 'overflow-x' 或 'overflow-y' 指定值为 'hidden'，另一个特性的指定值为 'visible' 时， 该元素最终渲染使用的 'overflow-y' 或 'overflow-x' 值不同。IE6 IE7 IE8 使用 'hidden'，其它浏览器使用 'auto'。\n>> 解决办法：\n- 同时设置 'overflow-x' 和 'overflow-y' 的值，不要出现其中之一为 'hidden' 时，而另一个是 'visible' 的情况；\n- 避免编写依赖指定值为 'visible' 的 'overflow-x' 和 'overflow-y' 特性的计算值的代码。\n\n> - 2、在 IE6(S) IE7(S) 中，若一个 'overflow' 特性不为 'visible' 的非定位元素内包含了可能溢出其的相对定位元素，则溢出部分不会被剪裁。\n在 IE6(Q) IE7(Q) IE8(Q) 中，若一个 'overflow' 特性不为 'visible' 的非定位元素内包含可能其溢出的绝对定位元素，则仍然会剪裁溢出的绝对定位元素。\n>> 解决办法：根据实际需求可以去掉包含块的 'overflow:hidden' 或采用其他定位方案，避免在 IE 中触发此问题，实现在各浏览器表现一致。\n\n> - 3、在 IE6 IE7 IE8 中，若在同一条规则中同时首先定义了 'overflow-x' 或 'overflow-y' 特性，然后又定义了 'overflow' 特性，则作为简写的 'overflow' 特性的值不会覆盖之前的 'overflow-x' 或 'overflow-y' 特性的值。\n>> 解决办法：根据实际需求尽可能同时设定明确的 'overflow-x' 以及 'overflow-y' 特性，或者直接使用简写的 'overflow'，避免在同一条 CSS 规则内在 'overflow-x' 或 'overflow-y' 特性之后再定义 'overflow' 特性。\n\n---\n - 未完待续\n===\n","slug":"与 CSS 相关的兼容性问题","published":1,"updated":"2016-10-31T07:25:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciuyzlut80007e6tb8rrvgpfm","content":"<p>不同浏览器的兼容问题一直是前端开发工程师最头疼的问题，本系列文章记录一些常见和不常见的兼容性问题，因为兼容性问题太多了，所以内容可能有些杂乱，涉及的方面也肯定非常广,这里大多数只叙述问题和解决办法，而不细说原理，想了解原理的可以自行在网上查找。下面开始正文，本系列先从CSS开始。<br><a id=\"more\"></a></p>\n<hr>\n<h1 id=\"一：语法和基本数据类型\"><a href=\"#一：语法和基本数据类型\" class=\"headerlink\" title=\"一：语法和基本数据类型\"></a>一：语法和基本数据类型</h1><blockquote>\n<ul>\n<li>1、@charset 一定要放在样式表的最前面，否则在 Chrome和Safari中，@charset后面的规则集(样式)将失效。</li>\n<li>2、如果一个外部 CSS 文件的编码与引入该文件的 HTML 文件的编码不一致，并且没有显式的声明该 CSS 文件的编码，在某些情况下会造成 CSS 的解析错误。解决办法：统一编码。</li>\n</ul>\n</blockquote>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">h1</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">margin</span>:<span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">100px</span>;</div><div class=\"line\">  <span class=\"attribute\">height</span>:<span class=\"number\">100px</span>;</div><div class=\"line\">  <span class=\"attribute\">background</span>:blue;</div><div class=\"line\">  <span class=\"attribute\">font</span>:<span class=\"number\">20px</span>/<span class=\"number\">100px</span> <span class=\"string\">\"黑体\"</span>;</div><div class=\"line\">  <span class=\"attribute\">text-decoration</span>:underline;</div><div class=\"line\">  <span class=\"attribute\">color</span>:red;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果上述CSS文件编码为GB2312，而引入的页面编码为UTF-8，在IE6中会从“黑体”往后的所有都被忽略（包括“黑体”），在其他浏览器只会将“黑体”忽略。<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/CSS兼容性1.png\" alt=\"CSS兼容性\"><br>解决办法之一就是在CSS文件头部添加@charset “UTF-8”。</p>\n<blockquote>\n<ul>\n<li>3、url中出现空白，在大部分浏览器中无法正确读取地址。但是IE6和IE7可以识别(经测试IE6/7也只能识别TAB和回车，空格也识别不出)。解决办法：避免url中出现空白。</li>\n</ul>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"css\"></span></div><div class=\"line\">\t<span class=\"selector-tag\">div</span><span class=\"selector-class\">.text</span> &#123; <span class=\"attribute\">font-size</span>:<span class=\"number\">40px</span>; <span class=\"attribute\">float</span>:left; <span class=\"attribute\">border</span>:<span class=\"number\">1px</span> solid black; <span class=\"attribute\">color</span>:navy; &#125;</div><div class=\"line\">\t<span class=\"selector-id\">#text2</span> &#123; <span class=\"attribute\">background-image</span>:<span class=\"built_in\">url</span>(go    ogle.</div><div class=\"line\">\tgif); &#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">body</span> <span class=\"attr\">style</span>=<span class=\"string\">\"font:12px/1.2 'Trebuchet MS';\"</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"text1\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"background-image:url(goo  gle_s</span></span></div><div class=\"line\">\tmall.gif);\"&gt;some text 1<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">br</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span> /&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"text2\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"text\"</span>&gt;</span>some text 2<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/CSS兼容性2.png\" alt=\"CSS兼容性\"></p>\n<blockquote>\n<ul>\n<li>4、正确地使用 CSS 的空白字符，避免使用表意空格 (U+3000)（表意空格（Ideographic Space），也可以叫全角空格（Full-width Space），对应的 HTML 实体字符为“&amp;#12288”。在相同的等宽中文字体下，全角空格的宽度与普通汉字的宽度相等）。这个不一一列举了，每个浏览器支持情况不同，避免使用就好。</li>\n</ul>\n</blockquote>\n<hr>\n<h1 id=\"二：选择器\"><a href=\"#二：选择器\" class=\"headerlink\" title=\"二：选择器\"></a>二：选择器</h1><blockquote>\n<ul>\n<li>1、IE6/IE7(Q)/IE8(Q)中不支持子选择器(如 ul&gt;li)、兄弟选择器(如 div+p)、属性选择器([att]、[att=val]、[att~=val]、[att|=val])、 ‘:first-child’伪元素，避免在上述情况使用。</li>\n<li>2、a标签的四个常用的伪类：’:link’、’:visited’、’:hover’、’:active’,使用的顺序一定要是：L-V-H-A 来排序，虽然这一问题在IE6/IE7(Q)/IE8(Q)没有影响，但是其它的浏览器还是会有各种问题。</li>\n<li>3、IE6/IE7(Q)/IE8(Q)中不支持a元素以外的元素使用’:hover’伪类。<blockquote>\n<p>解决办法：使用 JavaScript 绑定 ‘onmouseover’ 和 ‘onmouseout’（模仿 ‘:hover’）；使用 Whatever:hover 插件，该插件利用 IE 特有的 CSS 行为（behavior）及通过 JavaScript 来模拟 ‘:hover’ 伪类的效果。</p>\n</blockquote>\n</li>\n<li>4、IE6/IE7/IE8(Q)中不支持a元素以外的元素使用’:active’伪类。<blockquote>\n<p>解决办法：使用 JavaScript 绑定 ‘onmousedown’ 和 ‘onmouseup’（模仿 ‘:active’）；同样的你可以使用 Whatever:hover 插件。</p>\n</blockquote>\n</li>\n<li>5、IE6/IE7/IE8(Q)不支持’:focus’伪类。<blockquote>\n<p>解决办法：使用 JavaScript 绑定 onfocus onblur 事件模仿 ‘:focus’效果；<br>或者使用 Whatever:hover。</p>\n</blockquote>\n</li>\n<li>6、IE6/IE7/IE8(Q)不支持 ‘:before’ 和 ‘:after’ 伪元素    <blockquote>\n<p>解决办法：使用 JavaScript 判断 IE6 IE7 IE8(Q) 并在其中通过脚本实现 ‘:before’ 及 ‘:after’ 伪元素的效果；使用 jQuery 的插件 Pseudo Plugin，该组件利用 IE 特有的 CSS 行为（behavior）及 CSS 表达式来模拟 ‘:before’ 及 ‘:after’ 伪元素的效果。</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<hr>\n<h1 id=\"三、指定特性值，层叠和继承\"><a href=\"#三、指定特性值，层叠和继承\" class=\"headerlink\" title=\"三、指定特性值，层叠和继承\"></a>三、指定特性值，层叠和继承</h1><blockquote>\n<ul>\n<li>1、IE6/IE7/IE8/Opera 中不支持’inherit’这个继承属性。</li>\n</ul>\n</blockquote>\n<p>IE8(S)中，块级元素无法通过设置’display:inherit’、特性值，显式性继承绝大部分行内元素的默认’display’特性值，但却可以显示性继承 BUTTON 元素的默认 ‘display’ 特性。在Opera 中，P 元素无法通过设置 ‘border:inherit’ 特性值，显式性继承 BUTTON 元素的默认 ‘border’ 特性。<br>解决办法：<br>使用标准模式渲染页面；<br>在 IE6 IE7 退出舞台之前避免使用 ‘inherit’ 值显式性的继承样式设定；<br>在 IE8 内不使用 ‘inherit’ 值显式性继承行内元素的默认 ‘display’ 特性值；<br>在 Opera 内，不对使用 ‘inherit’ 值显式性继承 BUTTON 元素默认 ‘border’ 特性值。</p>\n<blockquote>\n<ul>\n<li>2、在 Chrome 和 Safari 中，默认样式下的 B、STRONG 元素的 ‘font-weight’ 特性计算值可能会受到其继承来的 ‘font-weight’ 特性影响，在 IE8(S) 中，除 B、STRONG 外，H1~H6、TH 元素的’font-weight’特性也会受影响。在其他浏览器中，则完全不受影响。<blockquote>\n<p>解决办法：尽量为元素设置绝对明确的 ‘font-weight’ 特性的值，避免使用 bolder、lighter 这类相对量以及浏览器的默认样式。</p>\n</blockquote>\n</li>\n<li>3、 IE6 IE7(Q) IE8(Q) 不完全支持 !important 规则。不支持位于同一个选择器内的 ‘!important’ 规则。</li>\n</ul>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span>&gt;</span><span class=\"css\"></span></div><div class=\"line\">    <span class=\"selector-tag\">div</span>&#123;</div><div class=\"line\">        <span class=\"attribute\">width</span>:<span class=\"number\">100px</span>;</div><div class=\"line\">        <span class=\"attribute\">height</span>:<span class=\"number\">30px</span>;</div><div class=\"line\">        <span class=\"attribute\">background-color</span>:gold <span class=\"meta\">!important</span>;</div><div class=\"line\">        <span class=\"attribute\">background-color</span>:silver;</div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/CSS兼容性3.png\" alt=\"CSS兼容性\"><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"css\"></span></div><div class=\"line\">  <span class=\"selector-class\">.c1</span> &#123; <span class=\"attribute\">background</span>:blue <span class=\"meta\">!important</span>; &#125;</div><div class=\"line\">  <span class=\"selector-class\">.c2</span> &#123; <span class=\"attribute\">background</span>:green; &#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"width:100px; height:100px;\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"c1 c2\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure><br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/CSS兼容性4.png\" alt=\"CSS兼容性\"></p>\n<p>解决办法：这是浏览器的 Bug 导致，无法通过常规方式解决。不过，一般 ‘!important’ 规则常常用于 CSS hack 以区分 IE6 与其他浏览器，其作为 hack 存在的意义已大于其本身的含义。</p>\n<hr>\n<h1 id=\"四、盒模型\"><a href=\"#四、盒模型\" class=\"headerlink\" title=\"四、盒模型\"></a>四、盒模型</h1><blockquote>\n<ul>\n<li>1、IE6 IE7 IE8(Q) 负边距 (margin) 导致元素溢出 hasLayout 容器时显示异常。<blockquote>\n<p>解决办法：在确保元素的容器触发 hasLayout 的前提下，为该元素同时设置 ‘position:relative’ 和 ‘zoom:1’。<br>首先需要保证容器在IE中触发 hasLayout 属性，可以通过zoom:1实现。在 IE7(S) 中，当使设置了负值 ‘margin’ 的元素的 hasLayout 属性为 ‘true’ ，即触发该元素的hasLayout特性后，此Bug现象消失，例如为该元素设置宽度或高度，或者在完全不影响该元素盒模型的情况下使用zoom:1 来触发 hasLayout 从而消除此 Bug 。在 IE6 IE7(Q) IE8(Q) 中，仅仅触发 hasLayout 特性并不一定能消除此 Bug ，同时还需要为该元素设置 ‘position:relative’，即在完全不影响该元素盒模型的情况下使用 zoom:1 ‘position:relative’ 。</p>\n</blockquote>\n</li>\n<li>2、Chrome Safari ，在 WebKit 内核的浏览器中，当元素满足三个条件时，宽度计算不符合规范：<br>元素的兄弟元素是浮动元素；元素的 ‘width’ 特性值为 ‘auto’，’overflow’ 特性值不是 ‘visible’；元素设置了与浮动同方向的 ‘margin’ 值(如：当 ‘float:left’ 时，设置 ‘margin-left’ 值，当 ‘float:right’ 时，设置 ‘margin-right’)。<blockquote>\n<p>解决办法：</p>\n<ul>\n<li>为该创建了 BFC 的元素设置一个明确的宽度; </li>\n<li>如果 ‘margin’ 值不小于浮动元素的 margin box 的宽时，去掉’overflow:hidden’。</li>\n</ul>\n</blockquote>\n</li>\n<li>3、Firefox 中 ‘display:table’ 的元素的外边距不会与包含块的外边距折叠(也就是margin塌陷)。</li>\n</ul>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"background:gold;\"</span>&gt;</span>Top line<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"background:gray; width:300px; margin:20px 0;\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">table</span> <span class=\"attr\">cellpadding</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">cellspacing</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"background:pink; width:200px; margin:10px 0;\"</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>TD<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"background:gold;\"</span>&gt;</span>Bottom line<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/CSS兼容性5.png\" alt=\"CSS兼容性\"></p>\n<blockquote>\n<blockquote>\n<p>解决办法：由于 IE6 IE7 IE8(Q) Firefox 元素的 ‘margin’ 处理与 W3C 规范中的差异，若我们需要利用 “margin collapse” 达到某些布局效果时，在这几种浏览器中可能会由于没有发生 “margin collapse” 而出现 “额外边距” 的情况。所以应避免为表格设置上下边距，以及导致其 “margin collapse” 的发生，可以使用为表格的父元素使用 ‘padding’ 代替表格元素的 ‘margin’ 。</p>\n</blockquote>\n<ul>\n<li>4、IE6 IE7 IE8(Q) 中浮动元素和定位元素某些情况下会影响普通流中毗邻 ‘margin’ 的折叠。<blockquote>\n<p>解决办法：</p>\n<ul>\n<li>根据具体需求，调整 ‘margin’ 的位置和大小；</li>\n<li>使用 CSS hack 设置 IE 中的 ‘margin’ 大小，以避免 IE 跟其他浏览器的布局差异。</li>\n</ul>\n</blockquote>\n</li>\n<li>5、在 IE6 IE7 IE8(Q)下，容器触发 hasLayout 导致其左浮动子元素 ‘margin-bottom’ 消失。</li>\n</ul>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>content_text<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"zoom:1; overflow:hidden; background:lightgrey;\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"float:left; width:50px; height:50px; margin:20px; background:dimgray;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>content_text<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/CSS兼容性6.png\" alt=\"CSS兼容性\"></p>\n<blockquote>\n<blockquote>\n<p>解决办法：为容器显式地设置高度。若容器高度不定，则要避免在触发了 hasLayout 的容器内的浮动子元素上设置 ‘margin-bottom’ 特性，可以通过为容器设置 ‘padding-bottom’ 达到相似的效果。只要不同时触发父元素hasLayout、子元素左浮动、左浮动子元素拥有非零的 margin-bottom 值，这三个条件中任意一项，均可解决此问题。</p>\n</blockquote>\n<ul>\n<li>6、IE6 IE7 IE8(Q) 中，若一个触发了 hasLayout 的元素其内第一个非空白节点 (即 children[0]) 为 TEXTAREA 元素 或者 type 属性值为 text、password、submit、reset、button、file 的 INPUT 元素，并且这个元素设定了 ‘margin-left’、’margin-right’ 特性，则 ‘margin-left’、’margin-right’ 特性指定的值会应用于其相应方向的 padding 上。<blockquote>\n<p>解决办法：在 INPUT、TEXTAREA 元素之前放一个触发了 hasLayout 的空 SPAN 元素。</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<hr>\n<h1 id=\"五、渲染模型\"><a href=\"#五、渲染模型\" class=\"headerlink\" title=\"五、渲染模型\"></a>五、渲染模型</h1><blockquote>\n<ul>\n<li><p>1、各浏览器对 ‘display’ 特性值的支持程度不同。</p>\n<blockquote>\n<p>解决办法：尽量仅使用所有浏览器都支持的 ‘display’ 特性值：’inline’、’block’、’list-item’、’none’。在 IE6 IE7 IE8(Q) 中实现块元素的 ‘display:inline-block’ 特性值支持，需要先将块元素设置为行内元素，并设置可以在 IE6 IE7 IE8(Q) 内触发 haslayout 特性的专有特性 ‘zoom:1’。行内元素实现 ‘display:inline-block’ 特性值支持只需直接设置此特性值或同样使用 ‘zoom:1’ 即可。</p>\n</blockquote>\n</li>\n<li><p>2、在IE早期版本中的元素触发了haslayout，但是没有触发BFC，会导致在IE和其它浏览器中的布局有差异。（如何触发haslayout和BFC在这里不细说）</p>\n<blockquote>\n<p>解决办法：仅当一个元素即在 IE 早期版本中触发了 hasLayout，又在其他浏览器中创建了 block formatting context 时，才能避免上述问题的发生。即同时启用上述两者以保证各浏览器的兼容，或者相反，两者皆不启用。</p>\n</blockquote>\n</li>\n<li><p>3、BFC在各浏览器中的问题：<br>1.当容器有足够的剩余空间容纳 BFC 的宽度时，所有浏览器都会将 BFC 放置在浮动元素所在行的剩余空间内。<br>2.在 IE6 IE7 IE8 Chrome Opera 中，当 BFC 的宽度介于 “容器剩余宽度” 与 “容器宽度” 之间时，BFC 会显示在浮动元素的下一行；在 Safari 中，BFC 则仍然保持显示在浮动元素所在行，并且 BFC 溢出容器；在 Firefox 中，当容器本身也创建了 BFC 或者容器的 ‘padding-top’、’border-top-width’ 这些特性不都为 0 时表现与 IE8(S)、Chrome 类似，否则表现与 Safari 类似。<br>3.在 IE6 IE7 IE8 Opera 中，当 BFC 的宽度大于 “容器宽度” 时，BFC 会显示在浮动元素的下一行；在 Chrome Safari 中，BFC 则仍然保持显示在浮动元素所在行，并且 BFC 溢出容器；在 Firefox 中，当容器本身也创建了 BFC 或者容器的 ‘padding- top’、’border-top-width’ 这些特性不都为 0 时表现与 IE8(S) 类似，否则表现与 Chrome 类似。</p>\n<blockquote>\n<p>解决办法：合理地设置容器的宽度、浮动元素的宽度、BFC 的宽度的值，尽量保证 BFC 的宽度小于 “容器的剩余空间宽度” 。若需要 BFC 折行显示在新的一行上，可以通过 BFC 设置 ‘clear’ 特性等手段使其换行。</p>\n</blockquote>\n</li>\n<li><p>4、在 IE6 IE7 IE8(Q) 中，一个零高度的浮动元素仍能阻挡与其向相同方向浮动的兄弟元素。</p>\n<blockquote>\n<p>解决办法：如果希望一个浮动元素能阻挡与其向相同方向浮动的兄弟元素，请确保其高度不为零；否则，请隐藏该元素，以使页面布局在各浏览器中的表现一致。</p>\n</blockquote>\n</li>\n<li><p>5、IE6 IE7 IE8(Q) 下，若浮动元素之前存在兄弟行内非浮动元素，IE 会将浮动元素所在的“当前行”认为是其前边的兄弟行内元素所产生的匿名框的底边，导致该浮动元素折行。</p>\n<blockquote>\n<p>解决办法：依具体情况可以使用三种方法：使用绝对定位模拟右浮动、使用 IE hack 专门在IE6 IE7 中设置负的上外边距、将右浮动的 SPAN 元素调整到所有非浮动 SPAN 元素之前。</p>\n</blockquote>\n</li>\n<li><p>6、在 IE6 IE7 IE8(Q) 下，为 ‘clear’ 元素设置负的 ‘margin-top’ 时， ‘clear’ 元素的顶部 ‘border-box’ 出现在了其之前浮动元素的底部 ‘margin-box’ 之上。</p>\n<blockquote>\n<p>解决办法：尽量避免为 ‘clear’ 特性不为 none 的元素（即清理元素）设置 ‘margin-top’ 特性，尤其是负值。若需要为该元素设置正的 ‘margin-top’ 特性，可以将 ‘clear’ 元素当做容器，在其内部加入设置了 ‘margin-top’ 的元素。若需要为该元素设置负的 ‘margin-top’ ，可以为浮动元素设置负的 ‘margin-bottom’ 以缩小其 ‘margin-box’ ，提高了其底部 ‘margin-box’ 的位置，从而使 ‘clear’ 元素可以产生向上移动的效果。</p>\n</blockquote>\n</li>\n<li><p>7、IE6 IE7 IE8(Q) 中，使用 ‘clear’ 特性清除浮动后，浮动元素的容器若没有触发 hasLayout，则其背景将会丢失。</p>\n<blockquote>\n<p>解决办法：使丢失背景的容器触发 IE 浏览器特有的 hasLayout，如 ‘zoom:1’，或者设置宽度和高度。</p>\n</blockquote>\n</li>\n<li><p>8、在IE6 IE7 IE8(Q)中，如果 clear 特性被设置在一个浮动的元素上，该浮动元素会与其前边的浮动元素放置在同一行。位于其后的浮动元素的外顶边高于该元素的外顶边。</p>\n<blockquote>\n<p>解决办法：不要将 ‘clear’ 特性应用在浮动元素上，以免出现上述不兼容的问题。</p>\n</blockquote>\n</li>\n<li><p>9、IE6 IE7 IE8(Q) 中一些拥有默认上下外边距的块级元素（浏览器设置的）在浮动，或触碰到触发了 hasLayout 特性的容器后，上下外边距会消失。</p>\n<blockquote>\n<p>解决办法：用自定义的 ‘margin’ 取代浏览器的默认外边距样式。</p>\n</blockquote>\n</li>\n<li><p>10、IE 中触发了 hasLayout 的容器同时使用 ‘clear’ 特性清除浮动在某些情况下导致 ‘padding-top’ 渲染异常。</p>\n<blockquote>\n<p>解决办法：</p>\n<ul>\n<li>不触发容器的 hasLayout 特性；</li>\n<li>若容器触发了hasLayout 特性，尽量不为其设置 ‘padding-top’ 特性；</li>\n<li>若容器触发了hasLayout 特性，且必须为容器设置 ‘padding-top’ 特性，可以考虑使用 ‘:after’ 的清除方式。</li>\n</ul>\n</blockquote>\n</li>\n<li><p>11、Firefox 浏览器对 ‘display:table’ 中绝对定位元素包含块的判定有错误，可能会导致绝对定位元素位置跟其他浏览器中有差异。</p>\n<blockquote>\n<p>解决办法：这是 Firefox 的一个 bug，绝对定位元素无法根据 ‘display’ 特性是 ‘table’ 且是绝对定位的祖先元素定位。为达到相同的效果可以改变元素的 containing block 或者改变元素的定位方式。为达到相同的效果，可以采用如下方式替代：<br>改变元素的 containing block：让绝对定位元素相对于 TABLE 元素的单元格定位，即，在 TD 上设置 ‘position:absolute’ ；或者改变元素的定位方式：把绝对定位元素的 ‘absolute’ 改为 ‘relative’ ，用相对定位。</p>\n</blockquote>\n</li>\n<li><p>12、 IE6 IE7 IE8(Q) Firefox Opera 中若绝对定位元素没有设置其 ‘top’ 、 ‘right’ 、 ‘bottom’ 、 ‘left’ 特性，则这四个特性的值为默认的 ‘auto’ ，由于各浏览器对规范理解的差异，会导致页面布局差异。</p>\n<blockquote>\n<p>解决办法：首先对于绝对定位元素，应尽可能避免使其 ‘top’、’right’、’bottom’、’left’ 特性的值均为 ‘auto’。若必须这么做，则尽可能的保证绝对定位元素之前的兄弟元素为非浮动的块级元素。</p>\n</blockquote>\n</li>\n<li><p>13、IE6 IE7(Q) IE8(Q) 不支持固定定位（position:fixed）。</p>\n<blockquote>\n<p>解决办法：在 IE6 IE7(Q) IE8(Q) 中为固定定位元素设置 ‘position:absolute’，再通过 JavaScript 脚本或者 CSS Expression 动态设置其偏移量。参考代码如下：</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<pre><code>&lt;body style=&quot;font:12px Arial; _background-attachment:fixed; _background-image:url(about:blank);&quot;&gt;\n&lt;div style=&quot;width:10000px; height:10000px;&quot;&gt;&lt;/div&gt;\n&lt;div id=&quot;d&quot; style=&quot;position:fixed; top:0; left:0; _position:absolute; _top:expression(offsetParent.scrollTop); _left:expression(offsetParent.scrollLeft); background:#ddd; width:100px; height:100px;&quot;&gt;&lt;/div&gt;\n&lt;/body&gt;\n</code></pre><blockquote>\n<ul>\n<li><p>14、在 IE6 IE7 IE8(Q) 下，对于宽度超过容器的浮动元素，浏览器违背了浮动基本规则，导致其在浮动方向上溢出包含块。</p>\n<blockquote>\n<p>解决办法：当文字方向为 ‘ltr’ 时应避免使右浮动元素的宽度超出其包含块的宽度。同样地，当文字方向为 ‘rtl’ 时应避免使左浮动元素的宽度超出其包含块的宽度。</p>\n</blockquote>\n</li>\n<li><p>15、当定位元素的 ‘z-index’ 未设置时（默认为 auto），在 IE6 IE7 IE8(Q) 下将会创建一个新的局部层叠上下文。而在其它浏览器下，则严格按照规范，不产生新的局部层叠上下文。</p>\n<blockquote>\n<p>解决办法：理解层叠上下文、层叠级别与 ‘z-index’ 之间的关系。在可能出现定位元素相互覆盖的情况时，明确指定定位元素的 ‘z-index’ 特性，避免此问题的出现。</p>\n</blockquote>\n</li>\n<li><p>16、IE6 IE7 IE8(Q) 中溢出容器的浮动元素导致容器兄弟元素文本定位错误。</p>\n<blockquote>\n<p>解决办法：及时地为容器清除浮动，并且确保浮动元素没有溢出容器。</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>17、在 IE7(S) 中一个元素溢出的部分会被触发了 hasLayout 特性的元素遮盖。</p>\n<blockquote>\n<p>解决办法：合理设置元素的 ‘width’、’height’ 和 ‘overflow’ 特性，避免内容溢出容器。</p>\n</blockquote>\n</li>\n<li><p>18、在 IE6 IE7(Q) IE8(Q) 下，若包含块没有触发 hasLayout 特性，则其内参照其定位的绝对定位元素的偏移位置计算会出现问题。</p>\n<blockquote>\n<p>解决办法：使包含块触发 hasLayout 特性。如 ‘zoom:1’ 或者设置明确的宽度、高度。</p>\n</blockquote>\n</li>\n<li><p>19、IE6 IE7 IE8(Q) Firefox 不支持 ‘display:run-in’。</p>\n<blockquote>\n<p>解决办法：’display:run-in’ 特性目前用的地方不多，应用此特性的元素的最终状态 (inline-level 或 block-level) 要根据其上下文来判断，目前建议直接使用 ‘display:inline’ 或 ‘display:block’ 来固定元素的状态。</p>\n</blockquote>\n</li>\n<li><p>20、包含块是行内元素，行内元素的绝对定位子元素位置，在各浏览器有差异。</p>\n<blockquote>\n<p>解决办法：各浏览器对于行内元素的包含块范围计算有误，因此建议，应尽可能避免将行内元素边界作为计算包含块边界的情况出现。</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>21、在 IE6 IE7 IE8(Q) 中，TD/TH 及 TD 元素对设定 ‘position:relative’ 特性及偏移有效，其他均无效；<br>在 IE8(S) 中，TD/TH 及 CAPTION 元素及它们相对于 CSS 中 display 特性值对设定 ‘position:relative’ 特性及偏移有效，其他均无效；<br>在 Firefox 中，除 TABLE 之外的所有表格类元素以及它们相对于 CSS 中 display 特性值对设定 ‘position:relative’ 特性及偏移均无效<br>在 Chrome Safari 中，CAPTION 元素及它相对于 CSS 中 display 特性值 ‘caption’ 对设定 ‘position:relative’ 特性及偏移有效，其他均无效；<br>在 Opera 中，COL、COLGROUP 元素以及它们相对于 CSS 中 display 特性值对设定 ‘position:relative’ 特性及偏移无效，其他均有效。</p>\n<blockquote>\n<p>解决办法：由于除 TABLE 之外的表格类元素以及它们相对于 CSS 中 display 特性值设定了相对定位后的效果 CSS2.1 规范中没有明确定义，而各浏览器的实现又存在很大差异。所以应避免为这些元素设定 ‘position:relative’。若需要实现如冻结表格行或列的效果，可以考虑使用绝对定位其他 TABLE 元素的方式模拟。</p>\n</blockquote>\n</li>\n<li><p>22、在 Safari Chrome 等使用 webkit 渲染引擎的浏览器中，’float:center’ 是合法值，他等同于 ‘float:none’ 设置，而其他浏览器则认为 ‘float’ 特性中 ‘center’ 是个非法值，遵循规范应忽略此处的 ‘float’ 特性设置。</p>\n<blockquote>\n<p>解决办法：避免使用非法的 ‘float’ 特性值。</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<hr>\n<h1 id=\"六、渲染模型的细节\"><a href=\"#六、渲染模型的细节\" class=\"headerlink\" title=\"六、渲染模型的细节\"></a>六、渲染模型的细节</h1><blockquote>\n<ul>\n<li>1、如果一个页面使浏览器工作在混杂模式下，那么当给一个设置了 ‘padding’ 或 ‘border-width’ 的非替换元素设置 ‘width’ 或 ‘height’ 以控制其尺寸时，这个元素在 IE 和其他览器中的实际尺寸将是不同的。<blockquote>\n<p>解决办法：- 使用能触发标准模式 (S) 的 DTD</p>\n</blockquote>\n</li>\n<li>使用 CSS 3 的新特性：box-sizing</li>\n</ul>\n<ul>\n<li>2、在 IE6 IE7(Q) IE8(Q) 中，如果一个非替换元素的 ‘overflow’ 为 ‘visible’，当该元素无法完全容纳其非绝对定位的内容时，该元素的尺寸将被其内容撑大。<br>在上述情况发生时，为这个非替换元素设置的 ‘width’ 和 ‘height’ 与 CSS 2.1 中的 ‘min-width’ 和 ‘min-height’ 的作用类似：设定值不是最终的实际值，实际值可能更大。<blockquote>\n<p>解决办法：使用能触发标准模式 (S) 的 DTD，以将受此问题影响的浏览器的范围缩小到仅 IE6(S)。<br>如果不能保证一个希望尺寸固定的非替换元素总是能容纳其内容，请将该元素的 ‘overflow’ 设置为非 ‘visible’ 的值。</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li>3、在 IE6 IE7 IE8 中，’width’ 或 ‘height’ 任意一个或两个都设置为 ‘0’ 的 IFRAME 元素是不可见的，而在其它浏览器中这样设置后的 IFRAME 元素仍可见。<blockquote>\n<p>解决办法：根据实际情况选择使用 ‘visibility:hidden’ 或者 ‘display:none’ 隐藏 IFRAME 。</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>4、在 IE6 IE7 IE8(Q) 中，如果一个浮动元素的宽度是 shrink-to-fit，该元素的最终宽度可能比预期的小，并被尽可能的向上布局。</p>\n<blockquote>\n<p>解决办法：这个问题的影响较大，避免该问题的最直接的方式是给浮动非替换元素指定一个宽度，而不使用其默认值 ‘auto’，从而避免其宽度为 shrink-to-fit，以使页面布局在各浏览器中的表现一致。</p>\n</blockquote>\n</li>\n<li><p>5、在 Chrome Safari 中，若浮动元素之前存在一个非 inline 级元素（包括 block、table 等），且它们的包含块 ‘width’ 特性计算值为 auto，则包含块的 shrink-to-fit 宽度计算会出现错误。</p>\n<blockquote>\n<p>解决办法：在容器为绝对定位、浮动或行内块元素且没有明确设定宽度时，若浮动元素之前出现非 inline 级元素，则要小心这个元素对容器 shrink-to-fit 宽度的影响。可以为容器明确的设定一个宽度。</p>\n</blockquote>\n</li>\n<li><p>6、在 IE6 IE7 IE8(Q) 中，一个右浮动元素将尽可能的向右布局，并撑大其所有宽度为 ‘auto’ 的祖先级元素的宽度，直到遇到一个明确设定了宽度的祖先级元素为止。<br>注：这种现象仅在该元素有宽度为 shrink-to-fit 的的祖先级元素时才可以看到。</p>\n<blockquote>\n<p>解决办法：如果有一个右浮动元素，应注意避免其祖先级元素的宽度为 shrink-to-fit，即给它们设定一个明确的宽度。以使页面布局在各浏览器中的表现一致。</p>\n</blockquote>\n</li>\n<li><p>7、IE6 IE7 IE8 Opera 中对 shrink-to-fit 计算时会考虑浮动元素的宽度，这其中包含非替换浮动元素、非替换绝对定位元素、为替换行内块元素。</p>\n<blockquote>\n<p>解决办法：尽量为非替换浮动元素、非替换绝对定位元素、非替换行内块元素显式地设置一个宽度，防止浏览器在 ‘width:auto’ 时对于 shrink-to-fit 的宽度计算方式不同造成布局上的差异。</p>\n</blockquote>\n</li>\n<li><p>8、IE6 及 IE7/8 的混杂模式下，非替换绝度定位元素当指定了 ‘left’ 及 ‘right’，而 ‘width’ 为默认值 “auto” 。此时浏览器无法正确地计算出 ‘width’ 的值，对于高度的计算也是如此。</p>\n<blockquote>\n<p>解决办法：若能为非替换绝对定位元素设定固定的宽度及高度，则尽量不使用此方式自动计算绝对定位元素的 ‘width’ 及 ‘height’；若无法避免使用此方式，则可以通过判断浏览器，仅在 IE6 中使用 CSS Expression 控制绝对定位元素的宽度及高度。</p>\n</blockquote>\n</li>\n<li><p>9、IE6 IE7 IE8(Q) 在超过一个行内元素排列生成行框时，识别行框的顶边和底边位置时会参照文本实际高度的顶边和底边尺寸，而不是行框内最高行内框的顶边和最底行内框的底边位置。</p>\n<blockquote>\n<p>解决办法：为了取得正常布局，建议 ‘line-height’ 计算值设置永远大于 ‘font-size’ 计算值设置。</p>\n</blockquote>\n</li>\n<li><p>10、IE6 IE7(Q) IE8(Q)不支持 ‘min-width’ 和 ‘max-width’ 特性。</p>\n<blockquote>\n<p>解决办法：使用 Javascript 实现 ‘min-width’ 和 ‘max-width’ 特性功能。</p>\n</blockquote>\n</li>\n<li><p>11、IE6 IE7 IE8(Q) 中行内非替换元素中的非文本文字可能会撑高其高度。</p>\n<blockquote>\n<p>解决办法：针对不同的需求，可以采取不同的解决方案，例如，将外层的行内元素改为一个块级元素、给外层行内元素设置 ‘display:inline-block’、给外层行内元素设置合适的 ‘font-size’ 值等。</p>\n</blockquote>\n</li>\n<li><p>12、不同浏览器内 ‘line-height’ 样式设置会影响 INPUT BUTTON 元素的显示高度。</p>\n<blockquote>\n<p>解决办法：尽量避免使用 ‘line-height’ 为 INPUT[type=text]、INPUT[type=password]、INPUT[type=button]、INPUT[type=file]、input[type=submit] 和 BUTTON 标记设置 ‘line-height’，而应改用规范内说明的 ‘height’ 属性。</p>\n</blockquote>\n</li>\n<li><p>13、IE6 IE7 IE8(Q) 中触发 hasLayout 的空块级非替换元素的高度不为 0。</p>\n<blockquote>\n<p>解决办法：如果想让一个触发了 hasLayout 的块级非替换元素的高度为 0，可以给这个空的块级非替换元素增加一个空的注释块：</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<pre><code>&lt;div style=&quot;zoom:1&quot;&gt;&lt;!-- --&gt;&lt;/div&gt;\n</code></pre><p>另外，不让元素在 IE 中触发 hasLayout 也可以避免此 BUG 。</p>\n<blockquote>\n<ul>\n<li><p>14、IE 的混杂模式中行内非替换元素的宽高可设置。</p>\n<blockquote>\n<p>解决办法：在页面上添加&lt;!DOCTYPE HTML&gt;，使页面工作在标准模式下。</p>\n</blockquote>\n</li>\n<li><p>15、IE6 IE7(Q) IE8(Q) 不支持 ‘min-height’ 和 ‘max-height’ 特性。</p>\n<blockquote>\n<p>解决办法：使用 Javascript 实现 ‘min-height’ 和 ‘max-height’ 特性功能。</p>\n</blockquote>\n</li>\n<li><p>16、不同浏览器对单行文本输入框和显示为按钮的控件基线位置理解不同。</p>\n<blockquote>\n<p>解决办法：避免使用 ‘baseline’ 对齐方式，为元素指定 ‘vertical-align’ 值非 ‘baseline’，推荐使用 ‘vertical-align:bottom’ 或 ‘vertical-align:top’。</p>\n</blockquote>\n</li>\n<li><p>17、Webkit 浏览器下行框高度计算还依赖于 ‘font-size’ 属性值，在 ‘line-height’ 属性值明显小于 ‘font-size’ 属性值设置时，将导致实际计算出的行框高度大于其他浏览器。</p>\n<blockquote>\n<p>解决办法：为了取得正常布局，建议 ‘line-height’ 计算值永远大于 ‘font-size’ 计算值设置。</p>\n</blockquote>\n</li>\n<li><p>18、容器高度被明确设定，容器内容高度仅由行高累加决定的情况下，Safari Chrome 中容器元素的 ‘overflow’ 值为非默认值时，其最后一个内联子元素的半差异高度可能会被忽略。</p>\n<blockquote>\n<p>解决办法：为了准确得到容器高度，建议避免使用行高为行内元素指定高度，而应改用块标记，并且明确的指定其 ‘height’ 值。</p>\n</blockquote>\n</li>\n<li><p>19、对于行内元素绝对定位后静态位置中的 ‘top’ 特性的计算值，IE6 IE7 IE8(Q) 会将其计算为静态位置下 content area 距包含块顶边的距离（即半差异的高度），其他浏览器则计算为 0。</p>\n<blockquote>\n<p>解决办法：在使行内元素绝对定位的时候，要注意其行高对静态位置带来的影响，明确设置定位的元素偏移位置。</p>\n</blockquote>\n</li>\n<li><p>20、在非标准文档模式中（包括混杂模式和近乎标准模式），当唯一的非表单控件类行内替换元素存在于其包容块中时，其父框的行高并不一定会计算文本基线高度。</p>\n<blockquote>\n<p>解决办法：如果在非标准模式中，需要父容器在仅有行内替换元素的情况下计算出包含文本基线高度的行高值，则必须加入其他行内文本元素。相反的，如果在标准模式中，需要行内替换元素与其父容器底部无间隙，请修改 ‘vertical-align’ 值为非 ‘baseline’ 。</p>\n</blockquote>\n</li>\n<li><p>21、若容器中包含 MARQUEE 元素，且容器遵循 shrink-to-fit 宽度算法，则容器及 MARQUEE 元素的宽度在不同浏览器中存在差异。</p>\n<blockquote>\n<p>解决办法：给 MARQUEE 元素及替换元素定义具体的宽度，保证各浏览器兼容。</p>\n</blockquote>\n</li>\n<li><p>22、对于宽度为 0% 的 IMG 元素的包含块的 shrink-to-fit 算法，Firefox Chrome Safari 与 IE6 IE7 IE8 Opera 存在差异。</p>\n<blockquote>\n<p>解决办法：尽量避免设置 IMG 元素的宽度为 0%，可以用 0px 替代。</p>\n</blockquote>\n</li>\n<li><p>23、IE6 IE7(Q) IE8(Q) 中，如果父需要使用 shrink-to-fit 算法，并且其子元素触发了 hasLayout 特性以及 ‘width’ 特性值为默认的 ‘auto’，那么会导致父元素 shrink-to-fit 计算值有误。</p>\n<blockquote>\n<p>解决办法：由于在 IE 浏览器中很难避免不触发 hasLayout 特性，因此建议在使用 ‘float’ ‘position:absolute’ 这两个样式时，为 ‘width’ 特性设置具体值。这样可以从根源上避免触发 shrink-to-fit 计算规则，由此来规避 IE6 IE7(Q) IE8(Q) 中由于 hasLayout 特性带来的渲染问题。</p>\n</blockquote>\n</li>\n<li><p>24、在 IE7(S) Firefox 中，若元素的高度出于某种原因使用了其 ‘min-height’ 或 ‘max-height’ 设定的值，则其生成的包含块的高度为元素的实际高度；而在 IE8(S) Chrome Safari Opera 中，生成的包含块的高度仍然为元素原始的高度。</p>\n<blockquote>\n<p>解决办法：在子孙元素参照设定并在计算值上应用了 ‘min-height’、’max-height’ 特性的元素生成的包含块的高度时需格外注意，此时尽量避免使用百分比等需要参照包含块计算的单位。</p>\n</blockquote>\n</li>\n<li><p>25、当采用如下布局方法时，各浏览器可能会造成 shrink-to-fit 计算规则处理差异：<br>1.父元素采用浮动或绝对定位样式，宽度值为 ‘auto’；<br>2.子元素存在两个以上连续的行内元素；<br>3.两个行内元素之间存在空文本节点而非标记首尾紧密相连；<br>4.第二个行内元素采用绝对定位样式，且 ‘top’ ‘left’ ‘bottom’ ‘right’ 都为 ‘auto’ 。<br>此时，Safari 和 Chrome 中的父元素采用 shrink-to-fit 计算规则时，可能使用了 preferred minimum width 来作为 preferred width ，导致在空文本节点处产生换行，使依赖元素普通流位置的绝对定位元素显示位置产生差异。</p>\n<blockquote>\n<p>解决办法：建议在使用 ‘float’ ‘position:absolute’ 这两个样式时，为 ‘width’ 特性设置具体值。这样可以从根源上避免触发 shrink-to-fit 计算规则带来的差异。</p>\n</blockquote>\n</li>\n<li><p>26、各浏览器对于未明确设定高度的包含块内包含百分比单位高度的块级元素的高度计算存在差异。</p>\n<blockquote>\n<p>解决办法：要对设置有百分比高度的块级元素的包含块设置明确的 ‘height’ 属性值。</p>\n</blockquote>\n</li>\n<li><p>27、当 IMG 元素没有设置 ‘width’ 特性且设置了值单位为百分比的 ‘min-width’ 或 ‘max-width’ 特性， 则在各浏览器中该 IMG 元素的包含块的 ‘shrink-to-fit’ 算法存在差异。</p>\n<blockquote>\n<p>解决办法：在包含块的宽度计算需要依赖其内 IMG 元素时，尽量避免给 IMG 元素的 ‘min-width’ 和 ‘max-width’ 特性设置百分比单位的值。</p>\n</blockquote>\n</li>\n<li><p>28、在正常文档流中，当包含块宽度为 0，其内未设定明确宽度的块级元素由于设定了 ‘margin’ 溢出包含块时，则该块级元素的宽度计算在 Chrome Safari 中会计算为 0。</p>\n<blockquote>\n<p>解决办法：尽量避免出现未明确设定宽度 (值为 ‘auto’) 的块级元素由于设定了 ‘margin’ 导致其溢出其宽度为 0 的包含块，应为其设定一个明确的宽度。</p>\n</blockquote>\n</li>\n<li><p>29、当页面中存在一个空的非替换行内元素时，如果给这个元素设置了边框或者背景样式，那么在 IE6 IE7 IE8(Q) 中这些样式将无法显示出来。</p>\n<blockquote>\n<p>解决办法：应尽量避免使用的空的非替换行内元素，以及避免为空元素添加显示用样式。</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<hr>\n<h1 id=\"七、可视效果\"><a href=\"#七、可视效果\" class=\"headerlink\" title=\"七、可视效果\"></a>七、可视效果</h1><blockquote>\n<ul>\n<li>1、当一个元素的 ‘overflow-x’ 或 ‘overflow-y’ 指定值为 ‘hidden’，另一个特性的指定值为 ‘visible’ 时， 该元素最终渲染使用的 ‘overflow-y’ 或 ‘overflow-x’ 值不同。IE6 IE7 IE8 使用 ‘hidden’，其它浏览器使用 ‘auto’。<blockquote>\n<p>解决办法：</p>\n</blockquote>\n</li>\n<li>同时设置 ‘overflow-x’ 和 ‘overflow-y’ 的值，不要出现其中之一为 ‘hidden’ 时，而另一个是 ‘visible’ 的情况；</li>\n<li><p>避免编写依赖指定值为 ‘visible’ 的 ‘overflow-x’ 和 ‘overflow-y’ 特性的计算值的代码。</p>\n</li>\n<li><p>2、在 IE6(S) IE7(S) 中，若一个 ‘overflow’ 特性不为 ‘visible’ 的非定位元素内包含了可能溢出其的相对定位元素，则溢出部分不会被剪裁。<br>在 IE6(Q) IE7(Q) IE8(Q) 中，若一个 ‘overflow’ 特性不为 ‘visible’ 的非定位元素内包含可能其溢出的绝对定位元素，则仍然会剪裁溢出的绝对定位元素。</p>\n<blockquote>\n<p>解决办法：根据实际需求可以去掉包含块的 ‘overflow:hidden’ 或采用其他定位方案，避免在 IE 中触发此问题，实现在各浏览器表现一致。</p>\n</blockquote>\n</li>\n<li><p>3、在 IE6 IE7 IE8 中，若在同一条规则中同时首先定义了 ‘overflow-x’ 或 ‘overflow-y’ 特性，然后又定义了 ‘overflow’ 特性，则作为简写的 ‘overflow’ 特性的值不会覆盖之前的 ‘overflow-x’ 或 ‘overflow-y’ 特性的值。</p>\n<blockquote>\n<p>解决办法：根据实际需求尽可能同时设定明确的 ‘overflow-x’ 以及 ‘overflow-y’ 特性，或者直接使用简写的 ‘overflow’，避免在同一条 CSS 规则内在 ‘overflow-x’ 或 ‘overflow-y’ 特性之后再定义 ‘overflow’ 特性。</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<hr>\n<h1 id=\"未完待续\"><a href=\"#未完待续\" class=\"headerlink\" title=\" - 未完待续\"></a> - 未完待续</h1>","excerpt":"<p>不同浏览器的兼容问题一直是前端开发工程师最头疼的问题，本系列文章记录一些常见和不常见的兼容性问题，因为兼容性问题太多了，所以内容可能有些杂乱，涉及的方面也肯定非常广,这里大多数只叙述问题和解决办法，而不细说原理，想了解原理的可以自行在网上查找。下面开始正文，本系列先从CSS开始。<br>","more":"</p>\n<hr>\n<h1 id=\"一：语法和基本数据类型\"><a href=\"#一：语法和基本数据类型\" class=\"headerlink\" title=\"一：语法和基本数据类型\"></a>一：语法和基本数据类型</h1><blockquote>\n<ul>\n<li>1、@charset 一定要放在样式表的最前面，否则在 Chrome和Safari中，@charset后面的规则集(样式)将失效。</li>\n<li>2、如果一个外部 CSS 文件的编码与引入该文件的 HTML 文件的编码不一致，并且没有显式的声明该 CSS 文件的编码，在某些情况下会造成 CSS 的解析错误。解决办法：统一编码。</li>\n</ul>\n</blockquote>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">h1</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">margin</span>:<span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">100px</span>;</div><div class=\"line\">  <span class=\"attribute\">height</span>:<span class=\"number\">100px</span>;</div><div class=\"line\">  <span class=\"attribute\">background</span>:blue;</div><div class=\"line\">  <span class=\"attribute\">font</span>:<span class=\"number\">20px</span>/<span class=\"number\">100px</span> <span class=\"string\">\"黑体\"</span>;</div><div class=\"line\">  <span class=\"attribute\">text-decoration</span>:underline;</div><div class=\"line\">  <span class=\"attribute\">color</span>:red;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果上述CSS文件编码为GB2312，而引入的页面编码为UTF-8，在IE6中会从“黑体”往后的所有都被忽略（包括“黑体”），在其他浏览器只会将“黑体”忽略。<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/CSS兼容性1.png\" alt=\"CSS兼容性\"><br>解决办法之一就是在CSS文件头部添加@charset “UTF-8”。</p>\n<blockquote>\n<ul>\n<li>3、url中出现空白，在大部分浏览器中无法正确读取地址。但是IE6和IE7可以识别(经测试IE6/7也只能识别TAB和回车，空格也识别不出)。解决办法：避免url中出现空白。</li>\n</ul>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"css\"></div><div class=\"line\">\t<span class=\"selector-tag\">div</span><span class=\"selector-class\">.text</span> &#123; <span class=\"attribute\">font-size</span>:<span class=\"number\">40px</span>; <span class=\"attribute\">float</span>:left; <span class=\"attribute\">border</span>:<span class=\"number\">1px</span> solid black; <span class=\"attribute\">color</span>:navy; &#125;</div><div class=\"line\">\t<span class=\"selector-id\">#text2</span> &#123; <span class=\"attribute\">background-image</span>:<span class=\"built_in\">url</span>(go    ogle.</div><div class=\"line\">\tgif); &#125;</div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">body</span> <span class=\"attr\">style</span>=<span class=\"string\">\"font:12px/1.2 'Trebuchet MS';\"</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"text1\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"background-image:url(goo  gle_s</div><div class=\"line\">\tmall.gif);\"</span>&gt;</span>some text 1<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">br</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span> /&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"text2\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"text\"</span>&gt;</span>some text 2<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/CSS兼容性2.png\" alt=\"CSS兼容性\"></p>\n<blockquote>\n<ul>\n<li>4、正确地使用 CSS 的空白字符，避免使用表意空格 (U+3000)（表意空格（Ideographic Space），也可以叫全角空格（Full-width Space），对应的 HTML 实体字符为“&amp;#12288”。在相同的等宽中文字体下，全角空格的宽度与普通汉字的宽度相等）。这个不一一列举了，每个浏览器支持情况不同，避免使用就好。</li>\n</ul>\n</blockquote>\n<hr>\n<h1 id=\"二：选择器\"><a href=\"#二：选择器\" class=\"headerlink\" title=\"二：选择器\"></a>二：选择器</h1><blockquote>\n<ul>\n<li>1、IE6/IE7(Q)/IE8(Q)中不支持子选择器(如 ul&gt;li)、兄弟选择器(如 div+p)、属性选择器([att]、[att=val]、[att~=val]、[att|=val])、 ‘:first-child’伪元素，避免在上述情况使用。</li>\n<li>2、a标签的四个常用的伪类：’:link’、’:visited’、’:hover’、’:active’,使用的顺序一定要是：L-V-H-A 来排序，虽然这一问题在IE6/IE7(Q)/IE8(Q)没有影响，但是其它的浏览器还是会有各种问题。</li>\n<li>3、IE6/IE7(Q)/IE8(Q)中不支持a元素以外的元素使用’:hover’伪类。<blockquote>\n<p>解决办法：使用 JavaScript 绑定 ‘onmouseover’ 和 ‘onmouseout’（模仿 ‘:hover’）；使用 Whatever:hover 插件，该插件利用 IE 特有的 CSS 行为（behavior）及通过 JavaScript 来模拟 ‘:hover’ 伪类的效果。</p>\n</blockquote>\n</li>\n<li>4、IE6/IE7/IE8(Q)中不支持a元素以外的元素使用’:active’伪类。<blockquote>\n<p>解决办法：使用 JavaScript 绑定 ‘onmousedown’ 和 ‘onmouseup’（模仿 ‘:active’）；同样的你可以使用 Whatever:hover 插件。</p>\n</blockquote>\n</li>\n<li>5、IE6/IE7/IE8(Q)不支持’:focus’伪类。<blockquote>\n<p>解决办法：使用 JavaScript 绑定 onfocus onblur 事件模仿 ‘:focus’效果；<br>或者使用 Whatever:hover。</p>\n</blockquote>\n</li>\n<li>6、IE6/IE7/IE8(Q)不支持 ‘:before’ 和 ‘:after’ 伪元素    <blockquote>\n<p>解决办法：使用 JavaScript 判断 IE6 IE7 IE8(Q) 并在其中通过脚本实现 ‘:before’ 及 ‘:after’ 伪元素的效果；使用 jQuery 的插件 Pseudo Plugin，该组件利用 IE 特有的 CSS 行为（behavior）及 CSS 表达式来模拟 ‘:before’ 及 ‘:after’ 伪元素的效果。</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<hr>\n<h1 id=\"三、指定特性值，层叠和继承\"><a href=\"#三、指定特性值，层叠和继承\" class=\"headerlink\" title=\"三、指定特性值，层叠和继承\"></a>三、指定特性值，层叠和继承</h1><blockquote>\n<ul>\n<li>1、IE6/IE7/IE8/Opera 中不支持’inherit’这个继承属性。</li>\n</ul>\n</blockquote>\n<p>IE8(S)中，块级元素无法通过设置’display:inherit’、特性值，显式性继承绝大部分行内元素的默认’display’特性值，但却可以显示性继承 BUTTON 元素的默认 ‘display’ 特性。在Opera 中，P 元素无法通过设置 ‘border:inherit’ 特性值，显式性继承 BUTTON 元素的默认 ‘border’ 特性。<br>解决办法：<br>使用标准模式渲染页面；<br>在 IE6 IE7 退出舞台之前避免使用 ‘inherit’ 值显式性的继承样式设定；<br>在 IE8 内不使用 ‘inherit’ 值显式性继承行内元素的默认 ‘display’ 特性值；<br>在 Opera 内，不对使用 ‘inherit’ 值显式性继承 BUTTON 元素默认 ‘border’ 特性值。</p>\n<blockquote>\n<ul>\n<li>2、在 Chrome 和 Safari 中，默认样式下的 B、STRONG 元素的 ‘font-weight’ 特性计算值可能会受到其继承来的 ‘font-weight’ 特性影响，在 IE8(S) 中，除 B、STRONG 外，H1~H6、TH 元素的’font-weight’特性也会受影响。在其他浏览器中，则完全不受影响。<blockquote>\n<p>解决办法：尽量为元素设置绝对明确的 ‘font-weight’ 特性的值，避免使用 bolder、lighter 这类相对量以及浏览器的默认样式。</p>\n</blockquote>\n</li>\n<li>3、 IE6 IE7(Q) IE8(Q) 不完全支持 !important 规则。不支持位于同一个选择器内的 ‘!important’ 规则。</li>\n</ul>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span>&gt;</span><span class=\"css\"></div><div class=\"line\">    <span class=\"selector-tag\">div</span>&#123;</div><div class=\"line\">        <span class=\"attribute\">width</span>:<span class=\"number\">100px</span>;</div><div class=\"line\">        <span class=\"attribute\">height</span>:<span class=\"number\">30px</span>;</div><div class=\"line\">        <span class=\"attribute\">background-color</span>:gold <span class=\"meta\">!important</span>;</div><div class=\"line\">        <span class=\"attribute\">background-color</span>:silver;</div><div class=\"line\">    &#125;</div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/CSS兼容性3.png\" alt=\"CSS兼容性\"><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"css\"></div><div class=\"line\">  <span class=\"selector-class\">.c1</span> &#123; <span class=\"attribute\">background</span>:blue <span class=\"meta\">!important</span>; &#125;</div><div class=\"line\">  <span class=\"selector-class\">.c2</span> &#123; <span class=\"attribute\">background</span>:green; &#125;</div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"width:100px; height:100px;\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"c1 c2\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure><br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/CSS兼容性4.png\" alt=\"CSS兼容性\"></p>\n<p>解决办法：这是浏览器的 Bug 导致，无法通过常规方式解决。不过，一般 ‘!important’ 规则常常用于 CSS hack 以区分 IE6 与其他浏览器，其作为 hack 存在的意义已大于其本身的含义。</p>\n<hr>\n<h1 id=\"四、盒模型\"><a href=\"#四、盒模型\" class=\"headerlink\" title=\"四、盒模型\"></a>四、盒模型</h1><blockquote>\n<ul>\n<li>1、IE6 IE7 IE8(Q) 负边距 (margin) 导致元素溢出 hasLayout 容器时显示异常。<blockquote>\n<p>解决办法：在确保元素的容器触发 hasLayout 的前提下，为该元素同时设置 ‘position:relative’ 和 ‘zoom:1’。<br>首先需要保证容器在IE中触发 hasLayout 属性，可以通过zoom:1实现。在 IE7(S) 中，当使设置了负值 ‘margin’ 的元素的 hasLayout 属性为 ‘true’ ，即触发该元素的hasLayout特性后，此Bug现象消失，例如为该元素设置宽度或高度，或者在完全不影响该元素盒模型的情况下使用zoom:1 来触发 hasLayout 从而消除此 Bug 。在 IE6 IE7(Q) IE8(Q) 中，仅仅触发 hasLayout 特性并不一定能消除此 Bug ，同时还需要为该元素设置 ‘position:relative’，即在完全不影响该元素盒模型的情况下使用 zoom:1 ‘position:relative’ 。</p>\n</blockquote>\n</li>\n<li>2、Chrome Safari ，在 WebKit 内核的浏览器中，当元素满足三个条件时，宽度计算不符合规范：<br>元素的兄弟元素是浮动元素；元素的 ‘width’ 特性值为 ‘auto’，’overflow’ 特性值不是 ‘visible’；元素设置了与浮动同方向的 ‘margin’ 值(如：当 ‘float:left’ 时，设置 ‘margin-left’ 值，当 ‘float:right’ 时，设置 ‘margin-right’)。<blockquote>\n<p>解决办法：</p>\n<ul>\n<li>为该创建了 BFC 的元素设置一个明确的宽度; </li>\n<li>如果 ‘margin’ 值不小于浮动元素的 margin box 的宽时，去掉’overflow:hidden’。</li>\n</ul>\n</blockquote>\n</li>\n<li>3、Firefox 中 ‘display:table’ 的元素的外边距不会与包含块的外边距折叠(也就是margin塌陷)。</li>\n</ul>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"background:gold;\"</span>&gt;</span>Top line<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"background:gray; width:300px; margin:20px 0;\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">table</span> <span class=\"attr\">cellpadding</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">cellspacing</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"background:pink; width:200px; margin:10px 0;\"</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>TD<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"background:gold;\"</span>&gt;</span>Bottom line<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/CSS兼容性5.png\" alt=\"CSS兼容性\"></p>\n<blockquote>\n<blockquote>\n<p>解决办法：由于 IE6 IE7 IE8(Q) Firefox 元素的 ‘margin’ 处理与 W3C 规范中的差异，若我们需要利用 “margin collapse” 达到某些布局效果时，在这几种浏览器中可能会由于没有发生 “margin collapse” 而出现 “额外边距” 的情况。所以应避免为表格设置上下边距，以及导致其 “margin collapse” 的发生，可以使用为表格的父元素使用 ‘padding’ 代替表格元素的 ‘margin’ 。</p>\n</blockquote>\n<ul>\n<li>4、IE6 IE7 IE8(Q) 中浮动元素和定位元素某些情况下会影响普通流中毗邻 ‘margin’ 的折叠。<blockquote>\n<p>解决办法：</p>\n<ul>\n<li>根据具体需求，调整 ‘margin’ 的位置和大小；</li>\n<li>使用 CSS hack 设置 IE 中的 ‘margin’ 大小，以避免 IE 跟其他浏览器的布局差异。</li>\n</ul>\n</blockquote>\n</li>\n<li>5、在 IE6 IE7 IE8(Q)下，容器触发 hasLayout 导致其左浮动子元素 ‘margin-bottom’ 消失。</li>\n</ul>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>content_text<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"zoom:1; overflow:hidden; background:lightgrey;\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"float:left; width:50px; height:50px; margin:20px; background:dimgray;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>content_text<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/CSS兼容性6.png\" alt=\"CSS兼容性\"></p>\n<blockquote>\n<blockquote>\n<p>解决办法：为容器显式地设置高度。若容器高度不定，则要避免在触发了 hasLayout 的容器内的浮动子元素上设置 ‘margin-bottom’ 特性，可以通过为容器设置 ‘padding-bottom’ 达到相似的效果。只要不同时触发父元素hasLayout、子元素左浮动、左浮动子元素拥有非零的 margin-bottom 值，这三个条件中任意一项，均可解决此问题。</p>\n</blockquote>\n<ul>\n<li>6、IE6 IE7 IE8(Q) 中，若一个触发了 hasLayout 的元素其内第一个非空白节点 (即 children[0]) 为 TEXTAREA 元素 或者 type 属性值为 text、password、submit、reset、button、file 的 INPUT 元素，并且这个元素设定了 ‘margin-left’、’margin-right’ 特性，则 ‘margin-left’、’margin-right’ 特性指定的值会应用于其相应方向的 padding 上。<blockquote>\n<p>解决办法：在 INPUT、TEXTAREA 元素之前放一个触发了 hasLayout 的空 SPAN 元素。</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<hr>\n<h1 id=\"五、渲染模型\"><a href=\"#五、渲染模型\" class=\"headerlink\" title=\"五、渲染模型\"></a>五、渲染模型</h1><blockquote>\n<ul>\n<li><p>1、各浏览器对 ‘display’ 特性值的支持程度不同。</p>\n<blockquote>\n<p>解决办法：尽量仅使用所有浏览器都支持的 ‘display’ 特性值：’inline’、’block’、’list-item’、’none’。在 IE6 IE7 IE8(Q) 中实现块元素的 ‘display:inline-block’ 特性值支持，需要先将块元素设置为行内元素，并设置可以在 IE6 IE7 IE8(Q) 内触发 haslayout 特性的专有特性 ‘zoom:1’。行内元素实现 ‘display:inline-block’ 特性值支持只需直接设置此特性值或同样使用 ‘zoom:1’ 即可。</p>\n</blockquote>\n</li>\n<li><p>2、在IE早期版本中的元素触发了haslayout，但是没有触发BFC，会导致在IE和其它浏览器中的布局有差异。（如何触发haslayout和BFC在这里不细说）</p>\n<blockquote>\n<p>解决办法：仅当一个元素即在 IE 早期版本中触发了 hasLayout，又在其他浏览器中创建了 block formatting context 时，才能避免上述问题的发生。即同时启用上述两者以保证各浏览器的兼容，或者相反，两者皆不启用。</p>\n</blockquote>\n</li>\n<li><p>3、BFC在各浏览器中的问题：<br>1.当容器有足够的剩余空间容纳 BFC 的宽度时，所有浏览器都会将 BFC 放置在浮动元素所在行的剩余空间内。<br>2.在 IE6 IE7 IE8 Chrome Opera 中，当 BFC 的宽度介于 “容器剩余宽度” 与 “容器宽度” 之间时，BFC 会显示在浮动元素的下一行；在 Safari 中，BFC 则仍然保持显示在浮动元素所在行，并且 BFC 溢出容器；在 Firefox 中，当容器本身也创建了 BFC 或者容器的 ‘padding-top’、’border-top-width’ 这些特性不都为 0 时表现与 IE8(S)、Chrome 类似，否则表现与 Safari 类似。<br>3.在 IE6 IE7 IE8 Opera 中，当 BFC 的宽度大于 “容器宽度” 时，BFC 会显示在浮动元素的下一行；在 Chrome Safari 中，BFC 则仍然保持显示在浮动元素所在行，并且 BFC 溢出容器；在 Firefox 中，当容器本身也创建了 BFC 或者容器的 ‘padding- top’、’border-top-width’ 这些特性不都为 0 时表现与 IE8(S) 类似，否则表现与 Chrome 类似。</p>\n<blockquote>\n<p>解决办法：合理地设置容器的宽度、浮动元素的宽度、BFC 的宽度的值，尽量保证 BFC 的宽度小于 “容器的剩余空间宽度” 。若需要 BFC 折行显示在新的一行上，可以通过 BFC 设置 ‘clear’ 特性等手段使其换行。</p>\n</blockquote>\n</li>\n<li><p>4、在 IE6 IE7 IE8(Q) 中，一个零高度的浮动元素仍能阻挡与其向相同方向浮动的兄弟元素。</p>\n<blockquote>\n<p>解决办法：如果希望一个浮动元素能阻挡与其向相同方向浮动的兄弟元素，请确保其高度不为零；否则，请隐藏该元素，以使页面布局在各浏览器中的表现一致。</p>\n</blockquote>\n</li>\n<li><p>5、IE6 IE7 IE8(Q) 下，若浮动元素之前存在兄弟行内非浮动元素，IE 会将浮动元素所在的“当前行”认为是其前边的兄弟行内元素所产生的匿名框的底边，导致该浮动元素折行。</p>\n<blockquote>\n<p>解决办法：依具体情况可以使用三种方法：使用绝对定位模拟右浮动、使用 IE hack 专门在IE6 IE7 中设置负的上外边距、将右浮动的 SPAN 元素调整到所有非浮动 SPAN 元素之前。</p>\n</blockquote>\n</li>\n<li><p>6、在 IE6 IE7 IE8(Q) 下，为 ‘clear’ 元素设置负的 ‘margin-top’ 时， ‘clear’ 元素的顶部 ‘border-box’ 出现在了其之前浮动元素的底部 ‘margin-box’ 之上。</p>\n<blockquote>\n<p>解决办法：尽量避免为 ‘clear’ 特性不为 none 的元素（即清理元素）设置 ‘margin-top’ 特性，尤其是负值。若需要为该元素设置正的 ‘margin-top’ 特性，可以将 ‘clear’ 元素当做容器，在其内部加入设置了 ‘margin-top’ 的元素。若需要为该元素设置负的 ‘margin-top’ ，可以为浮动元素设置负的 ‘margin-bottom’ 以缩小其 ‘margin-box’ ，提高了其底部 ‘margin-box’ 的位置，从而使 ‘clear’ 元素可以产生向上移动的效果。</p>\n</blockquote>\n</li>\n<li><p>7、IE6 IE7 IE8(Q) 中，使用 ‘clear’ 特性清除浮动后，浮动元素的容器若没有触发 hasLayout，则其背景将会丢失。</p>\n<blockquote>\n<p>解决办法：使丢失背景的容器触发 IE 浏览器特有的 hasLayout，如 ‘zoom:1’，或者设置宽度和高度。</p>\n</blockquote>\n</li>\n<li><p>8、在IE6 IE7 IE8(Q)中，如果 clear 特性被设置在一个浮动的元素上，该浮动元素会与其前边的浮动元素放置在同一行。位于其后的浮动元素的外顶边高于该元素的外顶边。</p>\n<blockquote>\n<p>解决办法：不要将 ‘clear’ 特性应用在浮动元素上，以免出现上述不兼容的问题。</p>\n</blockquote>\n</li>\n<li><p>9、IE6 IE7 IE8(Q) 中一些拥有默认上下外边距的块级元素（浏览器设置的）在浮动，或触碰到触发了 hasLayout 特性的容器后，上下外边距会消失。</p>\n<blockquote>\n<p>解决办法：用自定义的 ‘margin’ 取代浏览器的默认外边距样式。</p>\n</blockquote>\n</li>\n<li><p>10、IE 中触发了 hasLayout 的容器同时使用 ‘clear’ 特性清除浮动在某些情况下导致 ‘padding-top’ 渲染异常。</p>\n<blockquote>\n<p>解决办法：</p>\n<ul>\n<li>不触发容器的 hasLayout 特性；</li>\n<li>若容器触发了hasLayout 特性，尽量不为其设置 ‘padding-top’ 特性；</li>\n<li>若容器触发了hasLayout 特性，且必须为容器设置 ‘padding-top’ 特性，可以考虑使用 ‘:after’ 的清除方式。</li>\n</ul>\n</blockquote>\n</li>\n<li><p>11、Firefox 浏览器对 ‘display:table’ 中绝对定位元素包含块的判定有错误，可能会导致绝对定位元素位置跟其他浏览器中有差异。</p>\n<blockquote>\n<p>解决办法：这是 Firefox 的一个 bug，绝对定位元素无法根据 ‘display’ 特性是 ‘table’ 且是绝对定位的祖先元素定位。为达到相同的效果可以改变元素的 containing block 或者改变元素的定位方式。为达到相同的效果，可以采用如下方式替代：<br>改变元素的 containing block：让绝对定位元素相对于 TABLE 元素的单元格定位，即，在 TD 上设置 ‘position:absolute’ ；或者改变元素的定位方式：把绝对定位元素的 ‘absolute’ 改为 ‘relative’ ，用相对定位。</p>\n</blockquote>\n</li>\n<li><p>12、 IE6 IE7 IE8(Q) Firefox Opera 中若绝对定位元素没有设置其 ‘top’ 、 ‘right’ 、 ‘bottom’ 、 ‘left’ 特性，则这四个特性的值为默认的 ‘auto’ ，由于各浏览器对规范理解的差异，会导致页面布局差异。</p>\n<blockquote>\n<p>解决办法：首先对于绝对定位元素，应尽可能避免使其 ‘top’、’right’、’bottom’、’left’ 特性的值均为 ‘auto’。若必须这么做，则尽可能的保证绝对定位元素之前的兄弟元素为非浮动的块级元素。</p>\n</blockquote>\n</li>\n<li><p>13、IE6 IE7(Q) IE8(Q) 不支持固定定位（position:fixed）。</p>\n<blockquote>\n<p>解决办法：在 IE6 IE7(Q) IE8(Q) 中为固定定位元素设置 ‘position:absolute’，再通过 JavaScript 脚本或者 CSS Expression 动态设置其偏移量。参考代码如下：</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<pre><code>&lt;body style=&quot;font:12px Arial; _background-attachment:fixed; _background-image:url(about:blank);&quot;&gt;\n&lt;div style=&quot;width:10000px; height:10000px;&quot;&gt;&lt;/div&gt;\n&lt;div id=&quot;d&quot; style=&quot;position:fixed; top:0; left:0; _position:absolute; _top:expression(offsetParent.scrollTop); _left:expression(offsetParent.scrollLeft); background:#ddd; width:100px; height:100px;&quot;&gt;&lt;/div&gt;\n&lt;/body&gt;\n</code></pre><blockquote>\n<ul>\n<li><p>14、在 IE6 IE7 IE8(Q) 下，对于宽度超过容器的浮动元素，浏览器违背了浮动基本规则，导致其在浮动方向上溢出包含块。</p>\n<blockquote>\n<p>解决办法：当文字方向为 ‘ltr’ 时应避免使右浮动元素的宽度超出其包含块的宽度。同样地，当文字方向为 ‘rtl’ 时应避免使左浮动元素的宽度超出其包含块的宽度。</p>\n</blockquote>\n</li>\n<li><p>15、当定位元素的 ‘z-index’ 未设置时（默认为 auto），在 IE6 IE7 IE8(Q) 下将会创建一个新的局部层叠上下文。而在其它浏览器下，则严格按照规范，不产生新的局部层叠上下文。</p>\n<blockquote>\n<p>解决办法：理解层叠上下文、层叠级别与 ‘z-index’ 之间的关系。在可能出现定位元素相互覆盖的情况时，明确指定定位元素的 ‘z-index’ 特性，避免此问题的出现。</p>\n</blockquote>\n</li>\n<li><p>16、IE6 IE7 IE8(Q) 中溢出容器的浮动元素导致容器兄弟元素文本定位错误。</p>\n<blockquote>\n<p>解决办法：及时地为容器清除浮动，并且确保浮动元素没有溢出容器。</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>17、在 IE7(S) 中一个元素溢出的部分会被触发了 hasLayout 特性的元素遮盖。</p>\n<blockquote>\n<p>解决办法：合理设置元素的 ‘width’、’height’ 和 ‘overflow’ 特性，避免内容溢出容器。</p>\n</blockquote>\n</li>\n<li><p>18、在 IE6 IE7(Q) IE8(Q) 下，若包含块没有触发 hasLayout 特性，则其内参照其定位的绝对定位元素的偏移位置计算会出现问题。</p>\n<blockquote>\n<p>解决办法：使包含块触发 hasLayout 特性。如 ‘zoom:1’ 或者设置明确的宽度、高度。</p>\n</blockquote>\n</li>\n<li><p>19、IE6 IE7 IE8(Q) Firefox 不支持 ‘display:run-in’。</p>\n<blockquote>\n<p>解决办法：’display:run-in’ 特性目前用的地方不多，应用此特性的元素的最终状态 (inline-level 或 block-level) 要根据其上下文来判断，目前建议直接使用 ‘display:inline’ 或 ‘display:block’ 来固定元素的状态。</p>\n</blockquote>\n</li>\n<li><p>20、包含块是行内元素，行内元素的绝对定位子元素位置，在各浏览器有差异。</p>\n<blockquote>\n<p>解决办法：各浏览器对于行内元素的包含块范围计算有误，因此建议，应尽可能避免将行内元素边界作为计算包含块边界的情况出现。</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>21、在 IE6 IE7 IE8(Q) 中，TD/TH 及 TD 元素对设定 ‘position:relative’ 特性及偏移有效，其他均无效；<br>在 IE8(S) 中，TD/TH 及 CAPTION 元素及它们相对于 CSS 中 display 特性值对设定 ‘position:relative’ 特性及偏移有效，其他均无效；<br>在 Firefox 中，除 TABLE 之外的所有表格类元素以及它们相对于 CSS 中 display 特性值对设定 ‘position:relative’ 特性及偏移均无效<br>在 Chrome Safari 中，CAPTION 元素及它相对于 CSS 中 display 特性值 ‘caption’ 对设定 ‘position:relative’ 特性及偏移有效，其他均无效；<br>在 Opera 中，COL、COLGROUP 元素以及它们相对于 CSS 中 display 特性值对设定 ‘position:relative’ 特性及偏移无效，其他均有效。</p>\n<blockquote>\n<p>解决办法：由于除 TABLE 之外的表格类元素以及它们相对于 CSS 中 display 特性值设定了相对定位后的效果 CSS2.1 规范中没有明确定义，而各浏览器的实现又存在很大差异。所以应避免为这些元素设定 ‘position:relative’。若需要实现如冻结表格行或列的效果，可以考虑使用绝对定位其他 TABLE 元素的方式模拟。</p>\n</blockquote>\n</li>\n<li><p>22、在 Safari Chrome 等使用 webkit 渲染引擎的浏览器中，’float:center’ 是合法值，他等同于 ‘float:none’ 设置，而其他浏览器则认为 ‘float’ 特性中 ‘center’ 是个非法值，遵循规范应忽略此处的 ‘float’ 特性设置。</p>\n<blockquote>\n<p>解决办法：避免使用非法的 ‘float’ 特性值。</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<hr>\n<h1 id=\"六、渲染模型的细节\"><a href=\"#六、渲染模型的细节\" class=\"headerlink\" title=\"六、渲染模型的细节\"></a>六、渲染模型的细节</h1><blockquote>\n<ul>\n<li>1、如果一个页面使浏览器工作在混杂模式下，那么当给一个设置了 ‘padding’ 或 ‘border-width’ 的非替换元素设置 ‘width’ 或 ‘height’ 以控制其尺寸时，这个元素在 IE 和其他览器中的实际尺寸将是不同的。<blockquote>\n<p>解决办法：- 使用能触发标准模式 (S) 的 DTD</p>\n</blockquote>\n</li>\n<li>使用 CSS 3 的新特性：box-sizing</li>\n</ul>\n<ul>\n<li>2、在 IE6 IE7(Q) IE8(Q) 中，如果一个非替换元素的 ‘overflow’ 为 ‘visible’，当该元素无法完全容纳其非绝对定位的内容时，该元素的尺寸将被其内容撑大。<br>在上述情况发生时，为这个非替换元素设置的 ‘width’ 和 ‘height’ 与 CSS 2.1 中的 ‘min-width’ 和 ‘min-height’ 的作用类似：设定值不是最终的实际值，实际值可能更大。<blockquote>\n<p>解决办法：使用能触发标准模式 (S) 的 DTD，以将受此问题影响的浏览器的范围缩小到仅 IE6(S)。<br>如果不能保证一个希望尺寸固定的非替换元素总是能容纳其内容，请将该元素的 ‘overflow’ 设置为非 ‘visible’ 的值。</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li>3、在 IE6 IE7 IE8 中，’width’ 或 ‘height’ 任意一个或两个都设置为 ‘0’ 的 IFRAME 元素是不可见的，而在其它浏览器中这样设置后的 IFRAME 元素仍可见。<blockquote>\n<p>解决办法：根据实际情况选择使用 ‘visibility:hidden’ 或者 ‘display:none’ 隐藏 IFRAME 。</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>4、在 IE6 IE7 IE8(Q) 中，如果一个浮动元素的宽度是 shrink-to-fit，该元素的最终宽度可能比预期的小，并被尽可能的向上布局。</p>\n<blockquote>\n<p>解决办法：这个问题的影响较大，避免该问题的最直接的方式是给浮动非替换元素指定一个宽度，而不使用其默认值 ‘auto’，从而避免其宽度为 shrink-to-fit，以使页面布局在各浏览器中的表现一致。</p>\n</blockquote>\n</li>\n<li><p>5、在 Chrome Safari 中，若浮动元素之前存在一个非 inline 级元素（包括 block、table 等），且它们的包含块 ‘width’ 特性计算值为 auto，则包含块的 shrink-to-fit 宽度计算会出现错误。</p>\n<blockquote>\n<p>解决办法：在容器为绝对定位、浮动或行内块元素且没有明确设定宽度时，若浮动元素之前出现非 inline 级元素，则要小心这个元素对容器 shrink-to-fit 宽度的影响。可以为容器明确的设定一个宽度。</p>\n</blockquote>\n</li>\n<li><p>6、在 IE6 IE7 IE8(Q) 中，一个右浮动元素将尽可能的向右布局，并撑大其所有宽度为 ‘auto’ 的祖先级元素的宽度，直到遇到一个明确设定了宽度的祖先级元素为止。<br>注：这种现象仅在该元素有宽度为 shrink-to-fit 的的祖先级元素时才可以看到。</p>\n<blockquote>\n<p>解决办法：如果有一个右浮动元素，应注意避免其祖先级元素的宽度为 shrink-to-fit，即给它们设定一个明确的宽度。以使页面布局在各浏览器中的表现一致。</p>\n</blockquote>\n</li>\n<li><p>7、IE6 IE7 IE8 Opera 中对 shrink-to-fit 计算时会考虑浮动元素的宽度，这其中包含非替换浮动元素、非替换绝对定位元素、为替换行内块元素。</p>\n<blockquote>\n<p>解决办法：尽量为非替换浮动元素、非替换绝对定位元素、非替换行内块元素显式地设置一个宽度，防止浏览器在 ‘width:auto’ 时对于 shrink-to-fit 的宽度计算方式不同造成布局上的差异。</p>\n</blockquote>\n</li>\n<li><p>8、IE6 及 IE7/8 的混杂模式下，非替换绝度定位元素当指定了 ‘left’ 及 ‘right’，而 ‘width’ 为默认值 “auto” 。此时浏览器无法正确地计算出 ‘width’ 的值，对于高度的计算也是如此。</p>\n<blockquote>\n<p>解决办法：若能为非替换绝对定位元素设定固定的宽度及高度，则尽量不使用此方式自动计算绝对定位元素的 ‘width’ 及 ‘height’；若无法避免使用此方式，则可以通过判断浏览器，仅在 IE6 中使用 CSS Expression 控制绝对定位元素的宽度及高度。</p>\n</blockquote>\n</li>\n<li><p>9、IE6 IE7 IE8(Q) 在超过一个行内元素排列生成行框时，识别行框的顶边和底边位置时会参照文本实际高度的顶边和底边尺寸，而不是行框内最高行内框的顶边和最底行内框的底边位置。</p>\n<blockquote>\n<p>解决办法：为了取得正常布局，建议 ‘line-height’ 计算值设置永远大于 ‘font-size’ 计算值设置。</p>\n</blockquote>\n</li>\n<li><p>10、IE6 IE7(Q) IE8(Q)不支持 ‘min-width’ 和 ‘max-width’ 特性。</p>\n<blockquote>\n<p>解决办法：使用 Javascript 实现 ‘min-width’ 和 ‘max-width’ 特性功能。</p>\n</blockquote>\n</li>\n<li><p>11、IE6 IE7 IE8(Q) 中行内非替换元素中的非文本文字可能会撑高其高度。</p>\n<blockquote>\n<p>解决办法：针对不同的需求，可以采取不同的解决方案，例如，将外层的行内元素改为一个块级元素、给外层行内元素设置 ‘display:inline-block’、给外层行内元素设置合适的 ‘font-size’ 值等。</p>\n</blockquote>\n</li>\n<li><p>12、不同浏览器内 ‘line-height’ 样式设置会影响 INPUT BUTTON 元素的显示高度。</p>\n<blockquote>\n<p>解决办法：尽量避免使用 ‘line-height’ 为 INPUT[type=text]、INPUT[type=password]、INPUT[type=button]、INPUT[type=file]、input[type=submit] 和 BUTTON 标记设置 ‘line-height’，而应改用规范内说明的 ‘height’ 属性。</p>\n</blockquote>\n</li>\n<li><p>13、IE6 IE7 IE8(Q) 中触发 hasLayout 的空块级非替换元素的高度不为 0。</p>\n<blockquote>\n<p>解决办法：如果想让一个触发了 hasLayout 的块级非替换元素的高度为 0，可以给这个空的块级非替换元素增加一个空的注释块：</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<pre><code>&lt;div style=&quot;zoom:1&quot;&gt;&lt;!-- --&gt;&lt;/div&gt;\n</code></pre><p>另外，不让元素在 IE 中触发 hasLayout 也可以避免此 BUG 。</p>\n<blockquote>\n<ul>\n<li><p>14、IE 的混杂模式中行内非替换元素的宽高可设置。</p>\n<blockquote>\n<p>解决办法：在页面上添加&lt;!DOCTYPE HTML&gt;，使页面工作在标准模式下。</p>\n</blockquote>\n</li>\n<li><p>15、IE6 IE7(Q) IE8(Q) 不支持 ‘min-height’ 和 ‘max-height’ 特性。</p>\n<blockquote>\n<p>解决办法：使用 Javascript 实现 ‘min-height’ 和 ‘max-height’ 特性功能。</p>\n</blockquote>\n</li>\n<li><p>16、不同浏览器对单行文本输入框和显示为按钮的控件基线位置理解不同。</p>\n<blockquote>\n<p>解决办法：避免使用 ‘baseline’ 对齐方式，为元素指定 ‘vertical-align’ 值非 ‘baseline’，推荐使用 ‘vertical-align:bottom’ 或 ‘vertical-align:top’。</p>\n</blockquote>\n</li>\n<li><p>17、Webkit 浏览器下行框高度计算还依赖于 ‘font-size’ 属性值，在 ‘line-height’ 属性值明显小于 ‘font-size’ 属性值设置时，将导致实际计算出的行框高度大于其他浏览器。</p>\n<blockquote>\n<p>解决办法：为了取得正常布局，建议 ‘line-height’ 计算值永远大于 ‘font-size’ 计算值设置。</p>\n</blockquote>\n</li>\n<li><p>18、容器高度被明确设定，容器内容高度仅由行高累加决定的情况下，Safari Chrome 中容器元素的 ‘overflow’ 值为非默认值时，其最后一个内联子元素的半差异高度可能会被忽略。</p>\n<blockquote>\n<p>解决办法：为了准确得到容器高度，建议避免使用行高为行内元素指定高度，而应改用块标记，并且明确的指定其 ‘height’ 值。</p>\n</blockquote>\n</li>\n<li><p>19、对于行内元素绝对定位后静态位置中的 ‘top’ 特性的计算值，IE6 IE7 IE8(Q) 会将其计算为静态位置下 content area 距包含块顶边的距离（即半差异的高度），其他浏览器则计算为 0。</p>\n<blockquote>\n<p>解决办法：在使行内元素绝对定位的时候，要注意其行高对静态位置带来的影响，明确设置定位的元素偏移位置。</p>\n</blockquote>\n</li>\n<li><p>20、在非标准文档模式中（包括混杂模式和近乎标准模式），当唯一的非表单控件类行内替换元素存在于其包容块中时，其父框的行高并不一定会计算文本基线高度。</p>\n<blockquote>\n<p>解决办法：如果在非标准模式中，需要父容器在仅有行内替换元素的情况下计算出包含文本基线高度的行高值，则必须加入其他行内文本元素。相反的，如果在标准模式中，需要行内替换元素与其父容器底部无间隙，请修改 ‘vertical-align’ 值为非 ‘baseline’ 。</p>\n</blockquote>\n</li>\n<li><p>21、若容器中包含 MARQUEE 元素，且容器遵循 shrink-to-fit 宽度算法，则容器及 MARQUEE 元素的宽度在不同浏览器中存在差异。</p>\n<blockquote>\n<p>解决办法：给 MARQUEE 元素及替换元素定义具体的宽度，保证各浏览器兼容。</p>\n</blockquote>\n</li>\n<li><p>22、对于宽度为 0% 的 IMG 元素的包含块的 shrink-to-fit 算法，Firefox Chrome Safari 与 IE6 IE7 IE8 Opera 存在差异。</p>\n<blockquote>\n<p>解决办法：尽量避免设置 IMG 元素的宽度为 0%，可以用 0px 替代。</p>\n</blockquote>\n</li>\n<li><p>23、IE6 IE7(Q) IE8(Q) 中，如果父需要使用 shrink-to-fit 算法，并且其子元素触发了 hasLayout 特性以及 ‘width’ 特性值为默认的 ‘auto’，那么会导致父元素 shrink-to-fit 计算值有误。</p>\n<blockquote>\n<p>解决办法：由于在 IE 浏览器中很难避免不触发 hasLayout 特性，因此建议在使用 ‘float’ ‘position:absolute’ 这两个样式时，为 ‘width’ 特性设置具体值。这样可以从根源上避免触发 shrink-to-fit 计算规则，由此来规避 IE6 IE7(Q) IE8(Q) 中由于 hasLayout 特性带来的渲染问题。</p>\n</blockquote>\n</li>\n<li><p>24、在 IE7(S) Firefox 中，若元素的高度出于某种原因使用了其 ‘min-height’ 或 ‘max-height’ 设定的值，则其生成的包含块的高度为元素的实际高度；而在 IE8(S) Chrome Safari Opera 中，生成的包含块的高度仍然为元素原始的高度。</p>\n<blockquote>\n<p>解决办法：在子孙元素参照设定并在计算值上应用了 ‘min-height’、’max-height’ 特性的元素生成的包含块的高度时需格外注意，此时尽量避免使用百分比等需要参照包含块计算的单位。</p>\n</blockquote>\n</li>\n<li><p>25、当采用如下布局方法时，各浏览器可能会造成 shrink-to-fit 计算规则处理差异：<br>1.父元素采用浮动或绝对定位样式，宽度值为 ‘auto’；<br>2.子元素存在两个以上连续的行内元素；<br>3.两个行内元素之间存在空文本节点而非标记首尾紧密相连；<br>4.第二个行内元素采用绝对定位样式，且 ‘top’ ‘left’ ‘bottom’ ‘right’ 都为 ‘auto’ 。<br>此时，Safari 和 Chrome 中的父元素采用 shrink-to-fit 计算规则时，可能使用了 preferred minimum width 来作为 preferred width ，导致在空文本节点处产生换行，使依赖元素普通流位置的绝对定位元素显示位置产生差异。</p>\n<blockquote>\n<p>解决办法：建议在使用 ‘float’ ‘position:absolute’ 这两个样式时，为 ‘width’ 特性设置具体值。这样可以从根源上避免触发 shrink-to-fit 计算规则带来的差异。</p>\n</blockquote>\n</li>\n<li><p>26、各浏览器对于未明确设定高度的包含块内包含百分比单位高度的块级元素的高度计算存在差异。</p>\n<blockquote>\n<p>解决办法：要对设置有百分比高度的块级元素的包含块设置明确的 ‘height’ 属性值。</p>\n</blockquote>\n</li>\n<li><p>27、当 IMG 元素没有设置 ‘width’ 特性且设置了值单位为百分比的 ‘min-width’ 或 ‘max-width’ 特性， 则在各浏览器中该 IMG 元素的包含块的 ‘shrink-to-fit’ 算法存在差异。</p>\n<blockquote>\n<p>解决办法：在包含块的宽度计算需要依赖其内 IMG 元素时，尽量避免给 IMG 元素的 ‘min-width’ 和 ‘max-width’ 特性设置百分比单位的值。</p>\n</blockquote>\n</li>\n<li><p>28、在正常文档流中，当包含块宽度为 0，其内未设定明确宽度的块级元素由于设定了 ‘margin’ 溢出包含块时，则该块级元素的宽度计算在 Chrome Safari 中会计算为 0。</p>\n<blockquote>\n<p>解决办法：尽量避免出现未明确设定宽度 (值为 ‘auto’) 的块级元素由于设定了 ‘margin’ 导致其溢出其宽度为 0 的包含块，应为其设定一个明确的宽度。</p>\n</blockquote>\n</li>\n<li><p>29、当页面中存在一个空的非替换行内元素时，如果给这个元素设置了边框或者背景样式，那么在 IE6 IE7 IE8(Q) 中这些样式将无法显示出来。</p>\n<blockquote>\n<p>解决办法：应尽量避免使用的空的非替换行内元素，以及避免为空元素添加显示用样式。</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<hr>\n<h1 id=\"七、可视效果\"><a href=\"#七、可视效果\" class=\"headerlink\" title=\"七、可视效果\"></a>七、可视效果</h1><blockquote>\n<ul>\n<li>1、当一个元素的 ‘overflow-x’ 或 ‘overflow-y’ 指定值为 ‘hidden’，另一个特性的指定值为 ‘visible’ 时， 该元素最终渲染使用的 ‘overflow-y’ 或 ‘overflow-x’ 值不同。IE6 IE7 IE8 使用 ‘hidden’，其它浏览器使用 ‘auto’。<blockquote>\n<p>解决办法：</p>\n</blockquote>\n</li>\n<li>同时设置 ‘overflow-x’ 和 ‘overflow-y’ 的值，不要出现其中之一为 ‘hidden’ 时，而另一个是 ‘visible’ 的情况；</li>\n<li><p>避免编写依赖指定值为 ‘visible’ 的 ‘overflow-x’ 和 ‘overflow-y’ 特性的计算值的代码。</p>\n</li>\n<li><p>2、在 IE6(S) IE7(S) 中，若一个 ‘overflow’ 特性不为 ‘visible’ 的非定位元素内包含了可能溢出其的相对定位元素，则溢出部分不会被剪裁。<br>在 IE6(Q) IE7(Q) IE8(Q) 中，若一个 ‘overflow’ 特性不为 ‘visible’ 的非定位元素内包含可能其溢出的绝对定位元素，则仍然会剪裁溢出的绝对定位元素。</p>\n<blockquote>\n<p>解决办法：根据实际需求可以去掉包含块的 ‘overflow:hidden’ 或采用其他定位方案，避免在 IE 中触发此问题，实现在各浏览器表现一致。</p>\n</blockquote>\n</li>\n<li><p>3、在 IE6 IE7 IE8 中，若在同一条规则中同时首先定义了 ‘overflow-x’ 或 ‘overflow-y’ 特性，然后又定义了 ‘overflow’ 特性，则作为简写的 ‘overflow’ 特性的值不会覆盖之前的 ‘overflow-x’ 或 ‘overflow-y’ 特性的值。</p>\n<blockquote>\n<p>解决办法：根据实际需求尽可能同时设定明确的 ‘overflow-x’ 以及 ‘overflow-y’ 特性，或者直接使用简写的 ‘overflow’，避免在同一条 CSS 规则内在 ‘overflow-x’ 或 ‘overflow-y’ 特性之后再定义 ‘overflow’ 特性。</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<hr>\n<h1 id=\"未完待续\"><a href=\"#未完待续\" class=\"headerlink\" title=\" - 未完待续\"></a> - 未完待续</h1>"},{"title":"与渲染HTML相关的兼容性问题","date":"2015-08-12T10:15:14.000Z","keywords":"html渲染兼容性, 前端兼容性","_content":"内容如题\n<!-- more -->\n\n> - 1、注释内容含中横线（-）在 Firefox 中可能会使中间内容丢失。\n>> 解决办法：按标准推荐的方法写注释标签\n\n> - 2、各浏览器对于字符编码别名支持的宽泛程度有差异，当指定了浏览器无法识别的字符编码别名时，浏览器会以确定编码的优先级顺序采用设置的更低优先级的字符编码，以此类推。\n而 Chrome Safari Opera 中对字符编码别名有着比其他浏览器更宽泛的支持。\n>> 解决办法：首先，对于动态页面必须确保 HTTP \"Content-Type\" 头字段的 \"charset\" 参数与页面自身编码相符，且务必在页面的 META 元素中也声明相符的字符编码信息。对于静态页面，必须保证页面中 META 元素声明中 \"http-equiv\" 为 \"Content-Type\" 对应的值中的 \"charset\" 的值与页面自身编码相符。\n其次，在设置字符编码别名时，最好使用最通用的、各浏览器均可识别的编码别名。\n\n> - 3、对于 URI 中非 ASCII 字符，并非所有浏览器都是按照 HTML 4.01 规范中的建议实现的，而且不同浏览器在处理不同形式的 URI 时，表现也有差异。\n>> 解决办法：当 URI 中含有非 ASCII 字符时，不要依赖浏览器对 URI 的编码方式，以避免产生差异\n\n> - 4、如果在 DTD 之前加入注释或其他内容，在某些浏览器中该 DTD 将无法被识别。\n>> 解决办法：声明 DTD 时，确保 DTD 之前没有其他字符，即便有，也只能是空格符、换行符和制表符。如将 DTD 放在 HTML 文档的第一行。\n\n> - 5、Chrome 和 Safari 中标签紧密相邻的行内元素在折行显示时存在错误。\n>> 解决办法：避免出现紧密连接的内联元素标签，可以在每个标记之间加入空格或者换行符来避免这个问题。\n\n> - 6、通过 META 元素可以控制页面定时跳转，对于 http-equiv 属性为 refresh 时对应的 content 属性的值中，跳转时间与跳转 URL 之间需要分隔符分开，如果使用非 ';' 的分隔符时，在某些浏览器下将不能达到期望的效果。\n>> 解决办法：\n>> - 参照 W3C 的建议，使用服务端进行页面跳转。\n>> - 使用合法的，所有浏览器均支持的写法：\n\n> - 7、IE6/7 及 IE8 混杂模式(Q) 会忽略同一行内 OBJECT、IFRAME 元素之后的空白符。\n>> 解决办法：若不希望出现空格，可以将 IFRAME OBJECT 元素设置为块级元素。\n\n\n> - 8、IE6 IE7 IE8(Q) 中当 OBJECT 元素之前的行内文本由 \"&nbsp;\" 构成，且 \"&nbsp;\" 宽度之和小于容器宽度时，OBJECT 元素不发生折行；而 \"&nbsp;\" 宽度之和超过容器时，OBJECT 元素会折行显示。而在 IE8(S) Opera 中，出现上述情况时，OBJECT 元素始终不会发生折行。\n>> 解决办法：\n合理的设置容器及 OBJECT 元素的宽度。若需要 OBJECT 元素不发生折行，则为容器设置 \"white-space:nowrap\" ；\n若需要 OBJECT 元素折行，则在 OBJECT 元素之前加入明确的换行符 \"<br />\" 。\n\n> - 9、Chrome 和 Safari 中 BR 元素前的空白符不会被忽略，多余的空白符将被压缩为一个空白符并渲染到 BR 元素之前的行中。\n>> 解决办法：删除 BR 元素之前多余的空白符。\n\n> - 10、单元格的 colspan 属性在 IE 中可能影响 TABLE 元素的自动布局。\n>> 解决办法：\n>> - 设置 TABLE 的 'table-layout' 特性值为 fixed，使用固定布局的表格元素可避免此问题。\n>> - 单元格所跨过的列的宽度都设置成 auto。\n\n> - 11、在 Firefox 中，TABLE 元素 'width' 属性的百分比值大于 100% 时，Firefox 会按 100% 处理；如果是 CSS 的 'width' 特性，则不会这么处理。\n>> 解决办法：给 TABLE 元素设置宽度的时候，不要使用 HTML 属性 'width'，请使用 CSS 特性 'width'。\n\n> - 12、在 IE 中，不仅 TD 和 TH 元素，其他一些元素也拥有 noWrap 属性。\n>> 解决办法：nowrap 属性是被废弃的属性，使用 CSS 规则 white-space:nowrap 代替这个属性。\n\n> - 13、IE6 IE7 IE8(Q) 对 COL 和 COLGROUP 元素的属性及部分 CSS 特性支持较好，而IE8(S) Firefox Chrome Safari 不再支持 COL 及 COLGROUP 元素的部分属性及为其设定的 CSS 特性。\n>> 解决办法：当使用 COLGROUP COL 时需注意各浏览器对属性及 CSS 样式的设置，避免造成兼容性问题。\n\n> - 14、若表格设定了大于零的水平单元格间隙 (即 cellspacing 属性)，且其内单元格存在过度设定的 colspan 属性，也就是单元格横跨的列数的设定值多余实际存在的单元格的个数，这时各浏览器对表格的渲染效果存在较大差异。\n>> 解决办法：在进行表格布局时，务必精准设定 colspan 属性的值\n\n> - 15、BASE 元素出现在 BODY 中，且定义了 target 属性，各浏览器表现不一致。\n>> 解决办法：不要在 HEAD 元素之外定义 BASE 元素，保证各浏览器兼容。\n\n> - 16、通常情况下，IE 系列浏览器通过 ActiveX 插件使用 OBJECT 元素引入 Flash，而其他浏览器则是通过相应的 NPAPI 插件使用 EMBED 元素。这造成了各浏览器中插入 Flash 的方式的差异。\n>> 解决办法：\n>> - 若不考虑 W3C 校验，可统一使用 EMBED 元素嵌入 Flash，这样可以避免因参数不统一导致的兼容性问题。\n>> - 若需要考虑 W3C 校验（swfobject Markup Validation Service），则可使用第三种单独使用 OBJECT 与 PARAM 元素的方式。\n>> - 若必须使用 OBJECT 嵌套 EMBED 元素这种混合方式，则要保证 Flash 文件 URL、为 Flash 传递的参数、宽度、高度、wmode 等参数保持统一。\n>> - 可以使用开源的 SWFObject 引入 Flash。（请参见：swfobject）\n\n> - 17、该问题将造成局部的布局混乱。\n>> 解决办法：为了防止这种无 \"src\" 的 IMG 元素对页面产生布局影响，需要设置这种 IMG 的 ‘display’ 特性为 'none'。\n\n> - 18、alt 属性在 IE6 IE7 IE8(Q) 下具有双重意义。在给 IMG、AREA、INPUT[type=image] 元素设置的 alt 属性值不但可以作为该元素的替代文字，在该元素没有指定 title 属性时，还可以作为提示信息（tooltip）被显示出来。\n>> 解决办法：\n>> - 若用户需要显示提示框，则指定 title 属性；\n>> - 若用户不需要显示提示框，则指定 title=\"\"。\n\n> - 19、PNG24 格式图片可以携带 Alpha 半透明通道，以便呈现从透明到不透明间过渡色彩效果，但是 IE6 不支持这种格式原有的透明特性。\n>> 解决办法：\n- 使用 IE 专有滤镜 AlphaImageLoader Filter 来修复 IE6 透明通道问题\n- 或者使用脚本批量处理方式：\n\n\tfunction fixpng24(){\n\t    var arVersion = navigator.appVersion.split(\"MSIE\");\n\t    var version = parseFloat(arVersion[1]);\n\t    if ((version >= 5.5) && (document.body.filters)){\n\t       for(var i=0; i<document.images.length; i++){\n\t          var img = document.images[i];\n\t          if (img.src.toLowerCase().slice(-3) == \"png\"){\n\t             var imgID = (img.id) ? \"id='\" + img.id + \"' \" : \"\";\n\t             var imgClass = (img.className) ? \"class='\" + img.className + \"' \" : \"\";\n\t             var imgTitle = (img.title) ? \"title='\" + img.title + \"' \" : \"title='\" + img.alt + \"' \";\n\t             var imgStyle = \"display:inline-block;\" + img.style.cssText ;\n\t             if (img.align == \"left\") imgStyle = \"float:left;\" + imgStyle;\n\t             if (img.align == \"right\") imgStyle = \"float:right;\" + imgStyle;\n\t             if (img.parentElement.href) imgStyle = \"cursor:pointer;\" + imgStyle;\n\t             var strNewHTML = \"<span \" + imgID + imgClass + imgTitle\n\t             + \" style=\\\"width:\" + img.width + \"px; height:\" + img.height + \"px;\" + imgStyle\n\t             + \"filter:progid:DXImageTransform.Microsoft.AlphaImageLoader\"\n\t             + \"(src='\" + img.src + \"', sizingMethod='scale');\\\"></span>\";\n\t             img.outerHTML = strNewHTML;\n\t             i--;\n\t          }\n\t       }\n\t    }\n\t}\n\n\n> - 20、当给一个现有的 IMG 元素重设其 \"src\" 为其当前的 \"src\" 时，只有 IE6 会重现载入该图片，其他浏览器则不会。\n>> 解决办法：如果需要重复设置相同的 src 值时，均触发 IMG 的 onload 事件，或者需要每次均从服务器端下载图片数据的时候，可以采用图片地址后加上随机数或当前时间戳参数的手段，避免内容被缓存。\n\n> - 21、IE Chrome Safari 支持通过为 OBJECT 元素设置 classid 引入 Windows 下的 Media Player 或 Flash 插件。而 Windows 版的 Firefox 与 Opera 无法支持这种形式引入这些插件。\n>> 解决办法：由于某些浏览器原生无法支持 OBJECT 元素使用 classid 属性引入 Media Player 插件，所以为保证最大的兼容性，应避免使用此方式在页面中播放媒体文件。\n可以考虑使用 Flash，或者合理的利用 IE 对 Media Player 的支持及其其他浏览器对 HTML5 的新标签 \"VIDEO\" 与 \"AUDIO\" 的支持在不同浏览器中达到相类似的效果。\n\n> - 22、Firefox Opera 中 OBJECT 元素的默认尺寸为不可视；而 IE 中，OBJECT 默认尺寸为 16 x 16 像素；在 Chrome 和 Safari 下的默认尺寸为 300 x 150 像素。\n>> 解决办法：OBJECT 元素为替换元素，应为 OBJECT 元素设置一个明确的宽度和高度。\n\n> - 23、IE Opera 中，IMG 元素通过其 usemap 属性可以与 MAP 元素的 id 属性及 name 属性关联，而 Firefox Chrome Safari 中仅限于 MAP 元素的 name 属性。\n>> 解决办法：若需要 IMG 元素与 MAP 元素相关联，注意通过 IMG 元素的 usemap 属性关联的 MAP 元素的 name 属性的值。\n\n> - 24、MAP 元素会影响指向 MAP 的元素，其父元素 A 元素的默认链接行为。\nIE6 IE7 IE8 中，产生自 MAP 元素的事件冒泡路径，不依赖 MAP 本身所处的元素嵌套规则，他会执行到引向 MAP 的元素嵌套结构中。\n>> 解决办法：\n>> - 注意 MAP 标记与其他标记的嵌套关系，IE6 IE7 IE8 中的 MAP 冒泡机制是根据指向 MAP 标记的标记位置决定的。如果期望所有浏览器冒泡路径基本一致，可以将 MAP 标记放在引用 MAP 的标记的兄弟级别。\n>> - 注意 A 标记的默认导航行为触发限制，即使标签嵌套一致，点击事件冒泡路颈 A 标记，也不会在 IE6 IE7 IE8 Firefox 中触发浏览器默认行为产生导航。可以利用 A 标记也会执行点击事件冒泡的特性，使用 A 标记的 \"click\" 事件代替 \"href\" 属性执行页面跳转工作。\n\n> - 25、CENTER 元素在 IE6 IE7 IE8(Q) 中会使自身也居中对齐，除了上述浏览器，在 IE(S) 与 Opera(S) 中 CENTER 元素还会使其内表格中的单元格内文本居中对齐。\n>> 解决办法：避免使用 CENTER 标签，使用 CSS 的 'text-align' 特性来代替。\n\n> - 26、Firefox Chrome Safari 会将 DIV H1~H6 P 元素的 align=\"middle\" 解释为 align=\"center\"，从而使这些元素能够居中对齐。\nFirefox 混杂模式会将 TABLE 元素 align=\"middle\" 解释为 align=\"center\"，使 TABLE 元素居中对齐。\nIE6 IE7 Chrome Safari Opera 及 IE8 Firefox 的混杂模式下，均将 TD TH 元素的 align=\"middle\" 理解为 align=\"center\"。\n>> 解决办法：align=\"middle\" 仅在 IMG、OBJECT、APPLET 元素上的 align 属性中是合法值，对于其他元素的 align 属性均为非法。各浏览器在上述三个元素之外的元素上遇到 align=\"middle\" 均按照自己的理解方式解释。同时除单元格元素的 align 属性之外，其他的 align 属性均被 W3C 官方废弃（Deprecated.），所以应避免使用此属性。\n","source":"_posts/与渲染HTML相关的兼容性问题.md","raw":"title: 与渲染HTML相关的兼容性问题\ndate: 2015-08-12 18:15:14\ntags: 兼容性\ncategories: 与渲染HTML相关的兼容性问题\nkeywords: html渲染兼容性, 前端兼容性\n---\n内容如题\n<!-- more -->\n\n> - 1、注释内容含中横线（-）在 Firefox 中可能会使中间内容丢失。\n>> 解决办法：按标准推荐的方法写注释标签\n\n> - 2、各浏览器对于字符编码别名支持的宽泛程度有差异，当指定了浏览器无法识别的字符编码别名时，浏览器会以确定编码的优先级顺序采用设置的更低优先级的字符编码，以此类推。\n而 Chrome Safari Opera 中对字符编码别名有着比其他浏览器更宽泛的支持。\n>> 解决办法：首先，对于动态页面必须确保 HTTP \"Content-Type\" 头字段的 \"charset\" 参数与页面自身编码相符，且务必在页面的 META 元素中也声明相符的字符编码信息。对于静态页面，必须保证页面中 META 元素声明中 \"http-equiv\" 为 \"Content-Type\" 对应的值中的 \"charset\" 的值与页面自身编码相符。\n其次，在设置字符编码别名时，最好使用最通用的、各浏览器均可识别的编码别名。\n\n> - 3、对于 URI 中非 ASCII 字符，并非所有浏览器都是按照 HTML 4.01 规范中的建议实现的，而且不同浏览器在处理不同形式的 URI 时，表现也有差异。\n>> 解决办法：当 URI 中含有非 ASCII 字符时，不要依赖浏览器对 URI 的编码方式，以避免产生差异\n\n> - 4、如果在 DTD 之前加入注释或其他内容，在某些浏览器中该 DTD 将无法被识别。\n>> 解决办法：声明 DTD 时，确保 DTD 之前没有其他字符，即便有，也只能是空格符、换行符和制表符。如将 DTD 放在 HTML 文档的第一行。\n\n> - 5、Chrome 和 Safari 中标签紧密相邻的行内元素在折行显示时存在错误。\n>> 解决办法：避免出现紧密连接的内联元素标签，可以在每个标记之间加入空格或者换行符来避免这个问题。\n\n> - 6、通过 META 元素可以控制页面定时跳转，对于 http-equiv 属性为 refresh 时对应的 content 属性的值中，跳转时间与跳转 URL 之间需要分隔符分开，如果使用非 ';' 的分隔符时，在某些浏览器下将不能达到期望的效果。\n>> 解决办法：\n>> - 参照 W3C 的建议，使用服务端进行页面跳转。\n>> - 使用合法的，所有浏览器均支持的写法：\n\n> - 7、IE6/7 及 IE8 混杂模式(Q) 会忽略同一行内 OBJECT、IFRAME 元素之后的空白符。\n>> 解决办法：若不希望出现空格，可以将 IFRAME OBJECT 元素设置为块级元素。\n\n\n> - 8、IE6 IE7 IE8(Q) 中当 OBJECT 元素之前的行内文本由 \"&nbsp;\" 构成，且 \"&nbsp;\" 宽度之和小于容器宽度时，OBJECT 元素不发生折行；而 \"&nbsp;\" 宽度之和超过容器时，OBJECT 元素会折行显示。而在 IE8(S) Opera 中，出现上述情况时，OBJECT 元素始终不会发生折行。\n>> 解决办法：\n合理的设置容器及 OBJECT 元素的宽度。若需要 OBJECT 元素不发生折行，则为容器设置 \"white-space:nowrap\" ；\n若需要 OBJECT 元素折行，则在 OBJECT 元素之前加入明确的换行符 \"<br />\" 。\n\n> - 9、Chrome 和 Safari 中 BR 元素前的空白符不会被忽略，多余的空白符将被压缩为一个空白符并渲染到 BR 元素之前的行中。\n>> 解决办法：删除 BR 元素之前多余的空白符。\n\n> - 10、单元格的 colspan 属性在 IE 中可能影响 TABLE 元素的自动布局。\n>> 解决办法：\n>> - 设置 TABLE 的 'table-layout' 特性值为 fixed，使用固定布局的表格元素可避免此问题。\n>> - 单元格所跨过的列的宽度都设置成 auto。\n\n> - 11、在 Firefox 中，TABLE 元素 'width' 属性的百分比值大于 100% 时，Firefox 会按 100% 处理；如果是 CSS 的 'width' 特性，则不会这么处理。\n>> 解决办法：给 TABLE 元素设置宽度的时候，不要使用 HTML 属性 'width'，请使用 CSS 特性 'width'。\n\n> - 12、在 IE 中，不仅 TD 和 TH 元素，其他一些元素也拥有 noWrap 属性。\n>> 解决办法：nowrap 属性是被废弃的属性，使用 CSS 规则 white-space:nowrap 代替这个属性。\n\n> - 13、IE6 IE7 IE8(Q) 对 COL 和 COLGROUP 元素的属性及部分 CSS 特性支持较好，而IE8(S) Firefox Chrome Safari 不再支持 COL 及 COLGROUP 元素的部分属性及为其设定的 CSS 特性。\n>> 解决办法：当使用 COLGROUP COL 时需注意各浏览器对属性及 CSS 样式的设置，避免造成兼容性问题。\n\n> - 14、若表格设定了大于零的水平单元格间隙 (即 cellspacing 属性)，且其内单元格存在过度设定的 colspan 属性，也就是单元格横跨的列数的设定值多余实际存在的单元格的个数，这时各浏览器对表格的渲染效果存在较大差异。\n>> 解决办法：在进行表格布局时，务必精准设定 colspan 属性的值\n\n> - 15、BASE 元素出现在 BODY 中，且定义了 target 属性，各浏览器表现不一致。\n>> 解决办法：不要在 HEAD 元素之外定义 BASE 元素，保证各浏览器兼容。\n\n> - 16、通常情况下，IE 系列浏览器通过 ActiveX 插件使用 OBJECT 元素引入 Flash，而其他浏览器则是通过相应的 NPAPI 插件使用 EMBED 元素。这造成了各浏览器中插入 Flash 的方式的差异。\n>> 解决办法：\n>> - 若不考虑 W3C 校验，可统一使用 EMBED 元素嵌入 Flash，这样可以避免因参数不统一导致的兼容性问题。\n>> - 若需要考虑 W3C 校验（swfobject Markup Validation Service），则可使用第三种单独使用 OBJECT 与 PARAM 元素的方式。\n>> - 若必须使用 OBJECT 嵌套 EMBED 元素这种混合方式，则要保证 Flash 文件 URL、为 Flash 传递的参数、宽度、高度、wmode 等参数保持统一。\n>> - 可以使用开源的 SWFObject 引入 Flash。（请参见：swfobject）\n\n> - 17、该问题将造成局部的布局混乱。\n>> 解决办法：为了防止这种无 \"src\" 的 IMG 元素对页面产生布局影响，需要设置这种 IMG 的 ‘display’ 特性为 'none'。\n\n> - 18、alt 属性在 IE6 IE7 IE8(Q) 下具有双重意义。在给 IMG、AREA、INPUT[type=image] 元素设置的 alt 属性值不但可以作为该元素的替代文字，在该元素没有指定 title 属性时，还可以作为提示信息（tooltip）被显示出来。\n>> 解决办法：\n>> - 若用户需要显示提示框，则指定 title 属性；\n>> - 若用户不需要显示提示框，则指定 title=\"\"。\n\n> - 19、PNG24 格式图片可以携带 Alpha 半透明通道，以便呈现从透明到不透明间过渡色彩效果，但是 IE6 不支持这种格式原有的透明特性。\n>> 解决办法：\n- 使用 IE 专有滤镜 AlphaImageLoader Filter 来修复 IE6 透明通道问题\n- 或者使用脚本批量处理方式：\n\n\tfunction fixpng24(){\n\t    var arVersion = navigator.appVersion.split(\"MSIE\");\n\t    var version = parseFloat(arVersion[1]);\n\t    if ((version >= 5.5) && (document.body.filters)){\n\t       for(var i=0; i<document.images.length; i++){\n\t          var img = document.images[i];\n\t          if (img.src.toLowerCase().slice(-3) == \"png\"){\n\t             var imgID = (img.id) ? \"id='\" + img.id + \"' \" : \"\";\n\t             var imgClass = (img.className) ? \"class='\" + img.className + \"' \" : \"\";\n\t             var imgTitle = (img.title) ? \"title='\" + img.title + \"' \" : \"title='\" + img.alt + \"' \";\n\t             var imgStyle = \"display:inline-block;\" + img.style.cssText ;\n\t             if (img.align == \"left\") imgStyle = \"float:left;\" + imgStyle;\n\t             if (img.align == \"right\") imgStyle = \"float:right;\" + imgStyle;\n\t             if (img.parentElement.href) imgStyle = \"cursor:pointer;\" + imgStyle;\n\t             var strNewHTML = \"<span \" + imgID + imgClass + imgTitle\n\t             + \" style=\\\"width:\" + img.width + \"px; height:\" + img.height + \"px;\" + imgStyle\n\t             + \"filter:progid:DXImageTransform.Microsoft.AlphaImageLoader\"\n\t             + \"(src='\" + img.src + \"', sizingMethod='scale');\\\"></span>\";\n\t             img.outerHTML = strNewHTML;\n\t             i--;\n\t          }\n\t       }\n\t    }\n\t}\n\n\n> - 20、当给一个现有的 IMG 元素重设其 \"src\" 为其当前的 \"src\" 时，只有 IE6 会重现载入该图片，其他浏览器则不会。\n>> 解决办法：如果需要重复设置相同的 src 值时，均触发 IMG 的 onload 事件，或者需要每次均从服务器端下载图片数据的时候，可以采用图片地址后加上随机数或当前时间戳参数的手段，避免内容被缓存。\n\n> - 21、IE Chrome Safari 支持通过为 OBJECT 元素设置 classid 引入 Windows 下的 Media Player 或 Flash 插件。而 Windows 版的 Firefox 与 Opera 无法支持这种形式引入这些插件。\n>> 解决办法：由于某些浏览器原生无法支持 OBJECT 元素使用 classid 属性引入 Media Player 插件，所以为保证最大的兼容性，应避免使用此方式在页面中播放媒体文件。\n可以考虑使用 Flash，或者合理的利用 IE 对 Media Player 的支持及其其他浏览器对 HTML5 的新标签 \"VIDEO\" 与 \"AUDIO\" 的支持在不同浏览器中达到相类似的效果。\n\n> - 22、Firefox Opera 中 OBJECT 元素的默认尺寸为不可视；而 IE 中，OBJECT 默认尺寸为 16 x 16 像素；在 Chrome 和 Safari 下的默认尺寸为 300 x 150 像素。\n>> 解决办法：OBJECT 元素为替换元素，应为 OBJECT 元素设置一个明确的宽度和高度。\n\n> - 23、IE Opera 中，IMG 元素通过其 usemap 属性可以与 MAP 元素的 id 属性及 name 属性关联，而 Firefox Chrome Safari 中仅限于 MAP 元素的 name 属性。\n>> 解决办法：若需要 IMG 元素与 MAP 元素相关联，注意通过 IMG 元素的 usemap 属性关联的 MAP 元素的 name 属性的值。\n\n> - 24、MAP 元素会影响指向 MAP 的元素，其父元素 A 元素的默认链接行为。\nIE6 IE7 IE8 中，产生自 MAP 元素的事件冒泡路径，不依赖 MAP 本身所处的元素嵌套规则，他会执行到引向 MAP 的元素嵌套结构中。\n>> 解决办法：\n>> - 注意 MAP 标记与其他标记的嵌套关系，IE6 IE7 IE8 中的 MAP 冒泡机制是根据指向 MAP 标记的标记位置决定的。如果期望所有浏览器冒泡路径基本一致，可以将 MAP 标记放在引用 MAP 的标记的兄弟级别。\n>> - 注意 A 标记的默认导航行为触发限制，即使标签嵌套一致，点击事件冒泡路颈 A 标记，也不会在 IE6 IE7 IE8 Firefox 中触发浏览器默认行为产生导航。可以利用 A 标记也会执行点击事件冒泡的特性，使用 A 标记的 \"click\" 事件代替 \"href\" 属性执行页面跳转工作。\n\n> - 25、CENTER 元素在 IE6 IE7 IE8(Q) 中会使自身也居中对齐，除了上述浏览器，在 IE(S) 与 Opera(S) 中 CENTER 元素还会使其内表格中的单元格内文本居中对齐。\n>> 解决办法：避免使用 CENTER 标签，使用 CSS 的 'text-align' 特性来代替。\n\n> - 26、Firefox Chrome Safari 会将 DIV H1~H6 P 元素的 align=\"middle\" 解释为 align=\"center\"，从而使这些元素能够居中对齐。\nFirefox 混杂模式会将 TABLE 元素 align=\"middle\" 解释为 align=\"center\"，使 TABLE 元素居中对齐。\nIE6 IE7 Chrome Safari Opera 及 IE8 Firefox 的混杂模式下，均将 TD TH 元素的 align=\"middle\" 理解为 align=\"center\"。\n>> 解决办法：align=\"middle\" 仅在 IMG、OBJECT、APPLET 元素上的 align 属性中是合法值，对于其他元素的 align 属性均为非法。各浏览器在上述三个元素之外的元素上遇到 align=\"middle\" 均按照自己的理解方式解释。同时除单元格元素的 align 属性之外，其他的 align 属性均被 W3C 官方废弃（Deprecated.），所以应避免使用此属性。\n","slug":"与渲染HTML相关的兼容性问题","published":1,"updated":"2016-10-31T07:25:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciuyzlutb000be6tbxnk36rzx","content":"<p>内容如题<br><a id=\"more\"></a></p>\n<blockquote>\n<ul>\n<li><p>1、注释内容含中横线（-）在 Firefox 中可能会使中间内容丢失。</p>\n<blockquote>\n<p>解决办法：按标准推荐的方法写注释标签</p>\n</blockquote>\n</li>\n<li><p>2、各浏览器对于字符编码别名支持的宽泛程度有差异，当指定了浏览器无法识别的字符编码别名时，浏览器会以确定编码的优先级顺序采用设置的更低优先级的字符编码，以此类推。<br>而 Chrome Safari Opera 中对字符编码别名有着比其他浏览器更宽泛的支持。</p>\n<blockquote>\n<p>解决办法：首先，对于动态页面必须确保 HTTP “Content-Type” 头字段的 “charset” 参数与页面自身编码相符，且务必在页面的 META 元素中也声明相符的字符编码信息。对于静态页面，必须保证页面中 META 元素声明中 “http-equiv” 为 “Content-Type” 对应的值中的 “charset” 的值与页面自身编码相符。<br>其次，在设置字符编码别名时，最好使用最通用的、各浏览器均可识别的编码别名。</p>\n</blockquote>\n</li>\n<li><p>3、对于 URI 中非 ASCII 字符，并非所有浏览器都是按照 HTML 4.01 规范中的建议实现的，而且不同浏览器在处理不同形式的 URI 时，表现也有差异。</p>\n<blockquote>\n<p>解决办法：当 URI 中含有非 ASCII 字符时，不要依赖浏览器对 URI 的编码方式，以避免产生差异</p>\n</blockquote>\n</li>\n<li><p>4、如果在 DTD 之前加入注释或其他内容，在某些浏览器中该 DTD 将无法被识别。</p>\n<blockquote>\n<p>解决办法：声明 DTD 时，确保 DTD 之前没有其他字符，即便有，也只能是空格符、换行符和制表符。如将 DTD 放在 HTML 文档的第一行。</p>\n</blockquote>\n</li>\n<li><p>5、Chrome 和 Safari 中标签紧密相邻的行内元素在折行显示时存在错误。</p>\n<blockquote>\n<p>解决办法：避免出现紧密连接的内联元素标签，可以在每个标记之间加入空格或者换行符来避免这个问题。</p>\n</blockquote>\n</li>\n<li><p>6、通过 META 元素可以控制页面定时跳转，对于 http-equiv 属性为 refresh 时对应的 content 属性的值中，跳转时间与跳转 URL 之间需要分隔符分开，如果使用非 ‘;’ 的分隔符时，在某些浏览器下将不能达到期望的效果。</p>\n<blockquote>\n<p>解决办法：</p>\n<ul>\n<li>参照 W3C 的建议，使用服务端进行页面跳转。</li>\n<li>使用合法的，所有浏览器均支持的写法：</li>\n</ul>\n</blockquote>\n</li>\n<li><p>7、IE6/7 及 IE8 混杂模式(Q) 会忽略同一行内 OBJECT、IFRAME 元素之后的空白符。</p>\n<blockquote>\n<p>解决办法：若不希望出现空格，可以将 IFRAME OBJECT 元素设置为块级元素。</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>8、IE6 IE7 IE8(Q) 中当 OBJECT 元素之前的行内文本由 “&nbsp;” 构成，且 “&nbsp;” 宽度之和小于容器宽度时，OBJECT 元素不发生折行；而 “&nbsp;” 宽度之和超过容器时，OBJECT 元素会折行显示。而在 IE8(S) Opera 中，出现上述情况时，OBJECT 元素始终不会发生折行。</p>\n<blockquote>\n<p>解决办法：<br>合理的设置容器及 OBJECT 元素的宽度。若需要 OBJECT 元素不发生折行，则为容器设置 “white-space:nowrap” ；<br>若需要 OBJECT 元素折行，则在 OBJECT 元素之前加入明确的换行符 “<br>“ 。</p>\n</blockquote>\n</li>\n<li><p>9、Chrome 和 Safari 中 BR 元素前的空白符不会被忽略，多余的空白符将被压缩为一个空白符并渲染到 BR 元素之前的行中。</p>\n<blockquote>\n<p>解决办法：删除 BR 元素之前多余的空白符。</p>\n</blockquote>\n</li>\n<li><p>10、单元格的 colspan 属性在 IE 中可能影响 TABLE 元素的自动布局。</p>\n<blockquote>\n<p>解决办法：</p>\n<ul>\n<li>设置 TABLE 的 ‘table-layout’ 特性值为 fixed，使用固定布局的表格元素可避免此问题。</li>\n<li>单元格所跨过的列的宽度都设置成 auto。</li>\n</ul>\n</blockquote>\n</li>\n<li><p>11、在 Firefox 中，TABLE 元素 ‘width’ 属性的百分比值大于 100% 时，Firefox 会按 100% 处理；如果是 CSS 的 ‘width’ 特性，则不会这么处理。</p>\n<blockquote>\n<p>解决办法：给 TABLE 元素设置宽度的时候，不要使用 HTML 属性 ‘width’，请使用 CSS 特性 ‘width’。</p>\n</blockquote>\n</li>\n<li><p>12、在 IE 中，不仅 TD 和 TH 元素，其他一些元素也拥有 noWrap 属性。</p>\n<blockquote>\n<p>解决办法：nowrap 属性是被废弃的属性，使用 CSS 规则 white-space:nowrap 代替这个属性。</p>\n</blockquote>\n</li>\n<li><p>13、IE6 IE7 IE8(Q) 对 COL 和 COLGROUP 元素的属性及部分 CSS 特性支持较好，而IE8(S) Firefox Chrome Safari 不再支持 COL 及 COLGROUP 元素的部分属性及为其设定的 CSS 特性。</p>\n<blockquote>\n<p>解决办法：当使用 COLGROUP COL 时需注意各浏览器对属性及 CSS 样式的设置，避免造成兼容性问题。</p>\n</blockquote>\n</li>\n<li><p>14、若表格设定了大于零的水平单元格间隙 (即 cellspacing 属性)，且其内单元格存在过度设定的 colspan 属性，也就是单元格横跨的列数的设定值多余实际存在的单元格的个数，这时各浏览器对表格的渲染效果存在较大差异。</p>\n<blockquote>\n<p>解决办法：在进行表格布局时，务必精准设定 colspan 属性的值</p>\n</blockquote>\n</li>\n<li><p>15、BASE 元素出现在 BODY 中，且定义了 target 属性，各浏览器表现不一致。</p>\n<blockquote>\n<p>解决办法：不要在 HEAD 元素之外定义 BASE 元素，保证各浏览器兼容。</p>\n</blockquote>\n</li>\n<li><p>16、通常情况下，IE 系列浏览器通过 ActiveX 插件使用 OBJECT 元素引入 Flash，而其他浏览器则是通过相应的 NPAPI 插件使用 EMBED 元素。这造成了各浏览器中插入 Flash 的方式的差异。</p>\n<blockquote>\n<p>解决办法：</p>\n<ul>\n<li>若不考虑 W3C 校验，可统一使用 EMBED 元素嵌入 Flash，这样可以避免因参数不统一导致的兼容性问题。</li>\n<li>若需要考虑 W3C 校验（swfobject Markup Validation Service），则可使用第三种单独使用 OBJECT 与 PARAM 元素的方式。</li>\n<li>若必须使用 OBJECT 嵌套 EMBED 元素这种混合方式，则要保证 Flash 文件 URL、为 Flash 传递的参数、宽度、高度、wmode 等参数保持统一。</li>\n<li>可以使用开源的 SWFObject 引入 Flash。（请参见：swfobject）</li>\n</ul>\n</blockquote>\n</li>\n<li><p>17、该问题将造成局部的布局混乱。</p>\n<blockquote>\n<p>解决办法：为了防止这种无 “src” 的 IMG 元素对页面产生布局影响，需要设置这种 IMG 的 ‘display’ 特性为 ‘none’。</p>\n</blockquote>\n</li>\n<li><p>18、alt 属性在 IE6 IE7 IE8(Q) 下具有双重意义。在给 IMG、AREA、INPUT[type=image] 元素设置的 alt 属性值不但可以作为该元素的替代文字，在该元素没有指定 title 属性时，还可以作为提示信息（tooltip）被显示出来。</p>\n<blockquote>\n<p>解决办法：</p>\n<ul>\n<li>若用户需要显示提示框，则指定 title 属性；</li>\n<li>若用户不需要显示提示框，则指定 title=””。</li>\n</ul>\n</blockquote>\n</li>\n<li><p>19、PNG24 格式图片可以携带 Alpha 半透明通道，以便呈现从透明到不透明间过渡色彩效果，但是 IE6 不支持这种格式原有的透明特性。</p>\n<blockquote>\n<p>解决办法：</p>\n</blockquote>\n</li>\n<li>使用 IE 专有滤镜 AlphaImageLoader Filter 来修复 IE6 透明通道问题</li>\n<li>或者使用脚本批量处理方式：</li>\n</ul>\n</blockquote>\n<pre><code>function fixpng24(){\n    var arVersion = navigator.appVersion.split(&quot;MSIE&quot;);\n    var version = parseFloat(arVersion[1]);\n    if ((version &gt;= 5.5) &amp;&amp; (document.body.filters)){\n       for(var i=0; i&lt;document.images.length; i++){\n          var img = document.images[i];\n          if (img.src.toLowerCase().slice(-3) == &quot;png&quot;){\n             var imgID = (img.id) ? &quot;id=&apos;&quot; + img.id + &quot;&apos; &quot; : &quot;&quot;;\n             var imgClass = (img.className) ? &quot;class=&apos;&quot; + img.className + &quot;&apos; &quot; : &quot;&quot;;\n             var imgTitle = (img.title) ? &quot;title=&apos;&quot; + img.title + &quot;&apos; &quot; : &quot;title=&apos;&quot; + img.alt + &quot;&apos; &quot;;\n             var imgStyle = &quot;display:inline-block;&quot; + img.style.cssText ;\n             if (img.align == &quot;left&quot;) imgStyle = &quot;float:left;&quot; + imgStyle;\n             if (img.align == &quot;right&quot;) imgStyle = &quot;float:right;&quot; + imgStyle;\n             if (img.parentElement.href) imgStyle = &quot;cursor:pointer;&quot; + imgStyle;\n             var strNewHTML = &quot;&lt;span &quot; + imgID + imgClass + imgTitle\n             + &quot; style=\\&quot;width:&quot; + img.width + &quot;px; height:&quot; + img.height + &quot;px;&quot; + imgStyle\n             + &quot;filter:progid:DXImageTransform.Microsoft.AlphaImageLoader&quot;\n             + &quot;(src=&apos;&quot; + img.src + &quot;&apos;, sizingMethod=&apos;scale&apos;);\\&quot;&gt;&lt;/span&gt;&quot;;\n             img.outerHTML = strNewHTML;\n             i--;\n          }\n       }\n    }\n}\n</code></pre><blockquote>\n<ul>\n<li><p>20、当给一个现有的 IMG 元素重设其 “src” 为其当前的 “src” 时，只有 IE6 会重现载入该图片，其他浏览器则不会。</p>\n<blockquote>\n<p>解决办法：如果需要重复设置相同的 src 值时，均触发 IMG 的 onload 事件，或者需要每次均从服务器端下载图片数据的时候，可以采用图片地址后加上随机数或当前时间戳参数的手段，避免内容被缓存。</p>\n</blockquote>\n</li>\n<li><p>21、IE Chrome Safari 支持通过为 OBJECT 元素设置 classid 引入 Windows 下的 Media Player 或 Flash 插件。而 Windows 版的 Firefox 与 Opera 无法支持这种形式引入这些插件。</p>\n<blockquote>\n<p>解决办法：由于某些浏览器原生无法支持 OBJECT 元素使用 classid 属性引入 Media Player 插件，所以为保证最大的兼容性，应避免使用此方式在页面中播放媒体文件。<br>可以考虑使用 Flash，或者合理的利用 IE 对 Media Player 的支持及其其他浏览器对 HTML5 的新标签 “VIDEO” 与 “AUDIO” 的支持在不同浏览器中达到相类似的效果。</p>\n</blockquote>\n</li>\n<li><p>22、Firefox Opera 中 OBJECT 元素的默认尺寸为不可视；而 IE 中，OBJECT 默认尺寸为 16 x 16 像素；在 Chrome 和 Safari 下的默认尺寸为 300 x 150 像素。</p>\n<blockquote>\n<p>解决办法：OBJECT 元素为替换元素，应为 OBJECT 元素设置一个明确的宽度和高度。</p>\n</blockquote>\n</li>\n<li><p>23、IE Opera 中，IMG 元素通过其 usemap 属性可以与 MAP 元素的 id 属性及 name 属性关联，而 Firefox Chrome Safari 中仅限于 MAP 元素的 name 属性。</p>\n<blockquote>\n<p>解决办法：若需要 IMG 元素与 MAP 元素相关联，注意通过 IMG 元素的 usemap 属性关联的 MAP 元素的 name 属性的值。</p>\n</blockquote>\n</li>\n<li><p>24、MAP 元素会影响指向 MAP 的元素，其父元素 A 元素的默认链接行为。<br>IE6 IE7 IE8 中，产生自 MAP 元素的事件冒泡路径，不依赖 MAP 本身所处的元素嵌套规则，他会执行到引向 MAP 的元素嵌套结构中。</p>\n<blockquote>\n<p>解决办法：</p>\n<ul>\n<li>注意 MAP 标记与其他标记的嵌套关系，IE6 IE7 IE8 中的 MAP 冒泡机制是根据指向 MAP 标记的标记位置决定的。如果期望所有浏览器冒泡路径基本一致，可以将 MAP 标记放在引用 MAP 的标记的兄弟级别。</li>\n<li>注意 A 标记的默认导航行为触发限制，即使标签嵌套一致，点击事件冒泡路颈 A 标记，也不会在 IE6 IE7 IE8 Firefox 中触发浏览器默认行为产生导航。可以利用 A 标记也会执行点击事件冒泡的特性，使用 A 标记的 “click” 事件代替 “href” 属性执行页面跳转工作。</li>\n</ul>\n</blockquote>\n</li>\n<li><p>25、CENTER 元素在 IE6 IE7 IE8(Q) 中会使自身也居中对齐，除了上述浏览器，在 IE(S) 与 Opera(S) 中 CENTER 元素还会使其内表格中的单元格内文本居中对齐。</p>\n<blockquote>\n<p>解决办法：避免使用 CENTER 标签，使用 CSS 的 ‘text-align’ 特性来代替。</p>\n</blockquote>\n</li>\n<li><p>26、Firefox Chrome Safari 会将 DIV H1~H6 P 元素的 align=”middle” 解释为 align=”center”，从而使这些元素能够居中对齐。<br>Firefox 混杂模式会将 TABLE 元素 align=”middle” 解释为 align=”center”，使 TABLE 元素居中对齐。<br>IE6 IE7 Chrome Safari Opera 及 IE8 Firefox 的混杂模式下，均将 TD TH 元素的 align=”middle” 理解为 align=”center”。</p>\n<blockquote>\n<p>解决办法：align=”middle” 仅在 IMG、OBJECT、APPLET 元素上的 align 属性中是合法值，对于其他元素的 align 属性均为非法。各浏览器在上述三个元素之外的元素上遇到 align=”middle” 均按照自己的理解方式解释。同时除单元格元素的 align 属性之外，其他的 align 属性均被 W3C 官方废弃（Deprecated.），所以应避免使用此属性。</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n","excerpt":"<p>内容如题<br>","more":"</p>\n<blockquote>\n<ul>\n<li><p>1、注释内容含中横线（-）在 Firefox 中可能会使中间内容丢失。</p>\n<blockquote>\n<p>解决办法：按标准推荐的方法写注释标签</p>\n</blockquote>\n</li>\n<li><p>2、各浏览器对于字符编码别名支持的宽泛程度有差异，当指定了浏览器无法识别的字符编码别名时，浏览器会以确定编码的优先级顺序采用设置的更低优先级的字符编码，以此类推。<br>而 Chrome Safari Opera 中对字符编码别名有着比其他浏览器更宽泛的支持。</p>\n<blockquote>\n<p>解决办法：首先，对于动态页面必须确保 HTTP “Content-Type” 头字段的 “charset” 参数与页面自身编码相符，且务必在页面的 META 元素中也声明相符的字符编码信息。对于静态页面，必须保证页面中 META 元素声明中 “http-equiv” 为 “Content-Type” 对应的值中的 “charset” 的值与页面自身编码相符。<br>其次，在设置字符编码别名时，最好使用最通用的、各浏览器均可识别的编码别名。</p>\n</blockquote>\n</li>\n<li><p>3、对于 URI 中非 ASCII 字符，并非所有浏览器都是按照 HTML 4.01 规范中的建议实现的，而且不同浏览器在处理不同形式的 URI 时，表现也有差异。</p>\n<blockquote>\n<p>解决办法：当 URI 中含有非 ASCII 字符时，不要依赖浏览器对 URI 的编码方式，以避免产生差异</p>\n</blockquote>\n</li>\n<li><p>4、如果在 DTD 之前加入注释或其他内容，在某些浏览器中该 DTD 将无法被识别。</p>\n<blockquote>\n<p>解决办法：声明 DTD 时，确保 DTD 之前没有其他字符，即便有，也只能是空格符、换行符和制表符。如将 DTD 放在 HTML 文档的第一行。</p>\n</blockquote>\n</li>\n<li><p>5、Chrome 和 Safari 中标签紧密相邻的行内元素在折行显示时存在错误。</p>\n<blockquote>\n<p>解决办法：避免出现紧密连接的内联元素标签，可以在每个标记之间加入空格或者换行符来避免这个问题。</p>\n</blockquote>\n</li>\n<li><p>6、通过 META 元素可以控制页面定时跳转，对于 http-equiv 属性为 refresh 时对应的 content 属性的值中，跳转时间与跳转 URL 之间需要分隔符分开，如果使用非 ‘;’ 的分隔符时，在某些浏览器下将不能达到期望的效果。</p>\n<blockquote>\n<p>解决办法：</p>\n<ul>\n<li>参照 W3C 的建议，使用服务端进行页面跳转。</li>\n<li>使用合法的，所有浏览器均支持的写法：</li>\n</ul>\n</blockquote>\n</li>\n<li><p>7、IE6/7 及 IE8 混杂模式(Q) 会忽略同一行内 OBJECT、IFRAME 元素之后的空白符。</p>\n<blockquote>\n<p>解决办法：若不希望出现空格，可以将 IFRAME OBJECT 元素设置为块级元素。</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>8、IE6 IE7 IE8(Q) 中当 OBJECT 元素之前的行内文本由 “&nbsp;” 构成，且 “&nbsp;” 宽度之和小于容器宽度时，OBJECT 元素不发生折行；而 “&nbsp;” 宽度之和超过容器时，OBJECT 元素会折行显示。而在 IE8(S) Opera 中，出现上述情况时，OBJECT 元素始终不会发生折行。</p>\n<blockquote>\n<p>解决办法：<br>合理的设置容器及 OBJECT 元素的宽度。若需要 OBJECT 元素不发生折行，则为容器设置 “white-space:nowrap” ；<br>若需要 OBJECT 元素折行，则在 OBJECT 元素之前加入明确的换行符 “<br />“ 。</p>\n</blockquote>\n</li>\n<li><p>9、Chrome 和 Safari 中 BR 元素前的空白符不会被忽略，多余的空白符将被压缩为一个空白符并渲染到 BR 元素之前的行中。</p>\n<blockquote>\n<p>解决办法：删除 BR 元素之前多余的空白符。</p>\n</blockquote>\n</li>\n<li><p>10、单元格的 colspan 属性在 IE 中可能影响 TABLE 元素的自动布局。</p>\n<blockquote>\n<p>解决办法：</p>\n<ul>\n<li>设置 TABLE 的 ‘table-layout’ 特性值为 fixed，使用固定布局的表格元素可避免此问题。</li>\n<li>单元格所跨过的列的宽度都设置成 auto。</li>\n</ul>\n</blockquote>\n</li>\n<li><p>11、在 Firefox 中，TABLE 元素 ‘width’ 属性的百分比值大于 100% 时，Firefox 会按 100% 处理；如果是 CSS 的 ‘width’ 特性，则不会这么处理。</p>\n<blockquote>\n<p>解决办法：给 TABLE 元素设置宽度的时候，不要使用 HTML 属性 ‘width’，请使用 CSS 特性 ‘width’。</p>\n</blockquote>\n</li>\n<li><p>12、在 IE 中，不仅 TD 和 TH 元素，其他一些元素也拥有 noWrap 属性。</p>\n<blockquote>\n<p>解决办法：nowrap 属性是被废弃的属性，使用 CSS 规则 white-space:nowrap 代替这个属性。</p>\n</blockquote>\n</li>\n<li><p>13、IE6 IE7 IE8(Q) 对 COL 和 COLGROUP 元素的属性及部分 CSS 特性支持较好，而IE8(S) Firefox Chrome Safari 不再支持 COL 及 COLGROUP 元素的部分属性及为其设定的 CSS 特性。</p>\n<blockquote>\n<p>解决办法：当使用 COLGROUP COL 时需注意各浏览器对属性及 CSS 样式的设置，避免造成兼容性问题。</p>\n</blockquote>\n</li>\n<li><p>14、若表格设定了大于零的水平单元格间隙 (即 cellspacing 属性)，且其内单元格存在过度设定的 colspan 属性，也就是单元格横跨的列数的设定值多余实际存在的单元格的个数，这时各浏览器对表格的渲染效果存在较大差异。</p>\n<blockquote>\n<p>解决办法：在进行表格布局时，务必精准设定 colspan 属性的值</p>\n</blockquote>\n</li>\n<li><p>15、BASE 元素出现在 BODY 中，且定义了 target 属性，各浏览器表现不一致。</p>\n<blockquote>\n<p>解决办法：不要在 HEAD 元素之外定义 BASE 元素，保证各浏览器兼容。</p>\n</blockquote>\n</li>\n<li><p>16、通常情况下，IE 系列浏览器通过 ActiveX 插件使用 OBJECT 元素引入 Flash，而其他浏览器则是通过相应的 NPAPI 插件使用 EMBED 元素。这造成了各浏览器中插入 Flash 的方式的差异。</p>\n<blockquote>\n<p>解决办法：</p>\n<ul>\n<li>若不考虑 W3C 校验，可统一使用 EMBED 元素嵌入 Flash，这样可以避免因参数不统一导致的兼容性问题。</li>\n<li>若需要考虑 W3C 校验（swfobject Markup Validation Service），则可使用第三种单独使用 OBJECT 与 PARAM 元素的方式。</li>\n<li>若必须使用 OBJECT 嵌套 EMBED 元素这种混合方式，则要保证 Flash 文件 URL、为 Flash 传递的参数、宽度、高度、wmode 等参数保持统一。</li>\n<li>可以使用开源的 SWFObject 引入 Flash。（请参见：swfobject）</li>\n</ul>\n</blockquote>\n</li>\n<li><p>17、该问题将造成局部的布局混乱。</p>\n<blockquote>\n<p>解决办法：为了防止这种无 “src” 的 IMG 元素对页面产生布局影响，需要设置这种 IMG 的 ‘display’ 特性为 ‘none’。</p>\n</blockquote>\n</li>\n<li><p>18、alt 属性在 IE6 IE7 IE8(Q) 下具有双重意义。在给 IMG、AREA、INPUT[type=image] 元素设置的 alt 属性值不但可以作为该元素的替代文字，在该元素没有指定 title 属性时，还可以作为提示信息（tooltip）被显示出来。</p>\n<blockquote>\n<p>解决办法：</p>\n<ul>\n<li>若用户需要显示提示框，则指定 title 属性；</li>\n<li>若用户不需要显示提示框，则指定 title=””。</li>\n</ul>\n</blockquote>\n</li>\n<li><p>19、PNG24 格式图片可以携带 Alpha 半透明通道，以便呈现从透明到不透明间过渡色彩效果，但是 IE6 不支持这种格式原有的透明特性。</p>\n<blockquote>\n<p>解决办法：</p>\n</blockquote>\n</li>\n<li>使用 IE 专有滤镜 AlphaImageLoader Filter 来修复 IE6 透明通道问题</li>\n<li>或者使用脚本批量处理方式：</li>\n</ul>\n</blockquote>\n<pre><code>function fixpng24(){\n    var arVersion = navigator.appVersion.split(&quot;MSIE&quot;);\n    var version = parseFloat(arVersion[1]);\n    if ((version &gt;= 5.5) &amp;&amp; (document.body.filters)){\n       for(var i=0; i&lt;document.images.length; i++){\n          var img = document.images[i];\n          if (img.src.toLowerCase().slice(-3) == &quot;png&quot;){\n             var imgID = (img.id) ? &quot;id=&apos;&quot; + img.id + &quot;&apos; &quot; : &quot;&quot;;\n             var imgClass = (img.className) ? &quot;class=&apos;&quot; + img.className + &quot;&apos; &quot; : &quot;&quot;;\n             var imgTitle = (img.title) ? &quot;title=&apos;&quot; + img.title + &quot;&apos; &quot; : &quot;title=&apos;&quot; + img.alt + &quot;&apos; &quot;;\n             var imgStyle = &quot;display:inline-block;&quot; + img.style.cssText ;\n             if (img.align == &quot;left&quot;) imgStyle = &quot;float:left;&quot; + imgStyle;\n             if (img.align == &quot;right&quot;) imgStyle = &quot;float:right;&quot; + imgStyle;\n             if (img.parentElement.href) imgStyle = &quot;cursor:pointer;&quot; + imgStyle;\n             var strNewHTML = &quot;&lt;span &quot; + imgID + imgClass + imgTitle\n             + &quot; style=\\&quot;width:&quot; + img.width + &quot;px; height:&quot; + img.height + &quot;px;&quot; + imgStyle\n             + &quot;filter:progid:DXImageTransform.Microsoft.AlphaImageLoader&quot;\n             + &quot;(src=&apos;&quot; + img.src + &quot;&apos;, sizingMethod=&apos;scale&apos;);\\&quot;&gt;&lt;/span&gt;&quot;;\n             img.outerHTML = strNewHTML;\n             i--;\n          }\n       }\n    }\n}\n</code></pre><blockquote>\n<ul>\n<li><p>20、当给一个现有的 IMG 元素重设其 “src” 为其当前的 “src” 时，只有 IE6 会重现载入该图片，其他浏览器则不会。</p>\n<blockquote>\n<p>解决办法：如果需要重复设置相同的 src 值时，均触发 IMG 的 onload 事件，或者需要每次均从服务器端下载图片数据的时候，可以采用图片地址后加上随机数或当前时间戳参数的手段，避免内容被缓存。</p>\n</blockquote>\n</li>\n<li><p>21、IE Chrome Safari 支持通过为 OBJECT 元素设置 classid 引入 Windows 下的 Media Player 或 Flash 插件。而 Windows 版的 Firefox 与 Opera 无法支持这种形式引入这些插件。</p>\n<blockquote>\n<p>解决办法：由于某些浏览器原生无法支持 OBJECT 元素使用 classid 属性引入 Media Player 插件，所以为保证最大的兼容性，应避免使用此方式在页面中播放媒体文件。<br>可以考虑使用 Flash，或者合理的利用 IE 对 Media Player 的支持及其其他浏览器对 HTML5 的新标签 “VIDEO” 与 “AUDIO” 的支持在不同浏览器中达到相类似的效果。</p>\n</blockquote>\n</li>\n<li><p>22、Firefox Opera 中 OBJECT 元素的默认尺寸为不可视；而 IE 中，OBJECT 默认尺寸为 16 x 16 像素；在 Chrome 和 Safari 下的默认尺寸为 300 x 150 像素。</p>\n<blockquote>\n<p>解决办法：OBJECT 元素为替换元素，应为 OBJECT 元素设置一个明确的宽度和高度。</p>\n</blockquote>\n</li>\n<li><p>23、IE Opera 中，IMG 元素通过其 usemap 属性可以与 MAP 元素的 id 属性及 name 属性关联，而 Firefox Chrome Safari 中仅限于 MAP 元素的 name 属性。</p>\n<blockquote>\n<p>解决办法：若需要 IMG 元素与 MAP 元素相关联，注意通过 IMG 元素的 usemap 属性关联的 MAP 元素的 name 属性的值。</p>\n</blockquote>\n</li>\n<li><p>24、MAP 元素会影响指向 MAP 的元素，其父元素 A 元素的默认链接行为。<br>IE6 IE7 IE8 中，产生自 MAP 元素的事件冒泡路径，不依赖 MAP 本身所处的元素嵌套规则，他会执行到引向 MAP 的元素嵌套结构中。</p>\n<blockquote>\n<p>解决办法：</p>\n<ul>\n<li>注意 MAP 标记与其他标记的嵌套关系，IE6 IE7 IE8 中的 MAP 冒泡机制是根据指向 MAP 标记的标记位置决定的。如果期望所有浏览器冒泡路径基本一致，可以将 MAP 标记放在引用 MAP 的标记的兄弟级别。</li>\n<li>注意 A 标记的默认导航行为触发限制，即使标签嵌套一致，点击事件冒泡路颈 A 标记，也不会在 IE6 IE7 IE8 Firefox 中触发浏览器默认行为产生导航。可以利用 A 标记也会执行点击事件冒泡的特性，使用 A 标记的 “click” 事件代替 “href” 属性执行页面跳转工作。</li>\n</ul>\n</blockquote>\n</li>\n<li><p>25、CENTER 元素在 IE6 IE7 IE8(Q) 中会使自身也居中对齐，除了上述浏览器，在 IE(S) 与 Opera(S) 中 CENTER 元素还会使其内表格中的单元格内文本居中对齐。</p>\n<blockquote>\n<p>解决办法：避免使用 CENTER 标签，使用 CSS 的 ‘text-align’ 特性来代替。</p>\n</blockquote>\n</li>\n<li><p>26、Firefox Chrome Safari 会将 DIV H1~H6 P 元素的 align=”middle” 解释为 align=”center”，从而使这些元素能够居中对齐。<br>Firefox 混杂模式会将 TABLE 元素 align=”middle” 解释为 align=”center”，使 TABLE 元素居中对齐。<br>IE6 IE7 Chrome Safari Opera 及 IE8 Firefox 的混杂模式下，均将 TD TH 元素的 align=”middle” 理解为 align=”center”。</p>\n<blockquote>\n<p>解决办法：align=”middle” 仅在 IMG、OBJECT、APPLET 元素上的 align 属性中是合法值，对于其他元素的 align 属性均为非法。各浏览器在上述三个元素之外的元素上遇到 align=”middle” 均按照自己的理解方式解释。同时除单元格元素的 align 属性之外，其他的 align 属性均被 W3C 官方废弃（Deprecated.），所以应避免使用此属性。</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>"},{"title":"作用域链和标识符详细解析","date":"2015-07-31T05:42:30.000Z","keywords":"作用域链, JavaScript, js标识符","_content":"\n　　每一个 JavaScript 函数都被表示为对象。进一步说，它是一个函数实例。函数对象正如其他对象那样，拥有你可以编程访问的属性，和一系列不能被程序访问，仅供 JavaScript 引擎使用的内部属性。其中一个内部属性是[[Scope]]，由 ECMA-262 标准第三版定义。\n<!--more-->\n　　内部[[Scope]]属性包含一个函数被创建的作用域中对象的集合。此集合被称为函数的作用域链，它决定哪些数据可由函数访问。此函数作用域链中的每个对象被称为一个可变对象，每个可变对象都以“键值对”的形式存在。当一个函数创建后，它的作用域链被填充以对象，这些对象代表创建此函数的环境中可访问的数据。例如下面这个全局函数：\n\n\tfunction add(num1, num2){\n\t\tvar sum = num1 + num2;\n\t\treturn sum;\n\t}\n　　当 add()函数创建后，它的作用域链中填入一个单独的可变对象，此全局对象代表了所有全局范围定义的变量。此全局对象包含诸如窗口、浏览器和文档之类的访问接口。下图指出了它们之间的关系（注意：此图中只画出全局变量中很少的一部分，其他部分还很多）。\n![add()函数的作用域链](http://7xkj1z.com1.z0.glb.clouddn.com/作用域链img-1.png \"add()函数的作用域链\")\nadd 函数的作用域链将会在运行时用到。假设运行下面的代码：\n\n\tvar total = add(5, 10);\n　　运行此 add 函数时建立一个内部对象，称作“运行期上下文”。一个运行期上下文定义了一个函数运行时的环境。对函数的每次运行而言，每个运行期上下文都是独一的，所以多次调用同一个函数就会导致多次创建运行期上下文。当函数执行完毕，运行期上下文就被销毁。\n\n　　一个运行期上下文有它自己的作用域链，用于标识符解析。当运行期上下文被创建时，它的作用域链被初始化，连同运行函数的[[Scope]]属性中所包含的对象。这些值按照它们出现在函数中的顺序，被复制到运行期上下文的作用域链中。这项工作一旦完成，一个被称作“激活对象”的新对象就为运行期上下文创建好了。此激活对象作为函数执行期的一个可变对象，包含访问所有局部变量，命名参数，参数集合，和 this 的接口。然后，此对象被推入作用域链的前端。当作用域链被销毁时，激活对象也一同销毁。下图显示了前面实例代码所对应的运行期上下文和它的作用域链。\n![运行 add()时的作用域链](http://7xkj1z.com1.z0.glb.clouddn.com/作用域链img-2.png \"运行 add()时的作用域链\")\n　　在函数运行过程中，每遇到一个变量，标识符识别过程要决定从哪里获得或者存储数据。此过程搜索运行期上下文的作用域链，查找同名的标识符。搜索工作从运行函数的激活目标之作用域链的前端开始。如果找到了，那么就使用这个具有指定标识符的变量；如果没找到，搜索工作将进入作用域链的下一个对象。此过程持续运行，直到标识符被找到，或者没有更多对象可用于搜索，这种情况下标识符将被认为是未定义的。函数运行时每个标识符都要经过这样的搜索过程，例如前面的例子中，函数访问 sum，num1，num2 时都会产生这样的搜索过程。\n\n---\n以上就是作用域链的详细工作过程和原理。","source":"_posts/作用域链和标识符详细解析.md","raw":"title: 作用域链和标识符详细解析\ndate: 2015-07-31 13:42:30\ntags: 高性能JavaScript学习笔记\ncategories: 作用域链和标识符详细解析\nkeywords: 作用域链, JavaScript, js标识符\n---\n\n　　每一个 JavaScript 函数都被表示为对象。进一步说，它是一个函数实例。函数对象正如其他对象那样，拥有你可以编程访问的属性，和一系列不能被程序访问，仅供 JavaScript 引擎使用的内部属性。其中一个内部属性是[[Scope]]，由 ECMA-262 标准第三版定义。\n<!--more-->\n　　内部[[Scope]]属性包含一个函数被创建的作用域中对象的集合。此集合被称为函数的作用域链，它决定哪些数据可由函数访问。此函数作用域链中的每个对象被称为一个可变对象，每个可变对象都以“键值对”的形式存在。当一个函数创建后，它的作用域链被填充以对象，这些对象代表创建此函数的环境中可访问的数据。例如下面这个全局函数：\n\n\tfunction add(num1, num2){\n\t\tvar sum = num1 + num2;\n\t\treturn sum;\n\t}\n　　当 add()函数创建后，它的作用域链中填入一个单独的可变对象，此全局对象代表了所有全局范围定义的变量。此全局对象包含诸如窗口、浏览器和文档之类的访问接口。下图指出了它们之间的关系（注意：此图中只画出全局变量中很少的一部分，其他部分还很多）。\n![add()函数的作用域链](http://7xkj1z.com1.z0.glb.clouddn.com/作用域链img-1.png \"add()函数的作用域链\")\nadd 函数的作用域链将会在运行时用到。假设运行下面的代码：\n\n\tvar total = add(5, 10);\n　　运行此 add 函数时建立一个内部对象，称作“运行期上下文”。一个运行期上下文定义了一个函数运行时的环境。对函数的每次运行而言，每个运行期上下文都是独一的，所以多次调用同一个函数就会导致多次创建运行期上下文。当函数执行完毕，运行期上下文就被销毁。\n\n　　一个运行期上下文有它自己的作用域链，用于标识符解析。当运行期上下文被创建时，它的作用域链被初始化，连同运行函数的[[Scope]]属性中所包含的对象。这些值按照它们出现在函数中的顺序，被复制到运行期上下文的作用域链中。这项工作一旦完成，一个被称作“激活对象”的新对象就为运行期上下文创建好了。此激活对象作为函数执行期的一个可变对象，包含访问所有局部变量，命名参数，参数集合，和 this 的接口。然后，此对象被推入作用域链的前端。当作用域链被销毁时，激活对象也一同销毁。下图显示了前面实例代码所对应的运行期上下文和它的作用域链。\n![运行 add()时的作用域链](http://7xkj1z.com1.z0.glb.clouddn.com/作用域链img-2.png \"运行 add()时的作用域链\")\n　　在函数运行过程中，每遇到一个变量，标识符识别过程要决定从哪里获得或者存储数据。此过程搜索运行期上下文的作用域链，查找同名的标识符。搜索工作从运行函数的激活目标之作用域链的前端开始。如果找到了，那么就使用这个具有指定标识符的变量；如果没找到，搜索工作将进入作用域链的下一个对象。此过程持续运行，直到标识符被找到，或者没有更多对象可用于搜索，这种情况下标识符将被认为是未定义的。函数运行时每个标识符都要经过这样的搜索过程，例如前面的例子中，函数访问 sum，num1，num2 时都会产生这样的搜索过程。\n\n---\n以上就是作用域链的详细工作过程和原理。","slug":"作用域链和标识符详细解析","published":1,"updated":"2016-10-31T07:25:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciuyzlutl000de6tbxw9ys7yp","content":"<p>　　每一个 JavaScript 函数都被表示为对象。进一步说，它是一个函数实例。函数对象正如其他对象那样，拥有你可以编程访问的属性，和一系列不能被程序访问，仅供 JavaScript 引擎使用的内部属性。其中一个内部属性是[[Scope]]，由 ECMA-262 标准第三版定义。<br><a id=\"more\"></a><br>　　内部[[Scope]]属性包含一个函数被创建的作用域中对象的集合。此集合被称为函数的作用域链，它决定哪些数据可由函数访问。此函数作用域链中的每个对象被称为一个可变对象，每个可变对象都以“键值对”的形式存在。当一个函数创建后，它的作用域链被填充以对象，这些对象代表创建此函数的环境中可访问的数据。例如下面这个全局函数：</p>\n<pre><code>function add(num1, num2){\n    var sum = num1 + num2;\n    return sum;\n}\n</code></pre><p>　　当 add()函数创建后，它的作用域链中填入一个单独的可变对象，此全局对象代表了所有全局范围定义的变量。此全局对象包含诸如窗口、浏览器和文档之类的访问接口。下图指出了它们之间的关系（注意：此图中只画出全局变量中很少的一部分，其他部分还很多）。<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/作用域链img-1.png\" alt=\"add()函数的作用域链\" title=\"add()函数的作用域链\"><br>add 函数的作用域链将会在运行时用到。假设运行下面的代码：</p>\n<pre><code>var total = add(5, 10);\n</code></pre><p>　　运行此 add 函数时建立一个内部对象，称作“运行期上下文”。一个运行期上下文定义了一个函数运行时的环境。对函数的每次运行而言，每个运行期上下文都是独一的，所以多次调用同一个函数就会导致多次创建运行期上下文。当函数执行完毕，运行期上下文就被销毁。</p>\n<p>　　一个运行期上下文有它自己的作用域链，用于标识符解析。当运行期上下文被创建时，它的作用域链被初始化，连同运行函数的[[Scope]]属性中所包含的对象。这些值按照它们出现在函数中的顺序，被复制到运行期上下文的作用域链中。这项工作一旦完成，一个被称作“激活对象”的新对象就为运行期上下文创建好了。此激活对象作为函数执行期的一个可变对象，包含访问所有局部变量，命名参数，参数集合，和 this 的接口。然后，此对象被推入作用域链的前端。当作用域链被销毁时，激活对象也一同销毁。下图显示了前面实例代码所对应的运行期上下文和它的作用域链。<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/作用域链img-2.png\" alt=\"运行 add()时的作用域链\" title=\"运行 add()时的作用域链\"><br>　　在函数运行过程中，每遇到一个变量，标识符识别过程要决定从哪里获得或者存储数据。此过程搜索运行期上下文的作用域链，查找同名的标识符。搜索工作从运行函数的激活目标之作用域链的前端开始。如果找到了，那么就使用这个具有指定标识符的变量；如果没找到，搜索工作将进入作用域链的下一个对象。此过程持续运行，直到标识符被找到，或者没有更多对象可用于搜索，这种情况下标识符将被认为是未定义的。函数运行时每个标识符都要经过这样的搜索过程，例如前面的例子中，函数访问 sum，num1，num2 时都会产生这样的搜索过程。</p>\n<hr>\n<p>以上就是作用域链的详细工作过程和原理。</p>\n","excerpt":"<p>　　每一个 JavaScript 函数都被表示为对象。进一步说，它是一个函数实例。函数对象正如其他对象那样，拥有你可以编程访问的属性，和一系列不能被程序访问，仅供 JavaScript 引擎使用的内部属性。其中一个内部属性是[[Scope]]，由 ECMA-262 标准第三版定义。<br>","more":"<br>　　内部[[Scope]]属性包含一个函数被创建的作用域中对象的集合。此集合被称为函数的作用域链，它决定哪些数据可由函数访问。此函数作用域链中的每个对象被称为一个可变对象，每个可变对象都以“键值对”的形式存在。当一个函数创建后，它的作用域链被填充以对象，这些对象代表创建此函数的环境中可访问的数据。例如下面这个全局函数：</p>\n<pre><code>function add(num1, num2){\n    var sum = num1 + num2;\n    return sum;\n}\n</code></pre><p>　　当 add()函数创建后，它的作用域链中填入一个单独的可变对象，此全局对象代表了所有全局范围定义的变量。此全局对象包含诸如窗口、浏览器和文档之类的访问接口。下图指出了它们之间的关系（注意：此图中只画出全局变量中很少的一部分，其他部分还很多）。<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/作用域链img-1.png\" alt=\"add()函数的作用域链\" title=\"add()函数的作用域链\"><br>add 函数的作用域链将会在运行时用到。假设运行下面的代码：</p>\n<pre><code>var total = add(5, 10);\n</code></pre><p>　　运行此 add 函数时建立一个内部对象，称作“运行期上下文”。一个运行期上下文定义了一个函数运行时的环境。对函数的每次运行而言，每个运行期上下文都是独一的，所以多次调用同一个函数就会导致多次创建运行期上下文。当函数执行完毕，运行期上下文就被销毁。</p>\n<p>　　一个运行期上下文有它自己的作用域链，用于标识符解析。当运行期上下文被创建时，它的作用域链被初始化，连同运行函数的[[Scope]]属性中所包含的对象。这些值按照它们出现在函数中的顺序，被复制到运行期上下文的作用域链中。这项工作一旦完成，一个被称作“激活对象”的新对象就为运行期上下文创建好了。此激活对象作为函数执行期的一个可变对象，包含访问所有局部变量，命名参数，参数集合，和 this 的接口。然后，此对象被推入作用域链的前端。当作用域链被销毁时，激活对象也一同销毁。下图显示了前面实例代码所对应的运行期上下文和它的作用域链。<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/作用域链img-2.png\" alt=\"运行 add()时的作用域链\" title=\"运行 add()时的作用域链\"><br>　　在函数运行过程中，每遇到一个变量，标识符识别过程要决定从哪里获得或者存储数据。此过程搜索运行期上下文的作用域链，查找同名的标识符。搜索工作从运行函数的激活目标之作用域链的前端开始。如果找到了，那么就使用这个具有指定标识符的变量；如果没找到，搜索工作将进入作用域链的下一个对象。此过程持续运行，直到标识符被找到，或者没有更多对象可用于搜索，这种情况下标识符将被认为是未定义的。函数运行时每个标识符都要经过这样的搜索过程，例如前面的例子中，函数访问 sum，num1，num2 时都会产生这样的搜索过程。</p>\n<hr>\n<p>以上就是作用域链的详细工作过程和原理。</p>"},{"title":"JavaScript优化之工具","date":"2015-08-05T20:33:15.000Z","keywords":"高性能JavaScript","_content":"**第十章 Tools 工具 **\n===\n本章主要介绍优化性能工具的使用，具体内容可以看原文，这里只是简单的叙述一下。\n<!--more-->\n---\n> - Profiling 性能分析:\n在脚本运行期定时执行不同函数和操作，找出需要优化的部分。\n> - Network analysis 网络分析:\n检查图片，样式表，和脚本的加载过程，汇报它们对整个页面加载和渲染的影响。\n\n---\n\n> - 在调整代码之前，您应该确保脚本和其他资源的加载过程已经优化过了。图片和样式表加载会影响脚本加载，这取决于浏览器允许多少并发请求，有多少资源需要加载。\n> - YUI 分析器（http://developer.yahoo.com/yui/profiler/），由 Nicholas Zakas 提供，是用 JavaScript 编写的\nJavaScript 分析器。除了计时功能，它还提供了用于函数、对象、和构造器的性能分析接口，还包括性能分析数据的详细报告。它可以跨浏览器工作，其输出数据可提供更强大的报告和分析。YUI 分析器提供一个通用定时器用于收集性能数据。Profiler 提供一些静态函数，用于启动和停止命名定时器，以及获取性能数据。\n\n\tvar count = 10000, i, element;\n\tY.Profiler.start('createElement');\n\tfor (i = 0; i < count; i++) {\n\telement = document.createElement ('div');\n\t}\n\tY.Profiler.stop('createElement');\n\talert('created ' + count + ' in ' + Y.Profiler.getAverage('createElement') + 'ms');\n函数分析只需要注册一下。注册的函数被收集性能数据的代码调用。例如，要分析第二章提到的全局\ninitUI 方法，仅仅需要传入它的名字：\n\n\tY.Profiler.registerFunction(\"initUI\");\n\n---\n> - 使用匿名函数或函数分配会造成分析器的数据模糊。由于这是 JavaScript 的通用模式，许多被分析的函数可能是匿名的， 对它们测量和分析很困难或根本无法进行。 分析匿名函数的最佳办法是给它们取个名字。使用指针指向对象方法而不是闭包，可以实现最广泛的分析覆盖。\n\n---\nSummary 总结\n===\n---\n当网页或应用程序变慢时，分析网上传来的资源，分析脚本的运行性能，使你能够集中精力在那些需要努力优化的地方。\n> - 使用网络分析器找出加载脚本和其它页面资源的瓶颈所在，这有助于决定哪些脚本需要延迟加载，或者进行进一步分析。\n> - 传统的智慧告诉我们应尽量减少 HTTP 请求的数量，尽量延迟加载脚本以使页面渲染速度更快，向用户提供更好的整体体验。\n> - 使用性能分析器找出脚本运行时速度慢的部分，检查每个函数所花费的时间，以及函数被调用的次数，通过调用栈自身提供的一些线索来找出哪些地方应当努力优化。\n> - 虽然花费时间和调用次数通常是数据中最有价值的点，还是应当仔细察看函数的调用过程，可能发现其它优化方法。\n\n这些工具在那些现代代码所要运行的编程环境中不再神秘。在开始优化工作之前使用它们，确保开发时间用在解决问题的刀刃上。","source":"_posts/高性能JavaScrip10.md","raw":"title: JavaScript优化之工具\ndate: 2015-08-6 04:33:15\ntags: 高性能JavaScript学习笔记\ncategories: 高性能JavaScript-10\nkeywords: 高性能JavaScript\n---\n**第十章 Tools 工具 **\n===\n本章主要介绍优化性能工具的使用，具体内容可以看原文，这里只是简单的叙述一下。\n<!--more-->\n---\n> - Profiling 性能分析:\n在脚本运行期定时执行不同函数和操作，找出需要优化的部分。\n> - Network analysis 网络分析:\n检查图片，样式表，和脚本的加载过程，汇报它们对整个页面加载和渲染的影响。\n\n---\n\n> - 在调整代码之前，您应该确保脚本和其他资源的加载过程已经优化过了。图片和样式表加载会影响脚本加载，这取决于浏览器允许多少并发请求，有多少资源需要加载。\n> - YUI 分析器（http://developer.yahoo.com/yui/profiler/），由 Nicholas Zakas 提供，是用 JavaScript 编写的\nJavaScript 分析器。除了计时功能，它还提供了用于函数、对象、和构造器的性能分析接口，还包括性能分析数据的详细报告。它可以跨浏览器工作，其输出数据可提供更强大的报告和分析。YUI 分析器提供一个通用定时器用于收集性能数据。Profiler 提供一些静态函数，用于启动和停止命名定时器，以及获取性能数据。\n\n\tvar count = 10000, i, element;\n\tY.Profiler.start('createElement');\n\tfor (i = 0; i < count; i++) {\n\telement = document.createElement ('div');\n\t}\n\tY.Profiler.stop('createElement');\n\talert('created ' + count + ' in ' + Y.Profiler.getAverage('createElement') + 'ms');\n函数分析只需要注册一下。注册的函数被收集性能数据的代码调用。例如，要分析第二章提到的全局\ninitUI 方法，仅仅需要传入它的名字：\n\n\tY.Profiler.registerFunction(\"initUI\");\n\n---\n> - 使用匿名函数或函数分配会造成分析器的数据模糊。由于这是 JavaScript 的通用模式，许多被分析的函数可能是匿名的， 对它们测量和分析很困难或根本无法进行。 分析匿名函数的最佳办法是给它们取个名字。使用指针指向对象方法而不是闭包，可以实现最广泛的分析覆盖。\n\n---\nSummary 总结\n===\n---\n当网页或应用程序变慢时，分析网上传来的资源，分析脚本的运行性能，使你能够集中精力在那些需要努力优化的地方。\n> - 使用网络分析器找出加载脚本和其它页面资源的瓶颈所在，这有助于决定哪些脚本需要延迟加载，或者进行进一步分析。\n> - 传统的智慧告诉我们应尽量减少 HTTP 请求的数量，尽量延迟加载脚本以使页面渲染速度更快，向用户提供更好的整体体验。\n> - 使用性能分析器找出脚本运行时速度慢的部分，检查每个函数所花费的时间，以及函数被调用的次数，通过调用栈自身提供的一些线索来找出哪些地方应当努力优化。\n> - 虽然花费时间和调用次数通常是数据中最有价值的点，还是应当仔细察看函数的调用过程，可能发现其它优化方法。\n\n这些工具在那些现代代码所要运行的编程环境中不再神秘。在开始优化工作之前使用它们，确保开发时间用在解决问题的刀刃上。","slug":"高性能JavaScrip10","published":1,"updated":"2016-10-31T07:25:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciuyzluts000he6tbw7vph5ua","content":"<h1 id=\"第十章-Tools-工具\"><a href=\"#第十章-Tools-工具\" class=\"headerlink\" title=\"第十章 Tools 工具 \"></a><strong>第十章 Tools 工具 </strong></h1><p>本章主要介绍优化性能工具的使用，具体内容可以看原文，这里只是简单的叙述一下。</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><a id=\"more\"></a></h2><blockquote>\n<ul>\n<li>Profiling 性能分析:<br>在脚本运行期定时执行不同函数和操作，找出需要优化的部分。</li>\n<li>Network analysis 网络分析:<br>检查图片，样式表，和脚本的加载过程，汇报它们对整个页面加载和渲染的影响。</li>\n</ul>\n</blockquote>\n<hr>\n<blockquote>\n<ul>\n<li>在调整代码之前，您应该确保脚本和其他资源的加载过程已经优化过了。图片和样式表加载会影响脚本加载，这取决于浏览器允许多少并发请求，有多少资源需要加载。</li>\n<li>YUI 分析器（<a href=\"http://developer.yahoo.com/yui/profiler/），由\" target=\"_blank\" rel=\"external\">http://developer.yahoo.com/yui/profiler/），由</a> Nicholas Zakas 提供，是用 JavaScript 编写的<br>JavaScript 分析器。除了计时功能，它还提供了用于函数、对象、和构造器的性能分析接口，还包括性能分析数据的详细报告。它可以跨浏览器工作，其输出数据可提供更强大的报告和分析。YUI 分析器提供一个通用定时器用于收集性能数据。Profiler 提供一些静态函数，用于启动和停止命名定时器，以及获取性能数据。</li>\n</ul>\n</blockquote>\n<pre><code>var count = 10000, i, element;\nY.Profiler.start(&apos;createElement&apos;);\nfor (i = 0; i &lt; count; i++) {\nelement = document.createElement (&apos;div&apos;);\n}\nY.Profiler.stop(&apos;createElement&apos;);\nalert(&apos;created &apos; + count + &apos; in &apos; + Y.Profiler.getAverage(&apos;createElement&apos;) + &apos;ms&apos;);\n</code></pre><p>函数分析只需要注册一下。注册的函数被收集性能数据的代码调用。例如，要分析第二章提到的全局<br>initUI 方法，仅仅需要传入它的名字：</p>\n<pre><code>Y.Profiler.registerFunction(&quot;initUI&quot;);\n</code></pre><hr>\n<blockquote>\n<ul>\n<li>使用匿名函数或函数分配会造成分析器的数据模糊。由于这是 JavaScript 的通用模式，许多被分析的函数可能是匿名的， 对它们测量和分析很困难或根本无法进行。 分析匿名函数的最佳办法是给它们取个名字。使用指针指向对象方法而不是闭包，可以实现最广泛的分析覆盖。</li>\n</ul>\n</blockquote>\n<hr>\n<h1 id=\"Summary-总结\"><a href=\"#Summary-总结\" class=\"headerlink\" title=\"Summary 总结\"></a>Summary 总结</h1><hr>\n<p>当网页或应用程序变慢时，分析网上传来的资源，分析脚本的运行性能，使你能够集中精力在那些需要努力优化的地方。</p>\n<blockquote>\n<ul>\n<li>使用网络分析器找出加载脚本和其它页面资源的瓶颈所在，这有助于决定哪些脚本需要延迟加载，或者进行进一步分析。</li>\n<li>传统的智慧告诉我们应尽量减少 HTTP 请求的数量，尽量延迟加载脚本以使页面渲染速度更快，向用户提供更好的整体体验。</li>\n<li>使用性能分析器找出脚本运行时速度慢的部分，检查每个函数所花费的时间，以及函数被调用的次数，通过调用栈自身提供的一些线索来找出哪些地方应当努力优化。</li>\n<li>虽然花费时间和调用次数通常是数据中最有价值的点，还是应当仔细察看函数的调用过程，可能发现其它优化方法。</li>\n</ul>\n</blockquote>\n<p>这些工具在那些现代代码所要运行的编程环境中不再神秘。在开始优化工作之前使用它们，确保开发时间用在解决问题的刀刃上。</p>\n","excerpt":"<h1 id=\"第十章-Tools-工具\"><a href=\"#第十章-Tools-工具\" class=\"headerlink\" title=\"第十章 Tools 工具 \"></a><strong>第十章 Tools 工具 </strong></h1><p>本章主要介绍优化性能工具的使用，具体内容可以看原文，这里只是简单的叙述一下。</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a>","more":"</h2><blockquote>\n<ul>\n<li>Profiling 性能分析:<br>在脚本运行期定时执行不同函数和操作，找出需要优化的部分。</li>\n<li>Network analysis 网络分析:<br>检查图片，样式表，和脚本的加载过程，汇报它们对整个页面加载和渲染的影响。</li>\n</ul>\n</blockquote>\n<hr>\n<blockquote>\n<ul>\n<li>在调整代码之前，您应该确保脚本和其他资源的加载过程已经优化过了。图片和样式表加载会影响脚本加载，这取决于浏览器允许多少并发请求，有多少资源需要加载。</li>\n<li>YUI 分析器（<a href=\"http://developer.yahoo.com/yui/profiler/），由\">http://developer.yahoo.com/yui/profiler/），由</a> Nicholas Zakas 提供，是用 JavaScript 编写的<br>JavaScript 分析器。除了计时功能，它还提供了用于函数、对象、和构造器的性能分析接口，还包括性能分析数据的详细报告。它可以跨浏览器工作，其输出数据可提供更强大的报告和分析。YUI 分析器提供一个通用定时器用于收集性能数据。Profiler 提供一些静态函数，用于启动和停止命名定时器，以及获取性能数据。</li>\n</ul>\n</blockquote>\n<pre><code>var count = 10000, i, element;\nY.Profiler.start(&apos;createElement&apos;);\nfor (i = 0; i &lt; count; i++) {\nelement = document.createElement (&apos;div&apos;);\n}\nY.Profiler.stop(&apos;createElement&apos;);\nalert(&apos;created &apos; + count + &apos; in &apos; + Y.Profiler.getAverage(&apos;createElement&apos;) + &apos;ms&apos;);\n</code></pre><p>函数分析只需要注册一下。注册的函数被收集性能数据的代码调用。例如，要分析第二章提到的全局<br>initUI 方法，仅仅需要传入它的名字：</p>\n<pre><code>Y.Profiler.registerFunction(&quot;initUI&quot;);\n</code></pre><hr>\n<blockquote>\n<ul>\n<li>使用匿名函数或函数分配会造成分析器的数据模糊。由于这是 JavaScript 的通用模式，许多被分析的函数可能是匿名的， 对它们测量和分析很困难或根本无法进行。 分析匿名函数的最佳办法是给它们取个名字。使用指针指向对象方法而不是闭包，可以实现最广泛的分析覆盖。</li>\n</ul>\n</blockquote>\n<hr>\n<h1 id=\"Summary-总结\"><a href=\"#Summary-总结\" class=\"headerlink\" title=\"Summary 总结\"></a>Summary 总结</h1><hr>\n<p>当网页或应用程序变慢时，分析网上传来的资源，分析脚本的运行性能，使你能够集中精力在那些需要努力优化的地方。</p>\n<blockquote>\n<ul>\n<li>使用网络分析器找出加载脚本和其它页面资源的瓶颈所在，这有助于决定哪些脚本需要延迟加载，或者进行进一步分析。</li>\n<li>传统的智慧告诉我们应尽量减少 HTTP 请求的数量，尽量延迟加载脚本以使页面渲染速度更快，向用户提供更好的整体体验。</li>\n<li>使用性能分析器找出脚本运行时速度慢的部分，检查每个函数所花费的时间，以及函数被调用的次数，通过调用栈自身提供的一些线索来找出哪些地方应当努力优化。</li>\n<li>虽然花费时间和调用次数通常是数据中最有价值的点，还是应当仔细察看函数的调用过程，可能发现其它优化方法。</li>\n</ul>\n</blockquote>\n<p>这些工具在那些现代代码所要运行的编程环境中不再神秘。在开始优化工作之前使用它们，确保开发时间用在解决问题的刀刃上。</p>"},{"title":"关于主题","date":"2015-07-28T09:28:18.000Z","keywords":"hexo, smackdown theme, hexo主题","_content":"很早就搭出的博客，一直没有时间折腾，大三的时间实在是太紧了。这段时间终于腾出点时间，能让我好好的收拾一下自己的博客。将主题优化了一下，本主题基于 [Yilia](https://github.com/litten/hexo-theme-yilia)主题做的优化。后续我会把我优化后的主题传到[我的github](https://github.com/winnerweb)上。\n还有很多不足之处和bug需要更改，希望大家评论告诉我，看到一定回复。\n<!--more-->\n**体验手机版的可以扫下面的二维码。**\n![GitHub Mark](http://7xkj1z.com1.z0.glb.clouddn.com/二维码.png \"GitHub Mark\")\n\n---\n>- Yilia 是为 hexo 2.4+制作的主题。 \n>- 响应式开发\n>- 崇尚极致的性能。\n>- 主题能很好的兼容移动端。\n>- **因为我优化的主题（包括一些颜色和背景）可能比较让人眼花缭乱，所以增加了阅读模式，关闭背景图片，方便阅读（有时因为图片加载问题可能会出现花屏现象，可以Ctrl+A来解决）。**\n\n** * 以下内容转自Yilia原主题的README* **\n===\n---\n关于主题：\n===\n- 我喜欢简约。所以近期文章，搜索框都拿掉了\n- 接地气一点。所以用上了jiathis分享，友言评论，以及baidu的cdn\n- 追求移动端的体验\n- 让大家把注意力放到内容上。这是本主题设计初衷\n- 主题不支持IE6，7，8。以后也不会\n\n近期更新：\n===\n- 2015.6.14 - 模块化加载 2015.2.21 - 移动侧重构&布局bug修改 2014.11.7 - 增加“友情链接”“关于我”\n- 2014.10.22 - 优化fancybox展示\n- 2014.10.16 - 增加表格样式\n- 2014.9.19 - 云标签挂件\n","source":"_posts/关于主题.md","raw":"title: 关于主题\ndate: 2015-07-28 17:28:18\ntags: hexo\ncategories: 关于主题\nkeywords: hexo, smackdown theme, hexo主题\n---\n很早就搭出的博客，一直没有时间折腾，大三的时间实在是太紧了。这段时间终于腾出点时间，能让我好好的收拾一下自己的博客。将主题优化了一下，本主题基于 [Yilia](https://github.com/litten/hexo-theme-yilia)主题做的优化。后续我会把我优化后的主题传到[我的github](https://github.com/winnerweb)上。\n还有很多不足之处和bug需要更改，希望大家评论告诉我，看到一定回复。\n<!--more-->\n**体验手机版的可以扫下面的二维码。**\n![GitHub Mark](http://7xkj1z.com1.z0.glb.clouddn.com/二维码.png \"GitHub Mark\")\n\n---\n>- Yilia 是为 hexo 2.4+制作的主题。 \n>- 响应式开发\n>- 崇尚极致的性能。\n>- 主题能很好的兼容移动端。\n>- **因为我优化的主题（包括一些颜色和背景）可能比较让人眼花缭乱，所以增加了阅读模式，关闭背景图片，方便阅读（有时因为图片加载问题可能会出现花屏现象，可以Ctrl+A来解决）。**\n\n** * 以下内容转自Yilia原主题的README* **\n===\n---\n关于主题：\n===\n- 我喜欢简约。所以近期文章，搜索框都拿掉了\n- 接地气一点。所以用上了jiathis分享，友言评论，以及baidu的cdn\n- 追求移动端的体验\n- 让大家把注意力放到内容上。这是本主题设计初衷\n- 主题不支持IE6，7，8。以后也不会\n\n近期更新：\n===\n- 2015.6.14 - 模块化加载 2015.2.21 - 移动侧重构&布局bug修改 2014.11.7 - 增加“友情链接”“关于我”\n- 2014.10.22 - 优化fancybox展示\n- 2014.10.16 - 增加表格样式\n- 2014.9.19 - 云标签挂件\n","slug":"关于主题","published":1,"updated":"2016-10-31T07:25:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciuyzlutu000je6tb3d6w3wcf","content":"<p>很早就搭出的博客，一直没有时间折腾，大三的时间实在是太紧了。这段时间终于腾出点时间，能让我好好的收拾一下自己的博客。将主题优化了一下，本主题基于 <a href=\"https://github.com/litten/hexo-theme-yilia\" target=\"_blank\" rel=\"external\">Yilia</a>主题做的优化。后续我会把我优化后的主题传到<a href=\"https://github.com/winnerweb\" target=\"_blank\" rel=\"external\">我的github</a>上。<br>还有很多不足之处和bug需要更改，希望大家评论告诉我，看到一定回复。<br><a id=\"more\"></a><br><strong>体验手机版的可以扫下面的二维码。</strong><br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/二维码.png\" alt=\"GitHub Mark\" title=\"GitHub Mark\"></p>\n<hr>\n<blockquote>\n<ul>\n<li>Yilia 是为 hexo 2.4+制作的主题。 </li>\n<li>响应式开发</li>\n<li>崇尚极致的性能。</li>\n<li>主题能很好的兼容移动端。</li>\n<li><strong>因为我优化的主题（包括一些颜色和背景）可能比较让人眼花缭乱，所以增加了阅读模式，关闭背景图片，方便阅读（有时因为图片加载问题可能会出现花屏现象，可以Ctrl+A来解决）。</strong></li>\n</ul>\n</blockquote>\n<h1 id=\"以下内容转自Yilia原主题的README\"><a href=\"#以下内容转自Yilia原主题的README\" class=\"headerlink\" title=\"  以下内容转自Yilia原主题的README \"></a><strong> <em> 以下内容转自Yilia原主题的README</em> </strong></h1><hr>\n<h1 id=\"关于主题：\"><a href=\"#关于主题：\" class=\"headerlink\" title=\"关于主题：\"></a>关于主题：</h1><ul>\n<li>我喜欢简约。所以近期文章，搜索框都拿掉了</li>\n<li>接地气一点。所以用上了jiathis分享，友言评论，以及baidu的cdn</li>\n<li>追求移动端的体验</li>\n<li>让大家把注意力放到内容上。这是本主题设计初衷</li>\n<li>主题不支持IE6，7，8。以后也不会</li>\n</ul>\n<h1 id=\"近期更新：\"><a href=\"#近期更新：\" class=\"headerlink\" title=\"近期更新：\"></a>近期更新：</h1><ul>\n<li>2015.6.14 - 模块化加载 2015.2.21 - 移动侧重构&amp;布局bug修改 2014.11.7 - 增加“友情链接”“关于我”</li>\n<li>2014.10.22 - 优化fancybox展示</li>\n<li>2014.10.16 - 增加表格样式</li>\n<li>2014.9.19 - 云标签挂件</li>\n</ul>\n","excerpt":"<p>很早就搭出的博客，一直没有时间折腾，大三的时间实在是太紧了。这段时间终于腾出点时间，能让我好好的收拾一下自己的博客。将主题优化了一下，本主题基于 <a href=\"https://github.com/litten/hexo-theme-yilia\">Yilia</a>主题做的优化。后续我会把我优化后的主题传到<a href=\"https://github.com/winnerweb\">我的github</a>上。<br>还有很多不足之处和bug需要更改，希望大家评论告诉我，看到一定回复。<br>","more":"<br><strong>体验手机版的可以扫下面的二维码。</strong><br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/二维码.png\" alt=\"GitHub Mark\" title=\"GitHub Mark\"></p>\n<hr>\n<blockquote>\n<ul>\n<li>Yilia 是为 hexo 2.4+制作的主题。 </li>\n<li>响应式开发</li>\n<li>崇尚极致的性能。</li>\n<li>主题能很好的兼容移动端。</li>\n<li><strong>因为我优化的主题（包括一些颜色和背景）可能比较让人眼花缭乱，所以增加了阅读模式，关闭背景图片，方便阅读（有时因为图片加载问题可能会出现花屏现象，可以Ctrl+A来解决）。</strong></li>\n</ul>\n</blockquote>\n<h1 id=\"以下内容转自Yilia原主题的README\"><a href=\"#以下内容转自Yilia原主题的README\" class=\"headerlink\" title=\"  以下内容转自Yilia原主题的README \"></a><strong> <em> 以下内容转自Yilia原主题的README</em> </strong></h1><hr>\n<h1 id=\"关于主题：\"><a href=\"#关于主题：\" class=\"headerlink\" title=\"关于主题：\"></a>关于主题：</h1><ul>\n<li>我喜欢简约。所以近期文章，搜索框都拿掉了</li>\n<li>接地气一点。所以用上了jiathis分享，友言评论，以及baidu的cdn</li>\n<li>追求移动端的体验</li>\n<li>让大家把注意力放到内容上。这是本主题设计初衷</li>\n<li>主题不支持IE6，7，8。以后也不会</li>\n</ul>\n<h1 id=\"近期更新：\"><a href=\"#近期更新：\" class=\"headerlink\" title=\"近期更新：\"></a>近期更新：</h1><ul>\n<li>2015.6.14 - 模块化加载 2015.2.21 - 移动侧重构&amp;布局bug修改 2014.11.7 - 增加“友情链接”“关于我”</li>\n<li>2014.10.22 - 优化fancybox展示</li>\n<li>2014.10.16 - 增加表格样式</li>\n<li>2014.9.19 - 云标签挂件</li>\n</ul>"},{"title":"写代码强行装逼","date":"2016-10-12T10:43:11.000Z","keyword":"atom, sublime, 炫酷, 编辑器","_content":"## 写代码也要强行装逼有没有？编辑器也要炫酷吊炸天有没有？蓝瘦、香菇。。 ##\n![GitHub Mark](http://7xkj1z.com1.z0.glb.clouddn.com/%E5%86%99%E4%BB%A3%E7%A0%81%E5%BC%BA%E8%A1%8C%E8%A3%85%E9%80%BC.gif)\n<!--more-->\n\n---\n\n好久没写博客了，毕业季真的是很忙，现在毕业了，工作了，生活跟以前完全不一样了。好了闲话短说，我们进入正题。\n\n介绍两款[atom](https://atom.io/)编辑器的插件，[atom编辑器](https://atom.io/)去官网自行下载。\n关于两个主题这里也不多说，直接给出链接，具体安装过程讲的很详细。\n[atom-miku](https://github.com/sunqibuhuake/atom-miku)\n[activate-power-mode](https://atom.io/packages/activate-power-mode)\n\n\n\n","source":"_posts/写代码强行装逼.md","raw":"---\ntitle: 写代码强行装逼\ndate: 2016-10-12 18:43:11\ntags: 没事瞎扯\nkeyword: atom, sublime, 炫酷, 编辑器\n---\n## 写代码也要强行装逼有没有？编辑器也要炫酷吊炸天有没有？蓝瘦、香菇。。 ##\n![GitHub Mark](http://7xkj1z.com1.z0.glb.clouddn.com/%E5%86%99%E4%BB%A3%E7%A0%81%E5%BC%BA%E8%A1%8C%E8%A3%85%E9%80%BC.gif)\n<!--more-->\n\n---\n\n好久没写博客了，毕业季真的是很忙，现在毕业了，工作了，生活跟以前完全不一样了。好了闲话短说，我们进入正题。\n\n介绍两款[atom](https://atom.io/)编辑器的插件，[atom编辑器](https://atom.io/)去官网自行下载。\n关于两个主题这里也不多说，直接给出链接，具体安装过程讲的很详细。\n[atom-miku](https://github.com/sunqibuhuake/atom-miku)\n[activate-power-mode](https://atom.io/packages/activate-power-mode)\n\n\n\n","slug":"写代码强行装逼","published":1,"updated":"2016-10-31T07:25:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciuyzlutz000ne6tbjhsfl8mu","content":"<h2 id=\"写代码也要强行装逼有没有？编辑器也要炫酷吊炸天有没有？蓝瘦、香菇。。\"><a href=\"#写代码也要强行装逼有没有？编辑器也要炫酷吊炸天有没有？蓝瘦、香菇。。\" class=\"headerlink\" title=\"写代码也要强行装逼有没有？编辑器也要炫酷吊炸天有没有？蓝瘦、香菇。。\"></a>写代码也要强行装逼有没有？编辑器也要炫酷吊炸天有没有？蓝瘦、香菇。。</h2><p><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/%E5%86%99%E4%BB%A3%E7%A0%81%E5%BC%BA%E8%A1%8C%E8%A3%85%E9%80%BC.gif\" alt=\"GitHub Mark\"><br><a id=\"more\"></a></p>\n<hr>\n<p>好久没写博客了，毕业季真的是很忙，现在毕业了，工作了，生活跟以前完全不一样了。好了闲话短说，我们进入正题。</p>\n<p>介绍两款<a href=\"https://atom.io/\" target=\"_blank\" rel=\"external\">atom</a>编辑器的插件，<a href=\"https://atom.io/\" target=\"_blank\" rel=\"external\">atom编辑器</a>去官网自行下载。<br>关于两个主题这里也不多说，直接给出链接，具体安装过程讲的很详细。<br><a href=\"https://github.com/sunqibuhuake/atom-miku\" target=\"_blank\" rel=\"external\">atom-miku</a><br><a href=\"https://atom.io/packages/activate-power-mode\" target=\"_blank\" rel=\"external\">activate-power-mode</a></p>\n","excerpt":"<h2 id=\"写代码也要强行装逼有没有？编辑器也要炫酷吊炸天有没有？蓝瘦、香菇。。\"><a href=\"#写代码也要强行装逼有没有？编辑器也要炫酷吊炸天有没有？蓝瘦、香菇。。\" class=\"headerlink\" title=\"写代码也要强行装逼有没有？编辑器也要炫酷吊炸天有没有？蓝瘦、香菇。。\"></a>写代码也要强行装逼有没有？编辑器也要炫酷吊炸天有没有？蓝瘦、香菇。。</h2><p><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/%E5%86%99%E4%BB%A3%E7%A0%81%E5%BC%BA%E8%A1%8C%E8%A3%85%E9%80%BC.gif\" alt=\"GitHub Mark\"><br>","more":"</p>\n<hr>\n<p>好久没写博客了，毕业季真的是很忙，现在毕业了，工作了，生活跟以前完全不一样了。好了闲话短说，我们进入正题。</p>\n<p>介绍两款<a href=\"https://atom.io/\">atom</a>编辑器的插件，<a href=\"https://atom.io/\">atom编辑器</a>去官网自行下载。<br>关于两个主题这里也不多说，直接给出链接，具体安装过程讲的很详细。<br><a href=\"https://github.com/sunqibuhuake/atom-miku\">atom-miku</a><br><a href=\"https://atom.io/packages/activate-power-mode\">activate-power-mode</a></p>"},{"title":"为hexo-theme-smackdown主题添加阅读数","date":"2016-10-31T06:23:47.000Z","keyword":"hexo,theme,smackdown,hexo主题,统计,阅读数","_content":"为你的hexo博客每篇文章添加阅读数。\n<!--more-->\n\n<div align=\"center\">\n  ![阅读数展示图](http://7xkj1z.com1.z0.glb.clouddn.com/%E9%98%85%E8%AF%BB%E6%95%B0%E5%B1%95%E7%A4%BA%E5%9B%BE.jpeg)\n</div>\n\n---\n**如果你使用的是[hexo-theme-smackdown](https://github.com/winnerweb/hexo-theme-smackdown)主题，那你继续往下看本文章。\n如果你使用的是其它主题并想为你自己的主题添加文章阅读数，请参考[这篇文章](http://www.aluenkinglee.com/2016/06/30/hexo-add-post-hits/)。**\n\n\nhexo是一个静态的博客，所以想要添加评论或者统计，就需要依赖像多说这样的第三方服务。或者你自己有能力的话，可以自己搭一个服务器自己写。文章阅读数统计，也同样是需要第三方服务。有几个比较常见的第三方服务提供商：\n- leancloud\n- firebase\n- busuanzi\n\n参考了几篇文章之后，决定还是使用[leancloud](https://leancloud.cn)，免费账号提供的资源足够我们做计数用了。而且它的cdn在国内，对于国内用户方位速度较快。\n\n1. 首先注册一个[leancloud](https://leancloud.cn)账户，然后选择新建应用。\n<div align=\"center\">\n  ![leancloud](http://7xkj1z.com1.z0.glb.clouddn.com/hexo%E9%98%85%E8%AF%BB%E6%95%B0-2.jpeg)\n</div>\n\n2. 选择储存，点击设置新建class\n<div align=\"center\">\n  ![leancloud](http://7xkj1z.com1.z0.glb.clouddn.com/hexo%E9%98%85%E8%AF%BB%E6%95%B0-3.jpeg)\n</div>\n\n3. 权限无限制，名称叫做Counter\n<div align=\"center\">\n  ![leancloud](http://7xkj1z.com1.z0.glb.clouddn.com/hexo%E9%98%85%E8%AF%BB%E6%95%B0-4.jpeg)\n</div>\n\n4. 打开设置，选择应用key，复制下AppID和AppKey\n<div align=\"center\">\n  ![leancloud](http://7xkj1z.com1.z0.glb.clouddn.com/hexo%E9%98%85%E8%AF%BB%E6%95%B0-5.jpeg)\n</div>\n\n5. 在hexo-theme-smackdown主题的_config.yml文件中找到如下代码\n![leancloud](http://7xkj1z.com1.z0.glb.clouddn.com/hexo%E9%98%85%E8%AF%BB%E6%95%B0-7.jpeg)\n\n6. 将enable设置成true,将刚才复制的app_id和app_key分别粘贴到相应位置。\n  ```md\n  #是否开启文章阅读量\n  leancloud_visitors:\n    enable: true\n    app_id: eB0QOCzcXCP5aEk50wa5UDqz-gzGzofdsfs\n    app_key: Nx5RVdg3LvNyJtISPzdeWfjdklj\n  ```\n\n7. 大功告成。\n","source":"_posts/hexo主题添加阅读数.md","raw":"---\ntitle: 为hexo-theme-smackdown主题添加阅读数\ndate: 2016-10-31 14:23:47\ntags: hexo\ncategories: hexo\nkeyword: hexo,theme,smackdown,hexo主题,统计,阅读数\n---\n为你的hexo博客每篇文章添加阅读数。\n<!--more-->\n\n<div align=\"center\">\n  ![阅读数展示图](http://7xkj1z.com1.z0.glb.clouddn.com/%E9%98%85%E8%AF%BB%E6%95%B0%E5%B1%95%E7%A4%BA%E5%9B%BE.jpeg)\n</div>\n\n---\n**如果你使用的是[hexo-theme-smackdown](https://github.com/winnerweb/hexo-theme-smackdown)主题，那你继续往下看本文章。\n如果你使用的是其它主题并想为你自己的主题添加文章阅读数，请参考[这篇文章](http://www.aluenkinglee.com/2016/06/30/hexo-add-post-hits/)。**\n\n\nhexo是一个静态的博客，所以想要添加评论或者统计，就需要依赖像多说这样的第三方服务。或者你自己有能力的话，可以自己搭一个服务器自己写。文章阅读数统计，也同样是需要第三方服务。有几个比较常见的第三方服务提供商：\n- leancloud\n- firebase\n- busuanzi\n\n参考了几篇文章之后，决定还是使用[leancloud](https://leancloud.cn)，免费账号提供的资源足够我们做计数用了。而且它的cdn在国内，对于国内用户方位速度较快。\n\n1. 首先注册一个[leancloud](https://leancloud.cn)账户，然后选择新建应用。\n<div align=\"center\">\n  ![leancloud](http://7xkj1z.com1.z0.glb.clouddn.com/hexo%E9%98%85%E8%AF%BB%E6%95%B0-2.jpeg)\n</div>\n\n2. 选择储存，点击设置新建class\n<div align=\"center\">\n  ![leancloud](http://7xkj1z.com1.z0.glb.clouddn.com/hexo%E9%98%85%E8%AF%BB%E6%95%B0-3.jpeg)\n</div>\n\n3. 权限无限制，名称叫做Counter\n<div align=\"center\">\n  ![leancloud](http://7xkj1z.com1.z0.glb.clouddn.com/hexo%E9%98%85%E8%AF%BB%E6%95%B0-4.jpeg)\n</div>\n\n4. 打开设置，选择应用key，复制下AppID和AppKey\n<div align=\"center\">\n  ![leancloud](http://7xkj1z.com1.z0.glb.clouddn.com/hexo%E9%98%85%E8%AF%BB%E6%95%B0-5.jpeg)\n</div>\n\n5. 在hexo-theme-smackdown主题的_config.yml文件中找到如下代码\n![leancloud](http://7xkj1z.com1.z0.glb.clouddn.com/hexo%E9%98%85%E8%AF%BB%E6%95%B0-7.jpeg)\n\n6. 将enable设置成true,将刚才复制的app_id和app_key分别粘贴到相应位置。\n  ```md\n  #是否开启文章阅读量\n  leancloud_visitors:\n    enable: true\n    app_id: eB0QOCzcXCP5aEk50wa5UDqz-gzGzofdsfs\n    app_key: Nx5RVdg3LvNyJtISPzdeWfjdklj\n  ```\n\n7. 大功告成。\n","slug":"hexo主题添加阅读数","published":1,"updated":"2016-10-31T09:41:23.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciuyzluu3000pe6tbrzm2s360","content":"<p>为你的hexo博客每篇文章添加阅读数。<br><a id=\"more\"></a></p>\n<div align=\"center\"><br>  <img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/%E9%98%85%E8%AF%BB%E6%95%B0%E5%B1%95%E7%A4%BA%E5%9B%BE.jpeg\" alt=\"阅读数展示图\"><br></div>\n\n<hr>\n<p><strong>如果你使用的是<a href=\"https://github.com/winnerweb/hexo-theme-smackdown\" target=\"_blank\" rel=\"external\">hexo-theme-smackdown</a>主题，那你继续往下看本文章。<br>如果你使用的是其它主题并想为你自己的主题添加文章阅读数，请参考<a href=\"http://www.aluenkinglee.com/2016/06/30/hexo-add-post-hits/\" target=\"_blank\" rel=\"external\">这篇文章</a>。</strong></p>\n<p>hexo是一个静态的博客，所以想要添加评论或者统计，就需要依赖像多说这样的第三方服务。或者你自己有能力的话，可以自己搭一个服务器自己写。文章阅读数统计，也同样是需要第三方服务。有几个比较常见的第三方服务提供商：</p>\n<ul>\n<li>leancloud</li>\n<li>firebase</li>\n<li>busuanzi</li>\n</ul>\n<p>参考了几篇文章之后，决定还是使用<a href=\"https://leancloud.cn\" target=\"_blank\" rel=\"external\">leancloud</a>，免费账号提供的资源足够我们做计数用了。而且它的cdn在国内，对于国内用户方位速度较快。</p>\n<ol>\n<li><p>首先注册一个<a href=\"https://leancloud.cn\" target=\"_blank\" rel=\"external\">leancloud</a>账户，然后选择新建应用。</p>\n<div align=\"center\"><br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/hexo%E9%98%85%E8%AF%BB%E6%95%B0-2.jpeg\" alt=\"leancloud\"><br></div>\n</li>\n<li><p>选择储存，点击设置新建class</p>\n<div align=\"center\"><br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/hexo%E9%98%85%E8%AF%BB%E6%95%B0-3.jpeg\" alt=\"leancloud\"><br></div>\n</li>\n<li><p>权限无限制，名称叫做Counter</p>\n<div align=\"center\"><br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/hexo%E9%98%85%E8%AF%BB%E6%95%B0-4.jpeg\" alt=\"leancloud\"><br></div>\n</li>\n<li><p>打开设置，选择应用key，复制下AppID和AppKey</p>\n<div align=\"center\"><br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/hexo%E9%98%85%E8%AF%BB%E6%95%B0-5.jpeg\" alt=\"leancloud\"><br></div>\n</li>\n<li><p>在hexo-theme-smackdown主题的_config.yml文件中找到如下代码<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/hexo%E9%98%85%E8%AF%BB%E6%95%B0-7.jpeg\" alt=\"leancloud\"></p>\n</li>\n<li><p>将enable设置成true,将刚才复制的app_id和app_key分别粘贴到相应位置。</p>\n<figure class=\"highlight md\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"section\">#是否开启文章阅读量</span></div><div class=\"line\">leancloud_visitors:</div><div class=\"line\">  enable: true</div><div class=\"line\">  app_id: eB0QOCzcXCP5aEk50wa5UDqz-gzGzofdsfs</div><div class=\"line\">  app_key: Nx5RVdg3LvNyJtISPzdeWfjdklj</div></pre></td></tr></table></figure>\n</li>\n<li><p>大功告成。</p>\n</li>\n</ol>\n","excerpt":"<p>为你的hexo博客每篇文章添加阅读数。<br>","more":"</p>\n<div align=\"center\"><br>  <img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/%E9%98%85%E8%AF%BB%E6%95%B0%E5%B1%95%E7%A4%BA%E5%9B%BE.jpeg\" alt=\"阅读数展示图\"><br></div>\n\n<hr>\n<p><strong>如果你使用的是<a href=\"https://github.com/winnerweb/hexo-theme-smackdown\">hexo-theme-smackdown</a>主题，那你继续往下看本文章。<br>如果你使用的是其它主题并想为你自己的主题添加文章阅读数，请参考<a href=\"http://www.aluenkinglee.com/2016/06/30/hexo-add-post-hits/\">这篇文章</a>。</strong></p>\n<p>hexo是一个静态的博客，所以想要添加评论或者统计，就需要依赖像多说这样的第三方服务。或者你自己有能力的话，可以自己搭一个服务器自己写。文章阅读数统计，也同样是需要第三方服务。有几个比较常见的第三方服务提供商：</p>\n<ul>\n<li>leancloud</li>\n<li>firebase</li>\n<li>busuanzi</li>\n</ul>\n<p>参考了几篇文章之后，决定还是使用<a href=\"https://leancloud.cn\">leancloud</a>，免费账号提供的资源足够我们做计数用了。而且它的cdn在国内，对于国内用户方位速度较快。</p>\n<ol>\n<li><p>首先注册一个<a href=\"https://leancloud.cn\">leancloud</a>账户，然后选择新建应用。</p>\n<div align=\"center\"><br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/hexo%E9%98%85%E8%AF%BB%E6%95%B0-2.jpeg\" alt=\"leancloud\"><br></div>\n</li>\n<li><p>选择储存，点击设置新建class</p>\n<div align=\"center\"><br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/hexo%E9%98%85%E8%AF%BB%E6%95%B0-3.jpeg\" alt=\"leancloud\"><br></div>\n</li>\n<li><p>权限无限制，名称叫做Counter</p>\n<div align=\"center\"><br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/hexo%E9%98%85%E8%AF%BB%E6%95%B0-4.jpeg\" alt=\"leancloud\"><br></div>\n</li>\n<li><p>打开设置，选择应用key，复制下AppID和AppKey</p>\n<div align=\"center\"><br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/hexo%E9%98%85%E8%AF%BB%E6%95%B0-5.jpeg\" alt=\"leancloud\"><br></div>\n</li>\n<li><p>在hexo-theme-smackdown主题的_config.yml文件中找到如下代码<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/hexo%E9%98%85%E8%AF%BB%E6%95%B0-7.jpeg\" alt=\"leancloud\"></p>\n</li>\n<li><p>将enable设置成true,将刚才复制的app_id和app_key分别粘贴到相应位置。</p>\n<figure class=\"highlight md\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"section\">#是否开启文章阅读量</span></div><div class=\"line\">leancloud_visitors:</div><div class=\"line\">  enable: true</div><div class=\"line\">  app_id: eB0QOCzcXCP5aEk50wa5UDqz-gzGzofdsfs</div><div class=\"line\">  app_key: Nx5RVdg3LvNyJtISPzdeWfjdklj</div></pre></td></tr></table></figure>\n</li>\n<li><p>大功告成。</p>\n</li>\n</ol>"},{"title":"JavaScript数据访问的优化","date":"2015-07-31T05:42:30.000Z","_content":"**第二章 Data Access 数据访问**\n===\n本文章结尾处有结论，不愿意看原理或者已经懂原理的可以直接看结论。\n<!--more-->\n---\n　　经典计算机科学的一个问题是确定数据应当存放在什么地方， 以实现最佳的读写效率。数据存储的位置关系到访问的速度。在 JavaScript 中，有四种基本的数据访问位置：\n> - 直接量： 包括字符串，数字，布尔值，对象，数组，函数，正则表达式，具有特殊意义的空值（null），以及未定义（undefined）。\n> - 变量：用 var 关键字创建用于存储数据值。\n> - 数组项：具有数字索引，存储一个 JavaScript 数组对象。\n> - 对象成员：具有字符串索引，存储一个 JavaScript 对象。\n\n　　在一些老的浏览器中，直接量和局部变量的访问速度远远快于数组项和对象成员的访问速度（Firefox3 中优化过数组项，所以访问速度非常快）。**所以，如果关心运行速度，建议尽量使用直接量和局部变量，限制数组项和对象成员的使用。下图是对不同数据类型进行 200 000 次读操作所用的时间\n![对不同数据类型进行 200 000 次读操作所用的时间](http://7xkj1z.com1.z0.glb.clouddn.com/高性能js-img2-1.png)\n> 下面介绍几种模式来避免这种情况并优化你的代码。\n\n一.Managing Scope 管理作用域\n===\n---\n　　无论是从性能还是功能考虑，作用域链都是理解JavaScript的关键。但是要理解速度与作用域的关系，首先要理解作用域的工作原理。\n**1.Scope Chains and Identifier Resolution 作用域链和标识符解析**\n在这里不详细叙述作用域的工作原理，只是简单的说明一下作用域链的工作过程。如果想看详细原理，请参看我的文章[作用域链和标识符详细解析](http://www.winnerweb.club/2015/07/31/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E6%A0%87%E8%AF%86%E7%AC%A6%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/)。\n　　每一段 JavaScript 代码（全局代码或者函数）都有一个与之关联的作用域链(scope chain)。这个作用域链是一个对象链表，这组对象定义了这段代码“作用域中”的变量。当JavaScript需要查找变量x的值得时候（这个过程叫做变量解析），它会从链中的第一个对象(第一个对象是局部变量)开始查找，如果这个对象有一个名为x的属性，则会直接使用，若第二个对象依然没有，则会继续寻找下一个对象。以此类推，直至全局对象。若作用域链上没有任何一个对象含有属性x，那么就会返回一个undefined，在严格规范的ECMAScript 5中，会抛出一个异常。函数运行时每个标识符都要经过这样的搜索过程，正是这种搜索过程影响了性能。\n\n**Identifier Resolution Performance 标识符识别性能**\n　　在运行期上下文中，一个标识符所处的位置越深，读写速度也就越慢，所以局部变量访问速度是最快的，全局变量位于作用域链的最后一个位置是最慢的。下图展示了不同深度标识符的读写速度。（第一个写，第二个是读）\n![写操作的标识符识别速度](http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-2.png)\n![读操作的标识符识别速度](http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-3.png)\n　　采用优化JavaScript引擎的浏览器，如Safari4，访问域外标识符时没有性能的损失。其它浏览器都有较大幅度的影响。早期的IE6和Firefox2，有着令人难以置信的陡峭斜坡，如果此图包含它们的数据，曲线高点将超出图表边界。\n> 所以，在没有优化JavaScript引擎的浏览器中，尽可能使用局部变量。用局部变量存储本地范围之外的变量值。如果在函数中多次使用，参考以下例子：\n\n\tfunction initUI(){\n\t\tvar bd = document.body,\n\t\tlinks = document.getElementsByTagName_r(\"a\"),\n\t\ti = 0,\n\t\tlen = links.length;\n\t\twhile(i < len){\n\t\t\tupdate(links[i++]);\n\t\t}\n\t\tdocument.getElementById(\"go-btn\").onclick = function(){\n\t\t\tstart();\n\t\t};\n\t\tbd.className = \"active\";\n\t}\n　　次函数包含对document的引用，而document是全局变量。每次搜索此变量都要遍历整个作用域链。上述代码可以优化为：\n\n\tfunction initUI(){\n\t\tvar doc = document,\n\t\tbd = doc.body,\n\t\tlinks = doc.getElementsByTagName_r(\"a\"),\n\t\ti = 0,\n\t\tlen = links.length;\n\t\twhile(i < len){\n\t\t\tupdate(links[i++]);\n\t\t}\n\t\tdoc.getElementById(\"go-btn\").onclick = function(){\n\t\t\tstart();\n\t\t};\n\t\tbd.className = \"active\";\n\t}\n　　这个简单的函数不会显示出巨大的改进，如果几十个全局变量被反复访问，那么这么做性能将有显著的提高。\n**Scope Chain Augmentation 改变作用域链**\n　　一般来说，一个运行期上下文的作用域链不会被改变。但是，有两种表达式可以在运行时临时改变运行期上下文作用域链。第一个是 with 表达式。第二种是try-catch。with 表达式为所有对象属性创建一个默认操作变量。在其他语言中，类似的功能通常用来避免书写一些\n重复的代码。initUI()函数可以重写成如下样式：\n\n\tfunction initUI(){\n\t\twith (document){ //avoid!\n\t\tvar bd = body,\n\t\tlinks = getElementsByTagName_r(\"a\"),\n\t\ti = 0,\n\t\tlen = links.length;\n\t\twhile(i < len){\n\t\t\tupdate(links[i++]);\n\t\t}\n\t\tgetElementById(\"go-btn\").onclick = function(){\n\t\t\tstart();\n\t\t};\n\t\t\tbd.className = \"active\";\n\t\t}\n\t}\n　　**此重写的 initUI()版本使用了一个with表达式，避免多次书写“document”。这看起来似乎更有效率，而实际上却产生了一个性能问题。**\n当代码流执行到一个with表达式时，运行期上下文的作用域链被临时改变了。一个新的可变对象将被创建，它包含指定对象的所有属性。此对象被插入到作用域链的前端，意味着现在函数的所有局部变量都被推入第二个作用域链对象中，所以访问代价更高了，正因为这个原因，最好不要使用 with 表达式。正如前面提到的，只要简单地将 document 存储在一个\n局部变量中，就可以获得性能上的提升。（见下图）。\n![with 表达式改变作用域链](http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-4.png)。\n　　在 JavaScript 中不只是 with 表达式人为地改变运行期上下文的作用域链，try-catch 表达式的 catch 子句具有相同效果。当 try 块发生错误时，程序流程自动转入 catch 块，并将异常对象推入作用域链前端的一个可变对象中。在 catch 块中，函数的所有局部变量现在被放在第二个作用域链对象中。例如：\n\n\ttry {\n\t\tmethodThatMightCauseAnError();\n\t} catch (ex){\n\t\talert(ex.message); //scope chain is augmented here\n\t}\n**请注意，只要 catch 子句执行完毕，作用域链就会返回到原来的状态。**\n　　如果使用得当， try-catch 表达式是非常有用的语句，所以不建议完全避免。 如果你计划使用一个 try-catch语句，请确保你了解可能发生的错误。一个 try-catch 语句不应该作为 JavaScript 错误的解决办法。如果你知道一个错误会经常发生，那说明应当修正代码本身的问题。\n你可以通过精缩代码的办法最小化catch子句对性能的影响。一个很好的模式是将错误交给一个专用函数来处理。例子如下：\n\n\ttry {\n\t\tmethodThatMightCauseAnError();\n\t} catch (ex){\n\t\thandleError(ex); //delegate to handler method\n\t}\n　　handleError()函数是 catch 子句中运行的唯一代码。此函数以适当方法自由地处理错误，并接收由错误产生的异常对象。由于只有一条语句，没有局部变量访问，作用域链临时改变就不会影响代码的性能。\n**Dynamic Scopes 动态作用域**\n　　无论是 with 表达式还是 try-catch 表达式的 catch 子句，以及包含()的函数，都被认为是动态作用域。一个动态作用域只因代码运行而存在，因此无法通过静态分析（察看代码结构）来确定（是否存在动态作用域）\n\n\tfunction execute(code) {\n\t\t(code);\n\t\tfunction subroutine(){\n\t\t\treturn window;\n\t\t}\n\t\tvar w = subroutine();\n\t\t//what value is w?\n\t};\n　　execute()函数看上去像一个动态作用域，因为它使用了()。w 变量的值与 code 有关。大多数情况下，w将等价于全局的window对象，但是请考虑如下情况：\n\t\n\texecute(\"var window = {};\")\n　　这种情况下，()在 execute()函数中创建了一个局部window变量。所以w将等价于这个局部window变量而不是全局的那个。所以说，不运行这段代码是没有办法了解具体情况的，标识符 window 的确切含义不能预先确定。\n　　优化的 JavaScript 引擎，例如 Safari 的 Nitro 引擎，企图通过分析代码来确定哪些变量应该在任意时刻被访问，来加快标识符识别过程。这些引擎企图避开传统作用域链查找，取代以标识符索引的方式进行快速查找。当涉及一个动态作用域后，此优化方法就不起作用了。引擎需要切回慢速的基于哈希表的标识符识别方法，更像传统的作用域链搜索。\n　　正因为这个原因，只在绝对必要时才推荐使用动态作用域。\n**Closures, Scope, and Memory 闭包，作用域，和内存**\n　　闭包是 JavaScript 最强大的一个方面，它允许函数访问局部范围之外的数据。闭包的使用通过 Douglas\nCrockford的著作流行起来，当今在最复杂的网页应用中无处不在。不过，有一种性能影响与闭包有关。\n　　为了解与闭包有关的性能问题，考虑下面的例子：\n\n\tfunction assignEvents(){\n\t\tvar id = \"xdi9592\";\n\t\tdocument.getElementById(\"save-btn\").onclick = function(event){\n\t\t\tsaveDocument(id);\n\t\t};\n\t}\n　　当 assignEvents()被执行时，一个激活对象被创建，并包含了一些应有的内容，其中包括 id变量。它将成为运行期上下文作用域链上的第一个对象，全局对象是第二个。当闭包创建时，[[Scope]]属性与这些对象一起被初始化（见下图）。\n![assignEvents()运行期上下文的作用域链和闭包](http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-5.png)。\n　　由于闭包的[[Scope]]属性包含与运行期上下文作用域链相同的对象引用，会产生副作用。通常，一个函数的激活对象与运行期上下文一同销毁。当涉及闭包时，激活对象就无法销毁了，因为引用仍然存在于闭包的[[Scope]]属性中。这意味着脚本中的闭包与非闭包函数相比，需要更多内存开销。在大型网页应用中，\n这可能是个问题，尤其在 Internet Explorer 中更被关注。IE 使用非本地 JavaScript 对象实现 DOM 对象，闭包可能导致内存泄露（更多信息参见第 3 章）。\n　　当闭包被执行时，一个运行期上下文将被创建，它的作用域链与[[Scope]]中引用的两个相同的作用域链同时被初始化，然后一个新的激活对象为闭包自身被创建（参见下图）。\n![闭包运行](http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-6.png)。\n　　注意闭包中使用的两个标识符，id 和 saveDocument，存在于作用域链第一个对象之后的位置上。这是闭包最主要的性能关注点：你经常访问一些范围之外的标识符，每次访问都导致一些性能损失。\n>在脚本中最好是小心地使用闭包，内存和运行速度都值得被关注。但是，你可以通过本章早先讨论过的关于域外变量的处理建议，减轻对运行速度的影响：将常用的域外变量存入局部变量中，然后直接访问局部变量。\n\n**Prototypes 原形**\n　　JavaScript中的对象是基于原形的。原形是其他对象的基础，定义并实现了一个新对象所必须具有的成员。这一概念完全不同于传统面向对象编程中“类”的概念，它定义了创建新对象的过程。原形对象为所有给定类型的对象实例所共享，因此所有实例共享原形对象的成员。\n　　一个对象通过一个内部属性绑定到它的原形。Firefox，Safari，和 Chrome 向开发人员开放这一属性，称作__proto__其他浏览器不允许脚本访问这一属性。任何时候你创建一个内置类型的实例，如 Object 或 Array，这些实例自动拥有一个 Object 作为它们的原形。\n　　因此，对象可以有两种类型的成员：实例成员（也称作“own”成员）和原形成员。实例成员直接存在于实例自身，而原形成员则从对象原形继承。考虑下面的例子：\n\n\tvar book = {\n\t\ttitle: \"High Performance JavaScript\",\n\t\tpublisher: \"Yahoo! Press\"\n\t};\n\talert(book.toString()); //\"[object Object]\"\n此代码中，book 对象有两个实例成员：title 和 publisher。注意它并没有定义 toString()接口，但是这个接口却被调用了，也没有抛出错误。toString()函数就是一个 book 对象继承的原形成员。下图显示出它们之间的关系。\n![实例与原形的关系](http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-7.png)。\n　　处理对象成员的过程与变量处理十分相似。当 book.toString()被调用时，对成员进行名为“toString”的搜索，首先从对象实例开始，如果 book 没有名为 toString 的成员，那么就转向搜索原形对象，在那里发现了toString()方法并执行它。通过这种方法，booke 可以访问它的原形所拥有的每个属性或方法。\n　　你可以使用 hasOwnProperty()函数确定一个对象是否具有特定名称的实例成员，（它的参数就是成员名称）。要确定对象是否具有某个名称的属性，你可以使用操作符 in。例如：\n\n\tvar book = {\n\t\ttitle: \"High Performance JavaScript\",\n\t\tpublisher: \"Yahoo! Press\"\n\t};\n\talert(book.hasOwnProperty(\"title\")); //true\n\talert(book.hasOwnProperty(\"toString\")); //false\n\talert(\"title\" in book); //true\n\talert(\"toString\" in book); //true\n　　此代码中， hasOwnProperty()传入“title”时返回true， 因为title是一个实例成员。 传入“toString”时返回false，因为 toString 不在实例之中。如果使用 in 操作符检测这两个属性，那么返回都是 true，因为它既搜索实例又搜索原形。\n**Prototype Chains 原形链**\n对象的原形决定了一个实例的类型。默认情况下，所有对象都是 Object 的实例，并继承了所有基本方法，如 toString()。你可以用“构造器”创建另外一种类型的原形。例如：\n\t\n\tfunction Book(title, publisher){\n\t\tthis.title = title;\n\t\tthis.publisher = publisher;\n\t}\n\tBook.prototype.sayTitle = function(){\n\t\talert(this.title);\n\t};\n\tvar book1 = new Book(\"High Performance JavaScript\", \"Yahoo! Press\");\n\tvar book2 = new Book(\"JavaScript: The Good Parts\", \"Yahoo! Press\");\n\talert(book1 instanceof Book); //true\n\talert(book1 instanceof Object); //true\n\tbook1.sayTitle(); //\"High Performance JavaScript\"\n\talert(book1.toString()); //\"[object Object]\"\n原型链关系如下图：\n![原形链](http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-8.png)\n　　注意，两个 Book 实例共享同一个原形链。每个实例拥有自己的 title 和 publisher 属性，但其他成员均继承自原形。当 book1.toString()被调用时，搜索工作必须深入原形链才能找到对象成员“toString”。正如你所\n怀疑的那样，深入原形链越深，搜索的速度就会越慢。图2-11显示出成员在原形链中所处的深度与访问时间的关系。\n　　虽然使用优化 JavaScript 引擎的新式浏览器在此任务中表现良好，但是老的浏览器，特别是 Internet Explorer 和 Firefox 3.5，每深入原形链一层都会增加性能损失。记住，搜索实例成员的过程比访问直接量\n或者局部变量负担更重，所以增加遍历原形链的开销正好放大了这种效果。\n\n**Nested Members 嵌套成员**\n　　由于对象成员可能包含其它成员， 例如不太常见的写法 window.location.href 这种模式每遇到一个点号，JavaScript 引擎就要在对象成员上执行一次解析过程。成员嵌套越深，访问速度越慢。location.href 总是快于 window.location.href，而后者也要\n比 window.location.href.toString()更快。\n**Caching Object Member Values 缓存对象成员的值**\n\n\tfunction hasEitherClass(element, className1, className2){\n\t\treturn element.className == className1 || element.className == className2;\n\t}\n　　这段代码中element.className被访问了两次，而且在这个函数过程中它的值是不会变的。所以优化如下：\n\n\tfunction hasEitherClass(element, className1, className2){\n\t\tvar currentClassName = element.className;\n\t\treturn currentClassName == className1 || currentClassName == className2;\n\t}\n>一般来说，如果在同一个函数中你要多次读取同一个对象属性，最好将它存入一个局部变量。以局部变量替代属性，避免多余的属性查找带来性能开销。在处理嵌套对象成员时这点特别重要，它们会对运行速度产生难以置信的影响。\n\nSummary 总结\n===\n---\n　　在JavaScript中，数据存储位置可以对代码整体性能产生重要影响。有四种数据访问类型：直接量，变量，数组项，对象成员。它们有不同的性能考虑。\n\n> - 直接量和局部变量访问速度非常快，数组项和对象成员需要更长时间。\n> - 局部变量比域外变量快，因为它位于作用域链的第一个对象中。变量在作用域链中的位置越深，访问所需的时间就越长。全局变量总是最慢的，因为它们总是位于作用域链的最后一环。\n> - 避免使用 with 表达式， 因为它改变了运行期上下文的作用域链。 而且应当小心对待 try-catch 表达式的catch子句，因为它具有同样效果。\n> - 嵌套对象成员会造成重大性能影响，尽量少用。\n> - 一个属性或方法在原形链中的位置越深，访问它的速度就越慢。\n> - 一般来说，你可以通过这种方法提高JavaScript代码的性能：将经常使用的对象成员，数组项，和域外变量存入局部变量中。然后，访问局部变量的速度会快于那些原始变量。\n\n---\n通过使用这些策略，你可以极大地提高那些需要大量 JavaScript 代码的网页应用的实际性能。","source":"_posts/高性能JavaScript2(DESKTOP-354QT49--xuyan--2015-08-22-15,12,25).md","raw":"title: JavaScript数据访问的优化\ndate: 2015-07-31 13:42:30\ntags: 高性能JavaScript学习笔记\ncategories: 高性能JavaScript-2\n---\n**第二章 Data Access 数据访问**\n===\n本文章结尾处有结论，不愿意看原理或者已经懂原理的可以直接看结论。\n<!--more-->\n---\n　　经典计算机科学的一个问题是确定数据应当存放在什么地方， 以实现最佳的读写效率。数据存储的位置关系到访问的速度。在 JavaScript 中，有四种基本的数据访问位置：\n> - 直接量： 包括字符串，数字，布尔值，对象，数组，函数，正则表达式，具有特殊意义的空值（null），以及未定义（undefined）。\n> - 变量：用 var 关键字创建用于存储数据值。\n> - 数组项：具有数字索引，存储一个 JavaScript 数组对象。\n> - 对象成员：具有字符串索引，存储一个 JavaScript 对象。\n\n　　在一些老的浏览器中，直接量和局部变量的访问速度远远快于数组项和对象成员的访问速度（Firefox3 中优化过数组项，所以访问速度非常快）。**所以，如果关心运行速度，建议尽量使用直接量和局部变量，限制数组项和对象成员的使用。下图是对不同数据类型进行 200 000 次读操作所用的时间\n![对不同数据类型进行 200 000 次读操作所用的时间](http://7xkj1z.com1.z0.glb.clouddn.com/高性能js-img2-1.png)\n> 下面介绍几种模式来避免这种情况并优化你的代码。\n\n一.Managing Scope 管理作用域\n===\n---\n　　无论是从性能还是功能考虑，作用域链都是理解JavaScript的关键。但是要理解速度与作用域的关系，首先要理解作用域的工作原理。\n**1.Scope Chains and Identifier Resolution 作用域链和标识符解析**\n在这里不详细叙述作用域的工作原理，只是简单的说明一下作用域链的工作过程。如果想看详细原理，请参看我的文章[作用域链和标识符详细解析](http://www.winnerweb.club/2015/07/31/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E6%A0%87%E8%AF%86%E7%AC%A6%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/)。\n　　每一段 JavaScript 代码（全局代码或者函数）都有一个与之关联的作用域链(scope chain)。这个作用域链是一个对象链表，这组对象定义了这段代码“作用域中”的变量。当JavaScript需要查找变量x的值得时候（这个过程叫做变量解析），它会从链中的第一个对象(第一个对象是局部变量)开始查找，如果这个对象有一个名为x的属性，则会直接使用，若第二个对象依然没有，则会继续寻找下一个对象。以此类推，直至全局对象。若作用域链上没有任何一个对象含有属性x，那么就会返回一个undefined，在严格规范的ECMAScript 5中，会抛出一个异常。函数运行时每个标识符都要经过这样的搜索过程，正是这种搜索过程影响了性能。\n\n**Identifier Resolution Performance 标识符识别性能**\n　　在运行期上下文中，一个标识符所处的位置越深，读写速度也就越慢，所以局部变量访问速度是最快的，全局变量位于作用域链的最后一个位置是最慢的。下图展示了不同深度标识符的读写速度。（第一个写，第二个是读）\n![写操作的标识符识别速度](http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-2.png)\n![读操作的标识符识别速度](http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-3.png)\n　　采用优化JavaScript引擎的浏览器，如Safari4，访问域外标识符时没有性能的损失。其它浏览器都有较大幅度的影响。早期的IE6和Firefox2，有着令人难以置信的陡峭斜坡，如果此图包含它们的数据，曲线高点将超出图表边界。\n> 所以，在没有优化JavaScript引擎的浏览器中，尽可能使用局部变量。用局部变量存储本地范围之外的变量值。如果在函数中多次使用，参考以下例子：\n\n\tfunction initUI(){\n\t\tvar bd = document.body,\n\t\tlinks = document.getElementsByTagName_r(\"a\"),\n\t\ti = 0,\n\t\tlen = links.length;\n\t\twhile(i < len){\n\t\t\tupdate(links[i++]);\n\t\t}\n\t\tdocument.getElementById(\"go-btn\").onclick = function(){\n\t\t\tstart();\n\t\t};\n\t\tbd.className = \"active\";\n\t}\n　　次函数包含对document的引用，而document是全局变量。每次搜索此变量都要遍历整个作用域链。上述代码可以优化为：\n\n\tfunction initUI(){\n\t\tvar doc = document,\n\t\tbd = doc.body,\n\t\tlinks = doc.getElementsByTagName_r(\"a\"),\n\t\ti = 0,\n\t\tlen = links.length;\n\t\twhile(i < len){\n\t\t\tupdate(links[i++]);\n\t\t}\n\t\tdoc.getElementById(\"go-btn\").onclick = function(){\n\t\t\tstart();\n\t\t};\n\t\tbd.className = \"active\";\n\t}\n　　这个简单的函数不会显示出巨大的改进，如果几十个全局变量被反复访问，那么这么做性能将有显著的提高。\n**Scope Chain Augmentation 改变作用域链**\n　　一般来说，一个运行期上下文的作用域链不会被改变。但是，有两种表达式可以在运行时临时改变运行期上下文作用域链。第一个是 with 表达式。第二种是try-catch。with 表达式为所有对象属性创建一个默认操作变量。在其他语言中，类似的功能通常用来避免书写一些\n重复的代码。initUI()函数可以重写成如下样式：\n\n\tfunction initUI(){\n\t\twith (document){ //avoid!\n\t\tvar bd = body,\n\t\tlinks = getElementsByTagName_r(\"a\"),\n\t\ti = 0,\n\t\tlen = links.length;\n\t\twhile(i < len){\n\t\t\tupdate(links[i++]);\n\t\t}\n\t\tgetElementById(\"go-btn\").onclick = function(){\n\t\t\tstart();\n\t\t};\n\t\t\tbd.className = \"active\";\n\t\t}\n\t}\n　　**此重写的 initUI()版本使用了一个with表达式，避免多次书写“document”。这看起来似乎更有效率，而实际上却产生了一个性能问题。**\n当代码流执行到一个with表达式时，运行期上下文的作用域链被临时改变了。一个新的可变对象将被创建，它包含指定对象的所有属性。此对象被插入到作用域链的前端，意味着现在函数的所有局部变量都被推入第二个作用域链对象中，所以访问代价更高了，正因为这个原因，最好不要使用 with 表达式。正如前面提到的，只要简单地将 document 存储在一个\n局部变量中，就可以获得性能上的提升。（见下图）。\n![with 表达式改变作用域链](http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-4.png)。\n　　在 JavaScript 中不只是 with 表达式人为地改变运行期上下文的作用域链，try-catch 表达式的 catch 子句具有相同效果。当 try 块发生错误时，程序流程自动转入 catch 块，并将异常对象推入作用域链前端的一个可变对象中。在 catch 块中，函数的所有局部变量现在被放在第二个作用域链对象中。例如：\n\n\ttry {\n\t\tmethodThatMightCauseAnError();\n\t} catch (ex){\n\t\talert(ex.message); //scope chain is augmented here\n\t}\n**请注意，只要 catch 子句执行完毕，作用域链就会返回到原来的状态。**\n　　如果使用得当， try-catch 表达式是非常有用的语句，所以不建议完全避免。 如果你计划使用一个 try-catch语句，请确保你了解可能发生的错误。一个 try-catch 语句不应该作为 JavaScript 错误的解决办法。如果你知道一个错误会经常发生，那说明应当修正代码本身的问题。\n你可以通过精缩代码的办法最小化catch子句对性能的影响。一个很好的模式是将错误交给一个专用函数来处理。例子如下：\n\n\ttry {\n\t\tmethodThatMightCauseAnError();\n\t} catch (ex){\n\t\thandleError(ex); //delegate to handler method\n\t}\n　　handleError()函数是 catch 子句中运行的唯一代码。此函数以适当方法自由地处理错误，并接收由错误产生的异常对象。由于只有一条语句，没有局部变量访问，作用域链临时改变就不会影响代码的性能。\n**Dynamic Scopes 动态作用域**\n　　无论是 with 表达式还是 try-catch 表达式的 catch 子句，以及包含()的函数，都被认为是动态作用域。一个动态作用域只因代码运行而存在，因此无法通过静态分析（察看代码结构）来确定（是否存在动态作用域）\n\n\tfunction execute(code) {\n\t\t(code);\n\t\tfunction subroutine(){\n\t\t\treturn window;\n\t\t}\n\t\tvar w = subroutine();\n\t\t//what value is w?\n\t};\n　　execute()函数看上去像一个动态作用域，因为它使用了()。w 变量的值与 code 有关。大多数情况下，w将等价于全局的window对象，但是请考虑如下情况：\n\t\n\texecute(\"var window = {};\")\n　　这种情况下，()在 execute()函数中创建了一个局部window变量。所以w将等价于这个局部window变量而不是全局的那个。所以说，不运行这段代码是没有办法了解具体情况的，标识符 window 的确切含义不能预先确定。\n　　优化的 JavaScript 引擎，例如 Safari 的 Nitro 引擎，企图通过分析代码来确定哪些变量应该在任意时刻被访问，来加快标识符识别过程。这些引擎企图避开传统作用域链查找，取代以标识符索引的方式进行快速查找。当涉及一个动态作用域后，此优化方法就不起作用了。引擎需要切回慢速的基于哈希表的标识符识别方法，更像传统的作用域链搜索。\n　　正因为这个原因，只在绝对必要时才推荐使用动态作用域。\n**Closures, Scope, and Memory 闭包，作用域，和内存**\n　　闭包是 JavaScript 最强大的一个方面，它允许函数访问局部范围之外的数据。闭包的使用通过 Douglas\nCrockford的著作流行起来，当今在最复杂的网页应用中无处不在。不过，有一种性能影响与闭包有关。\n　　为了解与闭包有关的性能问题，考虑下面的例子：\n\n\tfunction assignEvents(){\n\t\tvar id = \"xdi9592\";\n\t\tdocument.getElementById(\"save-btn\").onclick = function(event){\n\t\t\tsaveDocument(id);\n\t\t};\n\t}\n　　当 assignEvents()被执行时，一个激活对象被创建，并包含了一些应有的内容，其中包括 id变量。它将成为运行期上下文作用域链上的第一个对象，全局对象是第二个。当闭包创建时，[[Scope]]属性与这些对象一起被初始化（见下图）。\n![assignEvents()运行期上下文的作用域链和闭包](http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-5.png)。\n　　由于闭包的[[Scope]]属性包含与运行期上下文作用域链相同的对象引用，会产生副作用。通常，一个函数的激活对象与运行期上下文一同销毁。当涉及闭包时，激活对象就无法销毁了，因为引用仍然存在于闭包的[[Scope]]属性中。这意味着脚本中的闭包与非闭包函数相比，需要更多内存开销。在大型网页应用中，\n这可能是个问题，尤其在 Internet Explorer 中更被关注。IE 使用非本地 JavaScript 对象实现 DOM 对象，闭包可能导致内存泄露（更多信息参见第 3 章）。\n　　当闭包被执行时，一个运行期上下文将被创建，它的作用域链与[[Scope]]中引用的两个相同的作用域链同时被初始化，然后一个新的激活对象为闭包自身被创建（参见下图）。\n![闭包运行](http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-6.png)。\n　　注意闭包中使用的两个标识符，id 和 saveDocument，存在于作用域链第一个对象之后的位置上。这是闭包最主要的性能关注点：你经常访问一些范围之外的标识符，每次访问都导致一些性能损失。\n>在脚本中最好是小心地使用闭包，内存和运行速度都值得被关注。但是，你可以通过本章早先讨论过的关于域外变量的处理建议，减轻对运行速度的影响：将常用的域外变量存入局部变量中，然后直接访问局部变量。\n\n**Prototypes 原形**\n　　JavaScript中的对象是基于原形的。原形是其他对象的基础，定义并实现了一个新对象所必须具有的成员。这一概念完全不同于传统面向对象编程中“类”的概念，它定义了创建新对象的过程。原形对象为所有给定类型的对象实例所共享，因此所有实例共享原形对象的成员。\n　　一个对象通过一个内部属性绑定到它的原形。Firefox，Safari，和 Chrome 向开发人员开放这一属性，称作__proto__其他浏览器不允许脚本访问这一属性。任何时候你创建一个内置类型的实例，如 Object 或 Array，这些实例自动拥有一个 Object 作为它们的原形。\n　　因此，对象可以有两种类型的成员：实例成员（也称作“own”成员）和原形成员。实例成员直接存在于实例自身，而原形成员则从对象原形继承。考虑下面的例子：\n\n\tvar book = {\n\t\ttitle: \"High Performance JavaScript\",\n\t\tpublisher: \"Yahoo! Press\"\n\t};\n\talert(book.toString()); //\"[object Object]\"\n此代码中，book 对象有两个实例成员：title 和 publisher。注意它并没有定义 toString()接口，但是这个接口却被调用了，也没有抛出错误。toString()函数就是一个 book 对象继承的原形成员。下图显示出它们之间的关系。\n![实例与原形的关系](http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-7.png)。\n　　处理对象成员的过程与变量处理十分相似。当 book.toString()被调用时，对成员进行名为“toString”的搜索，首先从对象实例开始，如果 book 没有名为 toString 的成员，那么就转向搜索原形对象，在那里发现了toString()方法并执行它。通过这种方法，booke 可以访问它的原形所拥有的每个属性或方法。\n　　你可以使用 hasOwnProperty()函数确定一个对象是否具有特定名称的实例成员，（它的参数就是成员名称）。要确定对象是否具有某个名称的属性，你可以使用操作符 in。例如：\n\n\tvar book = {\n\t\ttitle: \"High Performance JavaScript\",\n\t\tpublisher: \"Yahoo! Press\"\n\t};\n\talert(book.hasOwnProperty(\"title\")); //true\n\talert(book.hasOwnProperty(\"toString\")); //false\n\talert(\"title\" in book); //true\n\talert(\"toString\" in book); //true\n　　此代码中， hasOwnProperty()传入“title”时返回true， 因为title是一个实例成员。 传入“toString”时返回false，因为 toString 不在实例之中。如果使用 in 操作符检测这两个属性，那么返回都是 true，因为它既搜索实例又搜索原形。\n**Prototype Chains 原形链**\n对象的原形决定了一个实例的类型。默认情况下，所有对象都是 Object 的实例，并继承了所有基本方法，如 toString()。你可以用“构造器”创建另外一种类型的原形。例如：\n\t\n\tfunction Book(title, publisher){\n\t\tthis.title = title;\n\t\tthis.publisher = publisher;\n\t}\n\tBook.prototype.sayTitle = function(){\n\t\talert(this.title);\n\t};\n\tvar book1 = new Book(\"High Performance JavaScript\", \"Yahoo! Press\");\n\tvar book2 = new Book(\"JavaScript: The Good Parts\", \"Yahoo! Press\");\n\talert(book1 instanceof Book); //true\n\talert(book1 instanceof Object); //true\n\tbook1.sayTitle(); //\"High Performance JavaScript\"\n\talert(book1.toString()); //\"[object Object]\"\n原型链关系如下图：\n![原形链](http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-8.png)\n　　注意，两个 Book 实例共享同一个原形链。每个实例拥有自己的 title 和 publisher 属性，但其他成员均继承自原形。当 book1.toString()被调用时，搜索工作必须深入原形链才能找到对象成员“toString”。正如你所\n怀疑的那样，深入原形链越深，搜索的速度就会越慢。图2-11显示出成员在原形链中所处的深度与访问时间的关系。\n　　虽然使用优化 JavaScript 引擎的新式浏览器在此任务中表现良好，但是老的浏览器，特别是 Internet Explorer 和 Firefox 3.5，每深入原形链一层都会增加性能损失。记住，搜索实例成员的过程比访问直接量\n或者局部变量负担更重，所以增加遍历原形链的开销正好放大了这种效果。\n\n**Nested Members 嵌套成员**\n　　由于对象成员可能包含其它成员， 例如不太常见的写法 window.location.href 这种模式每遇到一个点号，JavaScript 引擎就要在对象成员上执行一次解析过程。成员嵌套越深，访问速度越慢。location.href 总是快于 window.location.href，而后者也要\n比 window.location.href.toString()更快。\n**Caching Object Member Values 缓存对象成员的值**\n\n\tfunction hasEitherClass(element, className1, className2){\n\t\treturn element.className == className1 || element.className == className2;\n\t}\n　　这段代码中element.className被访问了两次，而且在这个函数过程中它的值是不会变的。所以优化如下：\n\n\tfunction hasEitherClass(element, className1, className2){\n\t\tvar currentClassName = element.className;\n\t\treturn currentClassName == className1 || currentClassName == className2;\n\t}\n>一般来说，如果在同一个函数中你要多次读取同一个对象属性，最好将它存入一个局部变量。以局部变量替代属性，避免多余的属性查找带来性能开销。在处理嵌套对象成员时这点特别重要，它们会对运行速度产生难以置信的影响。\n\nSummary 总结\n===\n---\n　　在JavaScript中，数据存储位置可以对代码整体性能产生重要影响。有四种数据访问类型：直接量，变量，数组项，对象成员。它们有不同的性能考虑。\n\n> - 直接量和局部变量访问速度非常快，数组项和对象成员需要更长时间。\n> - 局部变量比域外变量快，因为它位于作用域链的第一个对象中。变量在作用域链中的位置越深，访问所需的时间就越长。全局变量总是最慢的，因为它们总是位于作用域链的最后一环。\n> - 避免使用 with 表达式， 因为它改变了运行期上下文的作用域链。 而且应当小心对待 try-catch 表达式的catch子句，因为它具有同样效果。\n> - 嵌套对象成员会造成重大性能影响，尽量少用。\n> - 一个属性或方法在原形链中的位置越深，访问它的速度就越慢。\n> - 一般来说，你可以通过这种方法提高JavaScript代码的性能：将经常使用的对象成员，数组项，和域外变量存入局部变量中。然后，访问局部变量的速度会快于那些原始变量。\n\n---\n通过使用这些策略，你可以极大地提高那些需要大量 JavaScript 代码的网页应用的实际性能。","slug":"高性能JavaScript2(DESKTOP-354QT49--xuyan--2015-08-22-15,12,25)","published":1,"updated":"2016-10-31T07:25:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciuyzluu9000ue6tbprmhuf17","content":"<h1 id=\"第二章-Data-Access-数据访问\"><a href=\"#第二章-Data-Access-数据访问\" class=\"headerlink\" title=\"第二章 Data Access 数据访问\"></a><strong>第二章 Data Access 数据访问</strong></h1><p>本文章结尾处有结论，不愿意看原理或者已经懂原理的可以直接看结论。</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><a id=\"more\"></a></h2><p>　　经典计算机科学的一个问题是确定数据应当存放在什么地方， 以实现最佳的读写效率。数据存储的位置关系到访问的速度。在 JavaScript 中，有四种基本的数据访问位置：</p>\n<blockquote>\n<ul>\n<li>直接量： 包括字符串，数字，布尔值，对象，数组，函数，正则表达式，具有特殊意义的空值（null），以及未定义（undefined）。</li>\n<li>变量：用 var 关键字创建用于存储数据值。</li>\n<li>数组项：具有数字索引，存储一个 JavaScript 数组对象。</li>\n<li>对象成员：具有字符串索引，存储一个 JavaScript 对象。</li>\n</ul>\n</blockquote>\n<p>　　在一些老的浏览器中，直接量和局部变量的访问速度远远快于数组项和对象成员的访问速度（Firefox3 中优化过数组项，所以访问速度非常快）。**所以，如果关心运行速度，建议尽量使用直接量和局部变量，限制数组项和对象成员的使用。下图是对不同数据类型进行 200 000 次读操作所用的时间<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/高性能js-img2-1.png\" alt=\"对不同数据类型进行 200 000 次读操作所用的时间\"></p>\n<blockquote>\n<p>下面介绍几种模式来避免这种情况并优化你的代码。</p>\n</blockquote>\n<h1 id=\"一-Managing-Scope-管理作用域\"><a href=\"#一-Managing-Scope-管理作用域\" class=\"headerlink\" title=\"一.Managing Scope 管理作用域\"></a>一.Managing Scope 管理作用域</h1><hr>\n<p>　　无论是从性能还是功能考虑，作用域链都是理解JavaScript的关键。但是要理解速度与作用域的关系，首先要理解作用域的工作原理。<br><strong>1.Scope Chains and Identifier Resolution 作用域链和标识符解析</strong><br>在这里不详细叙述作用域的工作原理，只是简单的说明一下作用域链的工作过程。如果想看详细原理，请参看我的文章<a href=\"http://www.winnerweb.club/2015/07/31/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E6%A0%87%E8%AF%86%E7%AC%A6%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/\" target=\"_blank\" rel=\"external\">作用域链和标识符详细解析</a>。<br>　　每一段 JavaScript 代码（全局代码或者函数）都有一个与之关联的作用域链(scope chain)。这个作用域链是一个对象链表，这组对象定义了这段代码“作用域中”的变量。当JavaScript需要查找变量x的值得时候（这个过程叫做变量解析），它会从链中的第一个对象(第一个对象是局部变量)开始查找，如果这个对象有一个名为x的属性，则会直接使用，若第二个对象依然没有，则会继续寻找下一个对象。以此类推，直至全局对象。若作用域链上没有任何一个对象含有属性x，那么就会返回一个undefined，在严格规范的ECMAScript 5中，会抛出一个异常。函数运行时每个标识符都要经过这样的搜索过程，正是这种搜索过程影响了性能。</p>\n<p><strong>Identifier Resolution Performance 标识符识别性能</strong><br>　　在运行期上下文中，一个标识符所处的位置越深，读写速度也就越慢，所以局部变量访问速度是最快的，全局变量位于作用域链的最后一个位置是最慢的。下图展示了不同深度标识符的读写速度。（第一个写，第二个是读）<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-2.png\" alt=\"写操作的标识符识别速度\"><br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-3.png\" alt=\"读操作的标识符识别速度\"><br>　　采用优化JavaScript引擎的浏览器，如Safari4，访问域外标识符时没有性能的损失。其它浏览器都有较大幅度的影响。早期的IE6和Firefox2，有着令人难以置信的陡峭斜坡，如果此图包含它们的数据，曲线高点将超出图表边界。</p>\n<blockquote>\n<p>所以，在没有优化JavaScript引擎的浏览器中，尽可能使用局部变量。用局部变量存储本地范围之外的变量值。如果在函数中多次使用，参考以下例子：</p>\n</blockquote>\n<pre><code>function initUI(){\n    var bd = document.body,\n    links = document.getElementsByTagName_r(&quot;a&quot;),\n    i = 0,\n    len = links.length;\n    while(i &lt; len){\n        update(links[i++]);\n    }\n    document.getElementById(&quot;go-btn&quot;).onclick = function(){\n        start();\n    };\n    bd.className = &quot;active&quot;;\n}\n</code></pre><p>　　次函数包含对document的引用，而document是全局变量。每次搜索此变量都要遍历整个作用域链。上述代码可以优化为：</p>\n<pre><code>function initUI(){\n    var doc = document,\n    bd = doc.body,\n    links = doc.getElementsByTagName_r(&quot;a&quot;),\n    i = 0,\n    len = links.length;\n    while(i &lt; len){\n        update(links[i++]);\n    }\n    doc.getElementById(&quot;go-btn&quot;).onclick = function(){\n        start();\n    };\n    bd.className = &quot;active&quot;;\n}\n</code></pre><p>　　这个简单的函数不会显示出巨大的改进，如果几十个全局变量被反复访问，那么这么做性能将有显著的提高。<br><strong>Scope Chain Augmentation 改变作用域链</strong><br>　　一般来说，一个运行期上下文的作用域链不会被改变。但是，有两种表达式可以在运行时临时改变运行期上下文作用域链。第一个是 with 表达式。第二种是try-catch。with 表达式为所有对象属性创建一个默认操作变量。在其他语言中，类似的功能通常用来避免书写一些<br>重复的代码。initUI()函数可以重写成如下样式：</p>\n<pre><code>function initUI(){\n    with (document){ //avoid!\n    var bd = body,\n    links = getElementsByTagName_r(&quot;a&quot;),\n    i = 0,\n    len = links.length;\n    while(i &lt; len){\n        update(links[i++]);\n    }\n    getElementById(&quot;go-btn&quot;).onclick = function(){\n        start();\n    };\n        bd.className = &quot;active&quot;;\n    }\n}\n</code></pre><p>　　<strong>此重写的 initUI()版本使用了一个with表达式，避免多次书写“document”。这看起来似乎更有效率，而实际上却产生了一个性能问题。</strong><br>当代码流执行到一个with表达式时，运行期上下文的作用域链被临时改变了。一个新的可变对象将被创建，它包含指定对象的所有属性。此对象被插入到作用域链的前端，意味着现在函数的所有局部变量都被推入第二个作用域链对象中，所以访问代价更高了，正因为这个原因，最好不要使用 with 表达式。正如前面提到的，只要简单地将 document 存储在一个<br>局部变量中，就可以获得性能上的提升。（见下图）。<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-4.png\" alt=\"with 表达式改变作用域链\">。<br>　　在 JavaScript 中不只是 with 表达式人为地改变运行期上下文的作用域链，try-catch 表达式的 catch 子句具有相同效果。当 try 块发生错误时，程序流程自动转入 catch 块，并将异常对象推入作用域链前端的一个可变对象中。在 catch 块中，函数的所有局部变量现在被放在第二个作用域链对象中。例如：</p>\n<pre><code>try {\n    methodThatMightCauseAnError();\n} catch (ex){\n    alert(ex.message); //scope chain is augmented here\n}\n</code></pre><p><strong>请注意，只要 catch 子句执行完毕，作用域链就会返回到原来的状态。</strong><br>　　如果使用得当， try-catch 表达式是非常有用的语句，所以不建议完全避免。 如果你计划使用一个 try-catch语句，请确保你了解可能发生的错误。一个 try-catch 语句不应该作为 JavaScript 错误的解决办法。如果你知道一个错误会经常发生，那说明应当修正代码本身的问题。<br>你可以通过精缩代码的办法最小化catch子句对性能的影响。一个很好的模式是将错误交给一个专用函数来处理。例子如下：</p>\n<pre><code>try {\n    methodThatMightCauseAnError();\n} catch (ex){\n    handleError(ex); //delegate to handler method\n}\n</code></pre><p>　　handleError()函数是 catch 子句中运行的唯一代码。此函数以适当方法自由地处理错误，并接收由错误产生的异常对象。由于只有一条语句，没有局部变量访问，作用域链临时改变就不会影响代码的性能。<br><strong>Dynamic Scopes 动态作用域</strong><br>　　无论是 with 表达式还是 try-catch 表达式的 catch 子句，以及包含()的函数，都被认为是动态作用域。一个动态作用域只因代码运行而存在，因此无法通过静态分析（察看代码结构）来确定（是否存在动态作用域）</p>\n<pre><code>function execute(code) {\n    (code);\n    function subroutine(){\n        return window;\n    }\n    var w = subroutine();\n    //what value is w?\n};\n</code></pre><p>　　execute()函数看上去像一个动态作用域，因为它使用了()。w 变量的值与 code 有关。大多数情况下，w将等价于全局的window对象，但是请考虑如下情况：</p>\n<pre><code>execute(&quot;var window = {};&quot;)\n</code></pre><p>　　这种情况下，()在 execute()函数中创建了一个局部window变量。所以w将等价于这个局部window变量而不是全局的那个。所以说，不运行这段代码是没有办法了解具体情况的，标识符 window 的确切含义不能预先确定。<br>　　优化的 JavaScript 引擎，例如 Safari 的 Nitro 引擎，企图通过分析代码来确定哪些变量应该在任意时刻被访问，来加快标识符识别过程。这些引擎企图避开传统作用域链查找，取代以标识符索引的方式进行快速查找。当涉及一个动态作用域后，此优化方法就不起作用了。引擎需要切回慢速的基于哈希表的标识符识别方法，更像传统的作用域链搜索。<br>　　正因为这个原因，只在绝对必要时才推荐使用动态作用域。<br><strong>Closures, Scope, and Memory 闭包，作用域，和内存</strong><br>　　闭包是 JavaScript 最强大的一个方面，它允许函数访问局部范围之外的数据。闭包的使用通过 Douglas<br>Crockford的著作流行起来，当今在最复杂的网页应用中无处不在。不过，有一种性能影响与闭包有关。<br>　　为了解与闭包有关的性能问题，考虑下面的例子：</p>\n<pre><code>function assignEvents(){\n    var id = &quot;xdi9592&quot;;\n    document.getElementById(&quot;save-btn&quot;).onclick = function(event){\n        saveDocument(id);\n    };\n}\n</code></pre><p>　　当 assignEvents()被执行时，一个激活对象被创建，并包含了一些应有的内容，其中包括 id变量。它将成为运行期上下文作用域链上的第一个对象，全局对象是第二个。当闭包创建时，[[Scope]]属性与这些对象一起被初始化（见下图）。<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-5.png\" alt=\"assignEvents()运行期上下文的作用域链和闭包\">。<br>　　由于闭包的[[Scope]]属性包含与运行期上下文作用域链相同的对象引用，会产生副作用。通常，一个函数的激活对象与运行期上下文一同销毁。当涉及闭包时，激活对象就无法销毁了，因为引用仍然存在于闭包的[[Scope]]属性中。这意味着脚本中的闭包与非闭包函数相比，需要更多内存开销。在大型网页应用中，<br>这可能是个问题，尤其在 Internet Explorer 中更被关注。IE 使用非本地 JavaScript 对象实现 DOM 对象，闭包可能导致内存泄露（更多信息参见第 3 章）。<br>　　当闭包被执行时，一个运行期上下文将被创建，它的作用域链与[[Scope]]中引用的两个相同的作用域链同时被初始化，然后一个新的激活对象为闭包自身被创建（参见下图）。<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-6.png\" alt=\"闭包运行\">。<br>　　注意闭包中使用的两个标识符，id 和 saveDocument，存在于作用域链第一个对象之后的位置上。这是闭包最主要的性能关注点：你经常访问一些范围之外的标识符，每次访问都导致一些性能损失。</p>\n<blockquote>\n<p>在脚本中最好是小心地使用闭包，内存和运行速度都值得被关注。但是，你可以通过本章早先讨论过的关于域外变量的处理建议，减轻对运行速度的影响：将常用的域外变量存入局部变量中，然后直接访问局部变量。</p>\n</blockquote>\n<p><strong>Prototypes 原形</strong><br>　　JavaScript中的对象是基于原形的。原形是其他对象的基础，定义并实现了一个新对象所必须具有的成员。这一概念完全不同于传统面向对象编程中“类”的概念，它定义了创建新对象的过程。原形对象为所有给定类型的对象实例所共享，因此所有实例共享原形对象的成员。<br>　　一个对象通过一个内部属性绑定到它的原形。Firefox，Safari，和 Chrome 向开发人员开放这一属性，称作<strong>proto</strong>其他浏览器不允许脚本访问这一属性。任何时候你创建一个内置类型的实例，如 Object 或 Array，这些实例自动拥有一个 Object 作为它们的原形。<br>　　因此，对象可以有两种类型的成员：实例成员（也称作“own”成员）和原形成员。实例成员直接存在于实例自身，而原形成员则从对象原形继承。考虑下面的例子：</p>\n<pre><code>var book = {\n    title: &quot;High Performance JavaScript&quot;,\n    publisher: &quot;Yahoo! Press&quot;\n};\nalert(book.toString()); //&quot;[object Object]&quot;\n</code></pre><p>此代码中，book 对象有两个实例成员：title 和 publisher。注意它并没有定义 toString()接口，但是这个接口却被调用了，也没有抛出错误。toString()函数就是一个 book 对象继承的原形成员。下图显示出它们之间的关系。<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-7.png\" alt=\"实例与原形的关系\">。<br>　　处理对象成员的过程与变量处理十分相似。当 book.toString()被调用时，对成员进行名为“toString”的搜索，首先从对象实例开始，如果 book 没有名为 toString 的成员，那么就转向搜索原形对象，在那里发现了toString()方法并执行它。通过这种方法，booke 可以访问它的原形所拥有的每个属性或方法。<br>　　你可以使用 hasOwnProperty()函数确定一个对象是否具有特定名称的实例成员，（它的参数就是成员名称）。要确定对象是否具有某个名称的属性，你可以使用操作符 in。例如：</p>\n<pre><code>var book = {\n    title: &quot;High Performance JavaScript&quot;,\n    publisher: &quot;Yahoo! Press&quot;\n};\nalert(book.hasOwnProperty(&quot;title&quot;)); //true\nalert(book.hasOwnProperty(&quot;toString&quot;)); //false\nalert(&quot;title&quot; in book); //true\nalert(&quot;toString&quot; in book); //true\n</code></pre><p>　　此代码中， hasOwnProperty()传入“title”时返回true， 因为title是一个实例成员。 传入“toString”时返回false，因为 toString 不在实例之中。如果使用 in 操作符检测这两个属性，那么返回都是 true，因为它既搜索实例又搜索原形。<br><strong>Prototype Chains 原形链</strong><br>对象的原形决定了一个实例的类型。默认情况下，所有对象都是 Object 的实例，并继承了所有基本方法，如 toString()。你可以用“构造器”创建另外一种类型的原形。例如：</p>\n<pre><code>function Book(title, publisher){\n    this.title = title;\n    this.publisher = publisher;\n}\nBook.prototype.sayTitle = function(){\n    alert(this.title);\n};\nvar book1 = new Book(&quot;High Performance JavaScript&quot;, &quot;Yahoo! Press&quot;);\nvar book2 = new Book(&quot;JavaScript: The Good Parts&quot;, &quot;Yahoo! Press&quot;);\nalert(book1 instanceof Book); //true\nalert(book1 instanceof Object); //true\nbook1.sayTitle(); //&quot;High Performance JavaScript&quot;\nalert(book1.toString()); //&quot;[object Object]&quot;\n</code></pre><p>原型链关系如下图：<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-8.png\" alt=\"原形链\"><br>　　注意，两个 Book 实例共享同一个原形链。每个实例拥有自己的 title 和 publisher 属性，但其他成员均继承自原形。当 book1.toString()被调用时，搜索工作必须深入原形链才能找到对象成员“toString”。正如你所<br>怀疑的那样，深入原形链越深，搜索的速度就会越慢。图2-11显示出成员在原形链中所处的深度与访问时间的关系。<br>　　虽然使用优化 JavaScript 引擎的新式浏览器在此任务中表现良好，但是老的浏览器，特别是 Internet Explorer 和 Firefox 3.5，每深入原形链一层都会增加性能损失。记住，搜索实例成员的过程比访问直接量<br>或者局部变量负担更重，所以增加遍历原形链的开销正好放大了这种效果。</p>\n<p><strong>Nested Members 嵌套成员</strong><br>　　由于对象成员可能包含其它成员， 例如不太常见的写法 window.location.href 这种模式每遇到一个点号，JavaScript 引擎就要在对象成员上执行一次解析过程。成员嵌套越深，访问速度越慢。location.href 总是快于 window.location.href，而后者也要<br>比 window.location.href.toString()更快。<br><strong>Caching Object Member Values 缓存对象成员的值</strong></p>\n<pre><code>function hasEitherClass(element, className1, className2){\n    return element.className == className1 || element.className == className2;\n}\n</code></pre><p>　　这段代码中element.className被访问了两次，而且在这个函数过程中它的值是不会变的。所以优化如下：</p>\n<pre><code>function hasEitherClass(element, className1, className2){\n    var currentClassName = element.className;\n    return currentClassName == className1 || currentClassName == className2;\n}\n</code></pre><blockquote>\n<p>一般来说，如果在同一个函数中你要多次读取同一个对象属性，最好将它存入一个局部变量。以局部变量替代属性，避免多余的属性查找带来性能开销。在处理嵌套对象成员时这点特别重要，它们会对运行速度产生难以置信的影响。</p>\n</blockquote>\n<h1 id=\"Summary-总结\"><a href=\"#Summary-总结\" class=\"headerlink\" title=\"Summary 总结\"></a>Summary 总结</h1><hr>\n<p>　　在JavaScript中，数据存储位置可以对代码整体性能产生重要影响。有四种数据访问类型：直接量，变量，数组项，对象成员。它们有不同的性能考虑。</p>\n<blockquote>\n<ul>\n<li>直接量和局部变量访问速度非常快，数组项和对象成员需要更长时间。</li>\n<li>局部变量比域外变量快，因为它位于作用域链的第一个对象中。变量在作用域链中的位置越深，访问所需的时间就越长。全局变量总是最慢的，因为它们总是位于作用域链的最后一环。</li>\n<li>避免使用 with 表达式， 因为它改变了运行期上下文的作用域链。 而且应当小心对待 try-catch 表达式的catch子句，因为它具有同样效果。</li>\n<li>嵌套对象成员会造成重大性能影响，尽量少用。</li>\n<li>一个属性或方法在原形链中的位置越深，访问它的速度就越慢。</li>\n<li>一般来说，你可以通过这种方法提高JavaScript代码的性能：将经常使用的对象成员，数组项，和域外变量存入局部变量中。然后，访问局部变量的速度会快于那些原始变量。</li>\n</ul>\n</blockquote>\n<hr>\n<p>通过使用这些策略，你可以极大地提高那些需要大量 JavaScript 代码的网页应用的实际性能。</p>\n","excerpt":"<h1 id=\"第二章-Data-Access-数据访问\"><a href=\"#第二章-Data-Access-数据访问\" class=\"headerlink\" title=\"第二章 Data Access 数据访问\"></a><strong>第二章 Data Access 数据访问</strong></h1><p>本文章结尾处有结论，不愿意看原理或者已经懂原理的可以直接看结论。</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a>","more":"</h2><p>　　经典计算机科学的一个问题是确定数据应当存放在什么地方， 以实现最佳的读写效率。数据存储的位置关系到访问的速度。在 JavaScript 中，有四种基本的数据访问位置：</p>\n<blockquote>\n<ul>\n<li>直接量： 包括字符串，数字，布尔值，对象，数组，函数，正则表达式，具有特殊意义的空值（null），以及未定义（undefined）。</li>\n<li>变量：用 var 关键字创建用于存储数据值。</li>\n<li>数组项：具有数字索引，存储一个 JavaScript 数组对象。</li>\n<li>对象成员：具有字符串索引，存储一个 JavaScript 对象。</li>\n</ul>\n</blockquote>\n<p>　　在一些老的浏览器中，直接量和局部变量的访问速度远远快于数组项和对象成员的访问速度（Firefox3 中优化过数组项，所以访问速度非常快）。**所以，如果关心运行速度，建议尽量使用直接量和局部变量，限制数组项和对象成员的使用。下图是对不同数据类型进行 200 000 次读操作所用的时间<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/高性能js-img2-1.png\" alt=\"对不同数据类型进行 200 000 次读操作所用的时间\"></p>\n<blockquote>\n<p>下面介绍几种模式来避免这种情况并优化你的代码。</p>\n</blockquote>\n<h1 id=\"一-Managing-Scope-管理作用域\"><a href=\"#一-Managing-Scope-管理作用域\" class=\"headerlink\" title=\"一.Managing Scope 管理作用域\"></a>一.Managing Scope 管理作用域</h1><hr>\n<p>　　无论是从性能还是功能考虑，作用域链都是理解JavaScript的关键。但是要理解速度与作用域的关系，首先要理解作用域的工作原理。<br><strong>1.Scope Chains and Identifier Resolution 作用域链和标识符解析</strong><br>在这里不详细叙述作用域的工作原理，只是简单的说明一下作用域链的工作过程。如果想看详细原理，请参看我的文章<a href=\"http://www.winnerweb.club/2015/07/31/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E6%A0%87%E8%AF%86%E7%AC%A6%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/\">作用域链和标识符详细解析</a>。<br>　　每一段 JavaScript 代码（全局代码或者函数）都有一个与之关联的作用域链(scope chain)。这个作用域链是一个对象链表，这组对象定义了这段代码“作用域中”的变量。当JavaScript需要查找变量x的值得时候（这个过程叫做变量解析），它会从链中的第一个对象(第一个对象是局部变量)开始查找，如果这个对象有一个名为x的属性，则会直接使用，若第二个对象依然没有，则会继续寻找下一个对象。以此类推，直至全局对象。若作用域链上没有任何一个对象含有属性x，那么就会返回一个undefined，在严格规范的ECMAScript 5中，会抛出一个异常。函数运行时每个标识符都要经过这样的搜索过程，正是这种搜索过程影响了性能。</p>\n<p><strong>Identifier Resolution Performance 标识符识别性能</strong><br>　　在运行期上下文中，一个标识符所处的位置越深，读写速度也就越慢，所以局部变量访问速度是最快的，全局变量位于作用域链的最后一个位置是最慢的。下图展示了不同深度标识符的读写速度。（第一个写，第二个是读）<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-2.png\" alt=\"写操作的标识符识别速度\"><br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-3.png\" alt=\"读操作的标识符识别速度\"><br>　　采用优化JavaScript引擎的浏览器，如Safari4，访问域外标识符时没有性能的损失。其它浏览器都有较大幅度的影响。早期的IE6和Firefox2，有着令人难以置信的陡峭斜坡，如果此图包含它们的数据，曲线高点将超出图表边界。</p>\n<blockquote>\n<p>所以，在没有优化JavaScript引擎的浏览器中，尽可能使用局部变量。用局部变量存储本地范围之外的变量值。如果在函数中多次使用，参考以下例子：</p>\n</blockquote>\n<pre><code>function initUI(){\n    var bd = document.body,\n    links = document.getElementsByTagName_r(&quot;a&quot;),\n    i = 0,\n    len = links.length;\n    while(i &lt; len){\n        update(links[i++]);\n    }\n    document.getElementById(&quot;go-btn&quot;).onclick = function(){\n        start();\n    };\n    bd.className = &quot;active&quot;;\n}\n</code></pre><p>　　次函数包含对document的引用，而document是全局变量。每次搜索此变量都要遍历整个作用域链。上述代码可以优化为：</p>\n<pre><code>function initUI(){\n    var doc = document,\n    bd = doc.body,\n    links = doc.getElementsByTagName_r(&quot;a&quot;),\n    i = 0,\n    len = links.length;\n    while(i &lt; len){\n        update(links[i++]);\n    }\n    doc.getElementById(&quot;go-btn&quot;).onclick = function(){\n        start();\n    };\n    bd.className = &quot;active&quot;;\n}\n</code></pre><p>　　这个简单的函数不会显示出巨大的改进，如果几十个全局变量被反复访问，那么这么做性能将有显著的提高。<br><strong>Scope Chain Augmentation 改变作用域链</strong><br>　　一般来说，一个运行期上下文的作用域链不会被改变。但是，有两种表达式可以在运行时临时改变运行期上下文作用域链。第一个是 with 表达式。第二种是try-catch。with 表达式为所有对象属性创建一个默认操作变量。在其他语言中，类似的功能通常用来避免书写一些<br>重复的代码。initUI()函数可以重写成如下样式：</p>\n<pre><code>function initUI(){\n    with (document){ //avoid!\n    var bd = body,\n    links = getElementsByTagName_r(&quot;a&quot;),\n    i = 0,\n    len = links.length;\n    while(i &lt; len){\n        update(links[i++]);\n    }\n    getElementById(&quot;go-btn&quot;).onclick = function(){\n        start();\n    };\n        bd.className = &quot;active&quot;;\n    }\n}\n</code></pre><p>　　<strong>此重写的 initUI()版本使用了一个with表达式，避免多次书写“document”。这看起来似乎更有效率，而实际上却产生了一个性能问题。</strong><br>当代码流执行到一个with表达式时，运行期上下文的作用域链被临时改变了。一个新的可变对象将被创建，它包含指定对象的所有属性。此对象被插入到作用域链的前端，意味着现在函数的所有局部变量都被推入第二个作用域链对象中，所以访问代价更高了，正因为这个原因，最好不要使用 with 表达式。正如前面提到的，只要简单地将 document 存储在一个<br>局部变量中，就可以获得性能上的提升。（见下图）。<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-4.png\" alt=\"with 表达式改变作用域链\">。<br>　　在 JavaScript 中不只是 with 表达式人为地改变运行期上下文的作用域链，try-catch 表达式的 catch 子句具有相同效果。当 try 块发生错误时，程序流程自动转入 catch 块，并将异常对象推入作用域链前端的一个可变对象中。在 catch 块中，函数的所有局部变量现在被放在第二个作用域链对象中。例如：</p>\n<pre><code>try {\n    methodThatMightCauseAnError();\n} catch (ex){\n    alert(ex.message); //scope chain is augmented here\n}\n</code></pre><p><strong>请注意，只要 catch 子句执行完毕，作用域链就会返回到原来的状态。</strong><br>　　如果使用得当， try-catch 表达式是非常有用的语句，所以不建议完全避免。 如果你计划使用一个 try-catch语句，请确保你了解可能发生的错误。一个 try-catch 语句不应该作为 JavaScript 错误的解决办法。如果你知道一个错误会经常发生，那说明应当修正代码本身的问题。<br>你可以通过精缩代码的办法最小化catch子句对性能的影响。一个很好的模式是将错误交给一个专用函数来处理。例子如下：</p>\n<pre><code>try {\n    methodThatMightCauseAnError();\n} catch (ex){\n    handleError(ex); //delegate to handler method\n}\n</code></pre><p>　　handleError()函数是 catch 子句中运行的唯一代码。此函数以适当方法自由地处理错误，并接收由错误产生的异常对象。由于只有一条语句，没有局部变量访问，作用域链临时改变就不会影响代码的性能。<br><strong>Dynamic Scopes 动态作用域</strong><br>　　无论是 with 表达式还是 try-catch 表达式的 catch 子句，以及包含()的函数，都被认为是动态作用域。一个动态作用域只因代码运行而存在，因此无法通过静态分析（察看代码结构）来确定（是否存在动态作用域）</p>\n<pre><code>function execute(code) {\n    (code);\n    function subroutine(){\n        return window;\n    }\n    var w = subroutine();\n    //what value is w?\n};\n</code></pre><p>　　execute()函数看上去像一个动态作用域，因为它使用了()。w 变量的值与 code 有关。大多数情况下，w将等价于全局的window对象，但是请考虑如下情况：</p>\n<pre><code>execute(&quot;var window = {};&quot;)\n</code></pre><p>　　这种情况下，()在 execute()函数中创建了一个局部window变量。所以w将等价于这个局部window变量而不是全局的那个。所以说，不运行这段代码是没有办法了解具体情况的，标识符 window 的确切含义不能预先确定。<br>　　优化的 JavaScript 引擎，例如 Safari 的 Nitro 引擎，企图通过分析代码来确定哪些变量应该在任意时刻被访问，来加快标识符识别过程。这些引擎企图避开传统作用域链查找，取代以标识符索引的方式进行快速查找。当涉及一个动态作用域后，此优化方法就不起作用了。引擎需要切回慢速的基于哈希表的标识符识别方法，更像传统的作用域链搜索。<br>　　正因为这个原因，只在绝对必要时才推荐使用动态作用域。<br><strong>Closures, Scope, and Memory 闭包，作用域，和内存</strong><br>　　闭包是 JavaScript 最强大的一个方面，它允许函数访问局部范围之外的数据。闭包的使用通过 Douglas<br>Crockford的著作流行起来，当今在最复杂的网页应用中无处不在。不过，有一种性能影响与闭包有关。<br>　　为了解与闭包有关的性能问题，考虑下面的例子：</p>\n<pre><code>function assignEvents(){\n    var id = &quot;xdi9592&quot;;\n    document.getElementById(&quot;save-btn&quot;).onclick = function(event){\n        saveDocument(id);\n    };\n}\n</code></pre><p>　　当 assignEvents()被执行时，一个激活对象被创建，并包含了一些应有的内容，其中包括 id变量。它将成为运行期上下文作用域链上的第一个对象，全局对象是第二个。当闭包创建时，[[Scope]]属性与这些对象一起被初始化（见下图）。<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-5.png\" alt=\"assignEvents()运行期上下文的作用域链和闭包\">。<br>　　由于闭包的[[Scope]]属性包含与运行期上下文作用域链相同的对象引用，会产生副作用。通常，一个函数的激活对象与运行期上下文一同销毁。当涉及闭包时，激活对象就无法销毁了，因为引用仍然存在于闭包的[[Scope]]属性中。这意味着脚本中的闭包与非闭包函数相比，需要更多内存开销。在大型网页应用中，<br>这可能是个问题，尤其在 Internet Explorer 中更被关注。IE 使用非本地 JavaScript 对象实现 DOM 对象，闭包可能导致内存泄露（更多信息参见第 3 章）。<br>　　当闭包被执行时，一个运行期上下文将被创建，它的作用域链与[[Scope]]中引用的两个相同的作用域链同时被初始化，然后一个新的激活对象为闭包自身被创建（参见下图）。<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-6.png\" alt=\"闭包运行\">。<br>　　注意闭包中使用的两个标识符，id 和 saveDocument，存在于作用域链第一个对象之后的位置上。这是闭包最主要的性能关注点：你经常访问一些范围之外的标识符，每次访问都导致一些性能损失。</p>\n<blockquote>\n<p>在脚本中最好是小心地使用闭包，内存和运行速度都值得被关注。但是，你可以通过本章早先讨论过的关于域外变量的处理建议，减轻对运行速度的影响：将常用的域外变量存入局部变量中，然后直接访问局部变量。</p>\n</blockquote>\n<p><strong>Prototypes 原形</strong><br>　　JavaScript中的对象是基于原形的。原形是其他对象的基础，定义并实现了一个新对象所必须具有的成员。这一概念完全不同于传统面向对象编程中“类”的概念，它定义了创建新对象的过程。原形对象为所有给定类型的对象实例所共享，因此所有实例共享原形对象的成员。<br>　　一个对象通过一个内部属性绑定到它的原形。Firefox，Safari，和 Chrome 向开发人员开放这一属性，称作<strong>proto</strong>其他浏览器不允许脚本访问这一属性。任何时候你创建一个内置类型的实例，如 Object 或 Array，这些实例自动拥有一个 Object 作为它们的原形。<br>　　因此，对象可以有两种类型的成员：实例成员（也称作“own”成员）和原形成员。实例成员直接存在于实例自身，而原形成员则从对象原形继承。考虑下面的例子：</p>\n<pre><code>var book = {\n    title: &quot;High Performance JavaScript&quot;,\n    publisher: &quot;Yahoo! Press&quot;\n};\nalert(book.toString()); //&quot;[object Object]&quot;\n</code></pre><p>此代码中，book 对象有两个实例成员：title 和 publisher。注意它并没有定义 toString()接口，但是这个接口却被调用了，也没有抛出错误。toString()函数就是一个 book 对象继承的原形成员。下图显示出它们之间的关系。<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-7.png\" alt=\"实例与原形的关系\">。<br>　　处理对象成员的过程与变量处理十分相似。当 book.toString()被调用时，对成员进行名为“toString”的搜索，首先从对象实例开始，如果 book 没有名为 toString 的成员，那么就转向搜索原形对象，在那里发现了toString()方法并执行它。通过这种方法，booke 可以访问它的原形所拥有的每个属性或方法。<br>　　你可以使用 hasOwnProperty()函数确定一个对象是否具有特定名称的实例成员，（它的参数就是成员名称）。要确定对象是否具有某个名称的属性，你可以使用操作符 in。例如：</p>\n<pre><code>var book = {\n    title: &quot;High Performance JavaScript&quot;,\n    publisher: &quot;Yahoo! Press&quot;\n};\nalert(book.hasOwnProperty(&quot;title&quot;)); //true\nalert(book.hasOwnProperty(&quot;toString&quot;)); //false\nalert(&quot;title&quot; in book); //true\nalert(&quot;toString&quot; in book); //true\n</code></pre><p>　　此代码中， hasOwnProperty()传入“title”时返回true， 因为title是一个实例成员。 传入“toString”时返回false，因为 toString 不在实例之中。如果使用 in 操作符检测这两个属性，那么返回都是 true，因为它既搜索实例又搜索原形。<br><strong>Prototype Chains 原形链</strong><br>对象的原形决定了一个实例的类型。默认情况下，所有对象都是 Object 的实例，并继承了所有基本方法，如 toString()。你可以用“构造器”创建另外一种类型的原形。例如：</p>\n<pre><code>function Book(title, publisher){\n    this.title = title;\n    this.publisher = publisher;\n}\nBook.prototype.sayTitle = function(){\n    alert(this.title);\n};\nvar book1 = new Book(&quot;High Performance JavaScript&quot;, &quot;Yahoo! Press&quot;);\nvar book2 = new Book(&quot;JavaScript: The Good Parts&quot;, &quot;Yahoo! Press&quot;);\nalert(book1 instanceof Book); //true\nalert(book1 instanceof Object); //true\nbook1.sayTitle(); //&quot;High Performance JavaScript&quot;\nalert(book1.toString()); //&quot;[object Object]&quot;\n</code></pre><p>原型链关系如下图：<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-8.png\" alt=\"原形链\"><br>　　注意，两个 Book 实例共享同一个原形链。每个实例拥有自己的 title 和 publisher 属性，但其他成员均继承自原形。当 book1.toString()被调用时，搜索工作必须深入原形链才能找到对象成员“toString”。正如你所<br>怀疑的那样，深入原形链越深，搜索的速度就会越慢。图2-11显示出成员在原形链中所处的深度与访问时间的关系。<br>　　虽然使用优化 JavaScript 引擎的新式浏览器在此任务中表现良好，但是老的浏览器，特别是 Internet Explorer 和 Firefox 3.5，每深入原形链一层都会增加性能损失。记住，搜索实例成员的过程比访问直接量<br>或者局部变量负担更重，所以增加遍历原形链的开销正好放大了这种效果。</p>\n<p><strong>Nested Members 嵌套成员</strong><br>　　由于对象成员可能包含其它成员， 例如不太常见的写法 window.location.href 这种模式每遇到一个点号，JavaScript 引擎就要在对象成员上执行一次解析过程。成员嵌套越深，访问速度越慢。location.href 总是快于 window.location.href，而后者也要<br>比 window.location.href.toString()更快。<br><strong>Caching Object Member Values 缓存对象成员的值</strong></p>\n<pre><code>function hasEitherClass(element, className1, className2){\n    return element.className == className1 || element.className == className2;\n}\n</code></pre><p>　　这段代码中element.className被访问了两次，而且在这个函数过程中它的值是不会变的。所以优化如下：</p>\n<pre><code>function hasEitherClass(element, className1, className2){\n    var currentClassName = element.className;\n    return currentClassName == className1 || currentClassName == className2;\n}\n</code></pre><blockquote>\n<p>一般来说，如果在同一个函数中你要多次读取同一个对象属性，最好将它存入一个局部变量。以局部变量替代属性，避免多余的属性查找带来性能开销。在处理嵌套对象成员时这点特别重要，它们会对运行速度产生难以置信的影响。</p>\n</blockquote>\n<h1 id=\"Summary-总结\"><a href=\"#Summary-总结\" class=\"headerlink\" title=\"Summary 总结\"></a>Summary 总结</h1><hr>\n<p>　　在JavaScript中，数据存储位置可以对代码整体性能产生重要影响。有四种数据访问类型：直接量，变量，数组项，对象成员。它们有不同的性能考虑。</p>\n<blockquote>\n<ul>\n<li>直接量和局部变量访问速度非常快，数组项和对象成员需要更长时间。</li>\n<li>局部变量比域外变量快，因为它位于作用域链的第一个对象中。变量在作用域链中的位置越深，访问所需的时间就越长。全局变量总是最慢的，因为它们总是位于作用域链的最后一环。</li>\n<li>避免使用 with 表达式， 因为它改变了运行期上下文的作用域链。 而且应当小心对待 try-catch 表达式的catch子句，因为它具有同样效果。</li>\n<li>嵌套对象成员会造成重大性能影响，尽量少用。</li>\n<li>一个属性或方法在原形链中的位置越深，访问它的速度就越慢。</li>\n<li>一般来说，你可以通过这种方法提高JavaScript代码的性能：将经常使用的对象成员，数组项，和域外变量存入局部变量中。然后，访问局部变量的速度会快于那些原始变量。</li>\n</ul>\n</blockquote>\n<hr>\n<p>通过使用这些策略，你可以极大地提高那些需要大量 JavaScript 代码的网页应用的实际性能。</p>"},{"title":"JavaScript DOM编程优化","date":"2015-08-01T02:20:11.000Z","_content":"**第三章 DOM Scripting DOM  编程**\n===\n　　回去看了一下前面两章的内容，发现写的内容都很多，但是过于繁琐，基本与原文解释的内容差不多，在后面的文章中，我将更多的写自己的理解，而不是更多的原文内容，如果对优化很感兴趣，可以详细的看一下《高性能JavaScript》这本书。在每章结束时，依旧有总结。\n<!--more-->\n　　在这章主要讨论以下三个问题。\n> - 1.访问和修改 DOM 元素。\n> - 2.修改 DOM 元素的样式，造成重绘和重新排版。\n> - 3.通过 DOM 事件处理用户响应。\n　　DOM 在浏览器中主要是用来操作 HTML 文档的。它天生就很慢，当你每次访问 DOM 时都需要耗费性能，这就好比每次 ECMAScript 需要访问 DOM 时，你需要过桥，交一次“过桥费”。所以，当你操作 DOM 次数越多，费用就越高。看一下下面这个例子：\n\n\tfunction innerHTMLLoop() {\n\t\tfor (var count = 0; count < 15000; count++) {\n\t\t\tdocument.getElementById('here').innerHTML += 'a';\n\t\t}\n\t}\n　　这个例子中，你每次循环都要访问DOM两次，一次是读取innerHTML，另一次是写入它。再看一下下面的改进版本。\n\n\tfunction innerHTMLLoop2() {\n\t\tvar content = '';\n\t\tfor (var count = 0; count < 15000; count++) {\n\t\t\tcontent += 'a';\n\t\t}\n\t\tdocument.getElementById('here').innerHTML += content;\n\t}\n　　**使用局部变量存储更新后的内容，在循环结束时一次性写入，如果循环非常大，你可能会发现性能会比之前快了几百倍。**\n\n　　还有一种优化方式，是用 innerHTML 来代替纯DOM ，innerHTML 会比纯 DOM方法快一点，下面两个例子分别建1000行的表：\ninnerHTML方法：\n\n\tfunction tableInnerHTML() {\n\t\tvar i, h = ['<table border=\"1\" width=\"100%\">'];\n\t\th.push('<thead>');\n\t\th.push('<tr><th>id<\\/th><th>yes?<\\/th><th>name<\\/th><th>url<\\/th><th>action<\\/th><\\/tr>');\n\t\th.push('<\\/thead>');\n\t\th.push('<tbody>');\n\t\tfor (i = 1; i <= 1000; i++) {\n\t\th.push('<tr><td>');\n\t\th.push(i);\n\t\th.push('<\\/td><td>');\n\t\th.push('And the answer is... ' + (i % 2 ? 'yes' : 'no'));\n\t\th.push('<\\/td><td>');\n\t\th.push('my name is #' + i);\n\t\th.push('<\\/td><td>');\n\t\th.push('<a href=\"http://example.org/' + i + '.html\">http://example.org/' + i + '.html<\\/a>');\n\t\th.push('<\\/td><td>');\n\t\th.push('<ul>');\n\t\th.push(' <li><a href=\"edit.php?id=' + i + '\">edit<\\/a><\\/li>');\n\t\th.push(' <li><a href=\"delete.php?id=\"' + i + '-id001\">delete<\\/a><\\/li>');\n\t\th.push('<\\/ul>');\n\t\th.push('<\\/td>');\n\t\th.push('<\\/tr>');\n\t\t}\n\t\th.push('<\\/tbody>');\n\t\th.push('<\\/table>');\n\t\tdocument.getElementById('here').innerHTML = h.join('');\n\t};\n如果使用 DOM 方法创建同样的表，代码有些冗长：\n\n\tfunction tableDOM() {\n\t\tvar i, table, thead, tbody, tr, th, td, a, ul, li;\n\t\ttbody = document.createElement ('tbody');\n\t\tfor (i = 1; i <= 1000; i++) {\n\t\t\ttr = document.createElement ('tr');\n\t\t\ttd = document.createElement ('td');\n\t\t\ttd.appendChild(document.createTextNode((i % 2) ? 'yes' : 'no'));\n\t\t\ttr.appendChild(td);\n\t\t\ttd = document.createElement ('td');\n\t\t\ttd.appendChild(document.createTextNode(i));\n\t\t\ttr.appendChild(td);\n\t\t\ttd = document.createElement ('td');\n\t\t\ttd.appendChild(document.createTextNode('my name is #' + i));\n\t\t\ttr.appendChild(td);\n\t\t\ta = document.createElement ('a');\n\t\t\ta.setAttribute('href', 'http://example.org/' + i + '.html');\n\t\t\ta.appendChild(document.createTextNode('http://example.org/' + i + '.html'));\n\t\t\ttd = document.createElement ('td');\n\t\t\ttd.appendChild(a);\n\t\t\ttr.appendChild(td);\n\t\t\tul = document.createElement ('ul');\n\t\t\ta = document.createElement ('a');\n\t\t\ta.setAttribute('href', 'edit.php?id=' + i);\n\t\t\ta.appendChild(document.createTextNode('edit'));\n\t\t\tli = document.createElement ('li');\n\t\t\tli.appendChild(a);\n\t\t\tul.appendChild(li);\n\t\t\ta = document.createElement ('a');\n\t\t\ta.setAttribute('href', 'delete.php?id=' + i);\n\t\t\ta.appendChild(document.createTextNode('delete'));\n\t\t\tli = document.createElement ('li');\n\t\t\tli.appendChild(a);\n\t\t\tul.appendChild(li);\n\t\t\ttd = document.createElement ('td');\n\t\t\ttd.appendChild(ul);\n\t\t\ttr.appendChild(td);\n\t\t\ttbody.appendChild(tr);\n\t\t}\n\t\ttr = document.createElement ('tr');\n\t\tth = document.createElement ('th');\n\t\tth.appendChild(document.createTextNode('yes?'));\n\t\ttr.appendChild(th);\n\t\tth = document.createElement ('th');\n\t\tth.appendChild(document.createTextNode('id'));\n\t\ttr.appendChild(th);\n\t\tth = document.createElement ('th');\n\t\tth.appendChild(document.createTextNode('name'));\n\t\ttr.appendChild(th);\n\t\tth = document.createElement('th');\n\t\tth.appendChild(document.createTextNode('url'));\n\t\ttr.appendChild(th);\n\t\tth = document.createElement('th');\n\t\tth.appendChild(document.createTextNode('action'));\n\t\ttr.appendChild(th);\n\t\tthead = document.createElement('thead');\n\t\tthead.appendChild(tr);\n\t\ttable = document.createElement('table');\n\t\ttable.setAttribute('border', 1);\n\t\ttable.setAttribute('width', '100%');\n\t\ttable.appendChild(thead);\n\t\ttable.appendChild(tbody);\n\t\tdocument.getElementById('here').appendChild(table);\n\t};\n>注意：在 webkit内核的浏览器中，DOM的方法更快。所以，决定使用哪种方法更快取决于你的浏览器。如果在一个性能苛刻的操作中更新一大块 HTML 页面，innerHTML 在大多数浏览器中执行更快。但对于大多数日常操作而言，其差异并不大，所以你应当根据代码可读性，可维护性，团队习惯，代码风格来\n综合决定采用哪种方法。\n\n　　上面说到的建1000行表也可以用节点克隆来解决，但是性能提高的不是很明显，这里不再细说。\n\n---\nHTML 集合是用于存放 DOM 节点引用的类数组对象。下列函数的返回值就是一个集合：\n\n\tdocument.getElementsByName()\n\tdocument.getElementsByClassName()\n\tdocument.getElementsByTagName()\n\tdocument.images\n\tdocument.links\n\t...\n这里有一点需要优化的就是集合的遍历，集合的遍历是没有数组的遍历速度快的，所以尽量的将HTML集合拷贝到一个数组中，再进行遍历，看一下下面的例子：\n\n\tfunction toArray(coll) {\n\t\tfor (var i = 0, a = [], len = coll.length; i < len; i++) {\n\t\t\ta[i] = coll[i];\n\t\t}\n\t\treturn a;\n\t}\n\tvar coll = document.getElementsByTagName_r('div');\n\tvar arr = toArray(coll)\n\t//比较下面两个函数的快慢。\n\t//slower\n\tfunction loopCollection() {\n\t\tfor (var count = 0; count < coll.length; count++) {\n\t\t}\n\t}\n\t// faster\n\tfunction loopCopiedArray() {\n\t\tfor (var count = 0; count < arr.length; count++) {\n\t\t}\n\t}\n这个例子中还有很多的地方可以优化，比如“.length”，无论是调用数组还是集合的length属性，都意味着每次都要重新运行查询过程。所以，最好的办法是将length属性缓存到局部变量中，同样的，如果再循环中多次访问同一个集合元素，也用局部变量缓存它：\n\t\n\tfunction collectionNodesLocal() {\n\t\tvar coll = document.getElementsByTagName_r('div'),\n\t\tlen = coll.length,\n\t\tname = '',\n\t\tel = null;\n\t\tfor (var count = 0; count < len; count++) {\n\t\t\tel = coll[count];\n\t\t\tname = el.nodeName;\n\t\t\tname = el.nodeType;\n\t\t\tname = el.tagName;\n\t\t}\n\t\treturn name;\n\t};\n\n这样才能让你的DOM访问更有效率，节省性能的开销。\n\n---\n在抓取节点的时候，因为节点的类型有很多，如注释节点和文本节点等。而我们常用的是元素节点，所以，此时选择只表示元素节点的DOM属性:\n![只表示元素节点的 DOM 属性（HTML 标签）和表示所有节点的属性](http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img3-1.png)\n\n使用CSS选择器尽量使用浏览器原生的DOM函数，如： querySelectorAll()、querySelector等。\n\n---\n尽量阻止重排现象，否则会导致你的性能大减。在下述情况中会发生重排版：\n\n> - 添加或删除可见的 DOM 元素.\n> - 元素位置改变.\n> - 元素尺寸改变（因为边距，填充，边框宽度，宽度，高度等属性改变）\n> - 内容改变，例如，文本改变或图片被另一个不同尺寸的所替代\n> - 最初的页面渲染\n> - 浏览器窗口改变尺寸\n\n　　根据改变的性质，渲染树上或大或小的一部分需要重新计算。某些改变可导致重排版整个页面：例如，当一个滚动条出现时。\n\n　　大多数浏览器通过队列化修改和批量显示优化重排版过程。然而，你可\n能（经常不由自主地）强迫队列刷新并要求所有计划改变的部分立刻应用。获取布局信息的操作将导致刷新队列动作，这意味着使用了下面这些方法：\n\n\toffsetTop, offsetLeft, offsetWidth, offsetHeight\n\tscrollTop, scrollLeft, scrollWidth, scrollHeight\n\tclientTop, clientLeft, clientWidth, clientHeight\n\tgetComputedStyle() (currentStyle in IE)（在 IE 中此函数称为 currentStyle)\n在改变风格的过程中，最好不要使用前面列出的那些属性。任何一个访问都将刷新渲染队列，即使你正在获取那些最近未发生改变的或者与最新的改变无关的布局信息。\n\n在改变CSS属性时，尽量将所有改变合并在一起执行。只修改一次DOM。可以通过cssText来实现：\n\n\tvar el = document.getElementById('mydiv');\n\tel.style.cssText = 'border-left: 1px; border-right: 2px; padding: 5px;';\n下面例子是常见的写法，与上面的例子相比慢了很多。\n\n\tvar el = document.getElementById('mydiv');\n\tel.style.borderLeft = '1px';\n\tel.style.borderRight = '2px';\n\tel.style.padding = '5px';\n减少重排的方法一：\n　　从文档流中摘除该元素-->对其应用多重改变-->将元素带回文档中\n摘除元素可以用以下方法来进行：\n> - 隐藏元素，进行修改，然后再显示它。\n> - 使用一个文档片断在已存 DOM 之外创建一个子树，然后将它拷贝到文档中。\n> - 将原始元素拷贝到一个脱离文档的节点中，修改副本，然后覆盖原始元素。\n减少重排的方法二：\n　　在文档之外创建并更新一个文档片断，然后将它附加在原始列表上。文档片断是一个轻量级的 document 对象，它被设计专用于更新、移动节点之类的任务。文档片断一个便利的语法特性是当你向节点附加一个片断时，实际添加的是文档片断的子节点群，而不是片断自己。\n减少重排的方法三：\n　　创建要更新节点的副本，然后在副本上操作，最后用新节点覆盖老节点。\n\n---\n> - 大量的使用hover会降低反应速度，在IE8中更显著。\n\n> - 尽量使用时间托管来绑定事件，来提高性能。\n\n---\nSummary 总结\n===\n---\n　　DOM 访问和操作是现代网页应用中很重要的一部分。 但每次你通过桥梁从 ECMAScript 岛到达 DOM 岛时，都会被收取“过桥费”。为减少 DOM 编程中的性能损失，请牢记以下几点：\n\n> - 最小化 DOM 访问，在 JavaScript 端做尽可能多的事情。\n> - 在反复访问的地方使用局部变量存放 DOM 引用.\n> - 小心地处理 HTML 集合，因为他们表现出“存在性”，总是对底层文档重新查询。将集合的 length 属性缓存到一个变量中，在迭代中使用这个变量。如果经常操作这个集合，可以将集合拷贝到数组中。\n> - 如果可能的话，使用速度更快的 API，诸如 querySelectorAll()和 firstElementChild。\n> - 注意重绘和重排版；批量修改风格，离线操作 DOM 树，缓存并减少对布局信息的访问。\n> - 动画中使用绝对坐标，使用拖放代理。\n> - 使用事件托管技术最小化事件句柄数量。","source":"_posts/高性能JavaScript3.md","raw":"title: JavaScript DOM编程优化\ndate: 2015-08-1 10:20:11\ntags: 高性能JavaScript学习笔记\ncategories: 高性能JavaScript-3\n---\n**第三章 DOM Scripting DOM  编程**\n===\n　　回去看了一下前面两章的内容，发现写的内容都很多，但是过于繁琐，基本与原文解释的内容差不多，在后面的文章中，我将更多的写自己的理解，而不是更多的原文内容，如果对优化很感兴趣，可以详细的看一下《高性能JavaScript》这本书。在每章结束时，依旧有总结。\n<!--more-->\n　　在这章主要讨论以下三个问题。\n> - 1.访问和修改 DOM 元素。\n> - 2.修改 DOM 元素的样式，造成重绘和重新排版。\n> - 3.通过 DOM 事件处理用户响应。\n　　DOM 在浏览器中主要是用来操作 HTML 文档的。它天生就很慢，当你每次访问 DOM 时都需要耗费性能，这就好比每次 ECMAScript 需要访问 DOM 时，你需要过桥，交一次“过桥费”。所以，当你操作 DOM 次数越多，费用就越高。看一下下面这个例子：\n\n\tfunction innerHTMLLoop() {\n\t\tfor (var count = 0; count < 15000; count++) {\n\t\t\tdocument.getElementById('here').innerHTML += 'a';\n\t\t}\n\t}\n　　这个例子中，你每次循环都要访问DOM两次，一次是读取innerHTML，另一次是写入它。再看一下下面的改进版本。\n\n\tfunction innerHTMLLoop2() {\n\t\tvar content = '';\n\t\tfor (var count = 0; count < 15000; count++) {\n\t\t\tcontent += 'a';\n\t\t}\n\t\tdocument.getElementById('here').innerHTML += content;\n\t}\n　　**使用局部变量存储更新后的内容，在循环结束时一次性写入，如果循环非常大，你可能会发现性能会比之前快了几百倍。**\n\n　　还有一种优化方式，是用 innerHTML 来代替纯DOM ，innerHTML 会比纯 DOM方法快一点，下面两个例子分别建1000行的表：\ninnerHTML方法：\n\n\tfunction tableInnerHTML() {\n\t\tvar i, h = ['<table border=\"1\" width=\"100%\">'];\n\t\th.push('<thead>');\n\t\th.push('<tr><th>id<\\/th><th>yes?<\\/th><th>name<\\/th><th>url<\\/th><th>action<\\/th><\\/tr>');\n\t\th.push('<\\/thead>');\n\t\th.push('<tbody>');\n\t\tfor (i = 1; i <= 1000; i++) {\n\t\th.push('<tr><td>');\n\t\th.push(i);\n\t\th.push('<\\/td><td>');\n\t\th.push('And the answer is... ' + (i % 2 ? 'yes' : 'no'));\n\t\th.push('<\\/td><td>');\n\t\th.push('my name is #' + i);\n\t\th.push('<\\/td><td>');\n\t\th.push('<a href=\"http://example.org/' + i + '.html\">http://example.org/' + i + '.html<\\/a>');\n\t\th.push('<\\/td><td>');\n\t\th.push('<ul>');\n\t\th.push(' <li><a href=\"edit.php?id=' + i + '\">edit<\\/a><\\/li>');\n\t\th.push(' <li><a href=\"delete.php?id=\"' + i + '-id001\">delete<\\/a><\\/li>');\n\t\th.push('<\\/ul>');\n\t\th.push('<\\/td>');\n\t\th.push('<\\/tr>');\n\t\t}\n\t\th.push('<\\/tbody>');\n\t\th.push('<\\/table>');\n\t\tdocument.getElementById('here').innerHTML = h.join('');\n\t};\n如果使用 DOM 方法创建同样的表，代码有些冗长：\n\n\tfunction tableDOM() {\n\t\tvar i, table, thead, tbody, tr, th, td, a, ul, li;\n\t\ttbody = document.createElement ('tbody');\n\t\tfor (i = 1; i <= 1000; i++) {\n\t\t\ttr = document.createElement ('tr');\n\t\t\ttd = document.createElement ('td');\n\t\t\ttd.appendChild(document.createTextNode((i % 2) ? 'yes' : 'no'));\n\t\t\ttr.appendChild(td);\n\t\t\ttd = document.createElement ('td');\n\t\t\ttd.appendChild(document.createTextNode(i));\n\t\t\ttr.appendChild(td);\n\t\t\ttd = document.createElement ('td');\n\t\t\ttd.appendChild(document.createTextNode('my name is #' + i));\n\t\t\ttr.appendChild(td);\n\t\t\ta = document.createElement ('a');\n\t\t\ta.setAttribute('href', 'http://example.org/' + i + '.html');\n\t\t\ta.appendChild(document.createTextNode('http://example.org/' + i + '.html'));\n\t\t\ttd = document.createElement ('td');\n\t\t\ttd.appendChild(a);\n\t\t\ttr.appendChild(td);\n\t\t\tul = document.createElement ('ul');\n\t\t\ta = document.createElement ('a');\n\t\t\ta.setAttribute('href', 'edit.php?id=' + i);\n\t\t\ta.appendChild(document.createTextNode('edit'));\n\t\t\tli = document.createElement ('li');\n\t\t\tli.appendChild(a);\n\t\t\tul.appendChild(li);\n\t\t\ta = document.createElement ('a');\n\t\t\ta.setAttribute('href', 'delete.php?id=' + i);\n\t\t\ta.appendChild(document.createTextNode('delete'));\n\t\t\tli = document.createElement ('li');\n\t\t\tli.appendChild(a);\n\t\t\tul.appendChild(li);\n\t\t\ttd = document.createElement ('td');\n\t\t\ttd.appendChild(ul);\n\t\t\ttr.appendChild(td);\n\t\t\ttbody.appendChild(tr);\n\t\t}\n\t\ttr = document.createElement ('tr');\n\t\tth = document.createElement ('th');\n\t\tth.appendChild(document.createTextNode('yes?'));\n\t\ttr.appendChild(th);\n\t\tth = document.createElement ('th');\n\t\tth.appendChild(document.createTextNode('id'));\n\t\ttr.appendChild(th);\n\t\tth = document.createElement ('th');\n\t\tth.appendChild(document.createTextNode('name'));\n\t\ttr.appendChild(th);\n\t\tth = document.createElement('th');\n\t\tth.appendChild(document.createTextNode('url'));\n\t\ttr.appendChild(th);\n\t\tth = document.createElement('th');\n\t\tth.appendChild(document.createTextNode('action'));\n\t\ttr.appendChild(th);\n\t\tthead = document.createElement('thead');\n\t\tthead.appendChild(tr);\n\t\ttable = document.createElement('table');\n\t\ttable.setAttribute('border', 1);\n\t\ttable.setAttribute('width', '100%');\n\t\ttable.appendChild(thead);\n\t\ttable.appendChild(tbody);\n\t\tdocument.getElementById('here').appendChild(table);\n\t};\n>注意：在 webkit内核的浏览器中，DOM的方法更快。所以，决定使用哪种方法更快取决于你的浏览器。如果在一个性能苛刻的操作中更新一大块 HTML 页面，innerHTML 在大多数浏览器中执行更快。但对于大多数日常操作而言，其差异并不大，所以你应当根据代码可读性，可维护性，团队习惯，代码风格来\n综合决定采用哪种方法。\n\n　　上面说到的建1000行表也可以用节点克隆来解决，但是性能提高的不是很明显，这里不再细说。\n\n---\nHTML 集合是用于存放 DOM 节点引用的类数组对象。下列函数的返回值就是一个集合：\n\n\tdocument.getElementsByName()\n\tdocument.getElementsByClassName()\n\tdocument.getElementsByTagName()\n\tdocument.images\n\tdocument.links\n\t...\n这里有一点需要优化的就是集合的遍历，集合的遍历是没有数组的遍历速度快的，所以尽量的将HTML集合拷贝到一个数组中，再进行遍历，看一下下面的例子：\n\n\tfunction toArray(coll) {\n\t\tfor (var i = 0, a = [], len = coll.length; i < len; i++) {\n\t\t\ta[i] = coll[i];\n\t\t}\n\t\treturn a;\n\t}\n\tvar coll = document.getElementsByTagName_r('div');\n\tvar arr = toArray(coll)\n\t//比较下面两个函数的快慢。\n\t//slower\n\tfunction loopCollection() {\n\t\tfor (var count = 0; count < coll.length; count++) {\n\t\t}\n\t}\n\t// faster\n\tfunction loopCopiedArray() {\n\t\tfor (var count = 0; count < arr.length; count++) {\n\t\t}\n\t}\n这个例子中还有很多的地方可以优化，比如“.length”，无论是调用数组还是集合的length属性，都意味着每次都要重新运行查询过程。所以，最好的办法是将length属性缓存到局部变量中，同样的，如果再循环中多次访问同一个集合元素，也用局部变量缓存它：\n\t\n\tfunction collectionNodesLocal() {\n\t\tvar coll = document.getElementsByTagName_r('div'),\n\t\tlen = coll.length,\n\t\tname = '',\n\t\tel = null;\n\t\tfor (var count = 0; count < len; count++) {\n\t\t\tel = coll[count];\n\t\t\tname = el.nodeName;\n\t\t\tname = el.nodeType;\n\t\t\tname = el.tagName;\n\t\t}\n\t\treturn name;\n\t};\n\n这样才能让你的DOM访问更有效率，节省性能的开销。\n\n---\n在抓取节点的时候，因为节点的类型有很多，如注释节点和文本节点等。而我们常用的是元素节点，所以，此时选择只表示元素节点的DOM属性:\n![只表示元素节点的 DOM 属性（HTML 标签）和表示所有节点的属性](http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img3-1.png)\n\n使用CSS选择器尽量使用浏览器原生的DOM函数，如： querySelectorAll()、querySelector等。\n\n---\n尽量阻止重排现象，否则会导致你的性能大减。在下述情况中会发生重排版：\n\n> - 添加或删除可见的 DOM 元素.\n> - 元素位置改变.\n> - 元素尺寸改变（因为边距，填充，边框宽度，宽度，高度等属性改变）\n> - 内容改变，例如，文本改变或图片被另一个不同尺寸的所替代\n> - 最初的页面渲染\n> - 浏览器窗口改变尺寸\n\n　　根据改变的性质，渲染树上或大或小的一部分需要重新计算。某些改变可导致重排版整个页面：例如，当一个滚动条出现时。\n\n　　大多数浏览器通过队列化修改和批量显示优化重排版过程。然而，你可\n能（经常不由自主地）强迫队列刷新并要求所有计划改变的部分立刻应用。获取布局信息的操作将导致刷新队列动作，这意味着使用了下面这些方法：\n\n\toffsetTop, offsetLeft, offsetWidth, offsetHeight\n\tscrollTop, scrollLeft, scrollWidth, scrollHeight\n\tclientTop, clientLeft, clientWidth, clientHeight\n\tgetComputedStyle() (currentStyle in IE)（在 IE 中此函数称为 currentStyle)\n在改变风格的过程中，最好不要使用前面列出的那些属性。任何一个访问都将刷新渲染队列，即使你正在获取那些最近未发生改变的或者与最新的改变无关的布局信息。\n\n在改变CSS属性时，尽量将所有改变合并在一起执行。只修改一次DOM。可以通过cssText来实现：\n\n\tvar el = document.getElementById('mydiv');\n\tel.style.cssText = 'border-left: 1px; border-right: 2px; padding: 5px;';\n下面例子是常见的写法，与上面的例子相比慢了很多。\n\n\tvar el = document.getElementById('mydiv');\n\tel.style.borderLeft = '1px';\n\tel.style.borderRight = '2px';\n\tel.style.padding = '5px';\n减少重排的方法一：\n　　从文档流中摘除该元素-->对其应用多重改变-->将元素带回文档中\n摘除元素可以用以下方法来进行：\n> - 隐藏元素，进行修改，然后再显示它。\n> - 使用一个文档片断在已存 DOM 之外创建一个子树，然后将它拷贝到文档中。\n> - 将原始元素拷贝到一个脱离文档的节点中，修改副本，然后覆盖原始元素。\n减少重排的方法二：\n　　在文档之外创建并更新一个文档片断，然后将它附加在原始列表上。文档片断是一个轻量级的 document 对象，它被设计专用于更新、移动节点之类的任务。文档片断一个便利的语法特性是当你向节点附加一个片断时，实际添加的是文档片断的子节点群，而不是片断自己。\n减少重排的方法三：\n　　创建要更新节点的副本，然后在副本上操作，最后用新节点覆盖老节点。\n\n---\n> - 大量的使用hover会降低反应速度，在IE8中更显著。\n\n> - 尽量使用时间托管来绑定事件，来提高性能。\n\n---\nSummary 总结\n===\n---\n　　DOM 访问和操作是现代网页应用中很重要的一部分。 但每次你通过桥梁从 ECMAScript 岛到达 DOM 岛时，都会被收取“过桥费”。为减少 DOM 编程中的性能损失，请牢记以下几点：\n\n> - 最小化 DOM 访问，在 JavaScript 端做尽可能多的事情。\n> - 在反复访问的地方使用局部变量存放 DOM 引用.\n> - 小心地处理 HTML 集合，因为他们表现出“存在性”，总是对底层文档重新查询。将集合的 length 属性缓存到一个变量中，在迭代中使用这个变量。如果经常操作这个集合，可以将集合拷贝到数组中。\n> - 如果可能的话，使用速度更快的 API，诸如 querySelectorAll()和 firstElementChild。\n> - 注意重绘和重排版；批量修改风格，离线操作 DOM 树，缓存并减少对布局信息的访问。\n> - 动画中使用绝对坐标，使用拖放代理。\n> - 使用事件托管技术最小化事件句柄数量。","slug":"高性能JavaScript3","published":1,"updated":"2016-10-31T07:25:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciuyzluub000we6tb8iswmb3r","content":"<h1 id=\"第三章-DOM-Scripting-DOM-编程\"><a href=\"#第三章-DOM-Scripting-DOM-编程\" class=\"headerlink\" title=\"第三章 DOM Scripting DOM  编程\"></a><strong>第三章 DOM Scripting DOM  编程</strong></h1><p>　　回去看了一下前面两章的内容，发现写的内容都很多，但是过于繁琐，基本与原文解释的内容差不多，在后面的文章中，我将更多的写自己的理解，而不是更多的原文内容，如果对优化很感兴趣，可以详细的看一下《高性能JavaScript》这本书。在每章结束时，依旧有总结。<br><a id=\"more\"></a><br>　　在这章主要讨论以下三个问题。</p>\n<blockquote>\n<ul>\n<li>1.访问和修改 DOM 元素。</li>\n<li>2.修改 DOM 元素的样式，造成重绘和重新排版。</li>\n<li>3.通过 DOM 事件处理用户响应。<br>　　DOM 在浏览器中主要是用来操作 HTML 文档的。它天生就很慢，当你每次访问 DOM 时都需要耗费性能，这就好比每次 ECMAScript 需要访问 DOM 时，你需要过桥，交一次“过桥费”。所以，当你操作 DOM 次数越多，费用就越高。看一下下面这个例子：</li>\n</ul>\n</blockquote>\n<pre><code>function innerHTMLLoop() {\n    for (var count = 0; count &lt; 15000; count++) {\n        document.getElementById(&apos;here&apos;).innerHTML += &apos;a&apos;;\n    }\n}\n</code></pre><p>　　这个例子中，你每次循环都要访问DOM两次，一次是读取innerHTML，另一次是写入它。再看一下下面的改进版本。</p>\n<pre><code>function innerHTMLLoop2() {\n    var content = &apos;&apos;;\n    for (var count = 0; count &lt; 15000; count++) {\n        content += &apos;a&apos;;\n    }\n    document.getElementById(&apos;here&apos;).innerHTML += content;\n}\n</code></pre><p>　　<strong>使用局部变量存储更新后的内容，在循环结束时一次性写入，如果循环非常大，你可能会发现性能会比之前快了几百倍。</strong></p>\n<p>　　还有一种优化方式，是用 innerHTML 来代替纯DOM ，innerHTML 会比纯 DOM方法快一点，下面两个例子分别建1000行的表：<br>innerHTML方法：</p>\n<pre><code>function tableInnerHTML() {\n    var i, h = [&apos;&lt;table border=&quot;1&quot; width=&quot;100%&quot;&gt;&apos;];\n    h.push(&apos;&lt;thead&gt;&apos;);\n    h.push(&apos;&lt;tr&gt;&lt;th&gt;id&lt;\\/th&gt;&lt;th&gt;yes?&lt;\\/th&gt;&lt;th&gt;name&lt;\\/th&gt;&lt;th&gt;url&lt;\\/th&gt;&lt;th&gt;action&lt;\\/th&gt;&lt;\\/tr&gt;&apos;);\n    h.push(&apos;&lt;\\/thead&gt;&apos;);\n    h.push(&apos;&lt;tbody&gt;&apos;);\n    for (i = 1; i &lt;= 1000; i++) {\n    h.push(&apos;&lt;tr&gt;&lt;td&gt;&apos;);\n    h.push(i);\n    h.push(&apos;&lt;\\/td&gt;&lt;td&gt;&apos;);\n    h.push(&apos;And the answer is... &apos; + (i % 2 ? &apos;yes&apos; : &apos;no&apos;));\n    h.push(&apos;&lt;\\/td&gt;&lt;td&gt;&apos;);\n    h.push(&apos;my name is #&apos; + i);\n    h.push(&apos;&lt;\\/td&gt;&lt;td&gt;&apos;);\n    h.push(&apos;&lt;a href=&quot;http://example.org/&apos; + i + &apos;.html&quot;&gt;http://example.org/&apos; + i + &apos;.html&lt;\\/a&gt;&apos;);\n    h.push(&apos;&lt;\\/td&gt;&lt;td&gt;&apos;);\n    h.push(&apos;&lt;ul&gt;&apos;);\n    h.push(&apos; &lt;li&gt;&lt;a href=&quot;edit.php?id=&apos; + i + &apos;&quot;&gt;edit&lt;\\/a&gt;&lt;\\/li&gt;&apos;);\n    h.push(&apos; &lt;li&gt;&lt;a href=&quot;delete.php?id=&quot;&apos; + i + &apos;-id001&quot;&gt;delete&lt;\\/a&gt;&lt;\\/li&gt;&apos;);\n    h.push(&apos;&lt;\\/ul&gt;&apos;);\n    h.push(&apos;&lt;\\/td&gt;&apos;);\n    h.push(&apos;&lt;\\/tr&gt;&apos;);\n    }\n    h.push(&apos;&lt;\\/tbody&gt;&apos;);\n    h.push(&apos;&lt;\\/table&gt;&apos;);\n    document.getElementById(&apos;here&apos;).innerHTML = h.join(&apos;&apos;);\n};\n</code></pre><p>如果使用 DOM 方法创建同样的表，代码有些冗长：</p>\n<pre><code>function tableDOM() {\n    var i, table, thead, tbody, tr, th, td, a, ul, li;\n    tbody = document.createElement (&apos;tbody&apos;);\n    for (i = 1; i &lt;= 1000; i++) {\n        tr = document.createElement (&apos;tr&apos;);\n        td = document.createElement (&apos;td&apos;);\n        td.appendChild(document.createTextNode((i % 2) ? &apos;yes&apos; : &apos;no&apos;));\n        tr.appendChild(td);\n        td = document.createElement (&apos;td&apos;);\n        td.appendChild(document.createTextNode(i));\n        tr.appendChild(td);\n        td = document.createElement (&apos;td&apos;);\n        td.appendChild(document.createTextNode(&apos;my name is #&apos; + i));\n        tr.appendChild(td);\n        a = document.createElement (&apos;a&apos;);\n        a.setAttribute(&apos;href&apos;, &apos;http://example.org/&apos; + i + &apos;.html&apos;);\n        a.appendChild(document.createTextNode(&apos;http://example.org/&apos; + i + &apos;.html&apos;));\n        td = document.createElement (&apos;td&apos;);\n        td.appendChild(a);\n        tr.appendChild(td);\n        ul = document.createElement (&apos;ul&apos;);\n        a = document.createElement (&apos;a&apos;);\n        a.setAttribute(&apos;href&apos;, &apos;edit.php?id=&apos; + i);\n        a.appendChild(document.createTextNode(&apos;edit&apos;));\n        li = document.createElement (&apos;li&apos;);\n        li.appendChild(a);\n        ul.appendChild(li);\n        a = document.createElement (&apos;a&apos;);\n        a.setAttribute(&apos;href&apos;, &apos;delete.php?id=&apos; + i);\n        a.appendChild(document.createTextNode(&apos;delete&apos;));\n        li = document.createElement (&apos;li&apos;);\n        li.appendChild(a);\n        ul.appendChild(li);\n        td = document.createElement (&apos;td&apos;);\n        td.appendChild(ul);\n        tr.appendChild(td);\n        tbody.appendChild(tr);\n    }\n    tr = document.createElement (&apos;tr&apos;);\n    th = document.createElement (&apos;th&apos;);\n    th.appendChild(document.createTextNode(&apos;yes?&apos;));\n    tr.appendChild(th);\n    th = document.createElement (&apos;th&apos;);\n    th.appendChild(document.createTextNode(&apos;id&apos;));\n    tr.appendChild(th);\n    th = document.createElement (&apos;th&apos;);\n    th.appendChild(document.createTextNode(&apos;name&apos;));\n    tr.appendChild(th);\n    th = document.createElement(&apos;th&apos;);\n    th.appendChild(document.createTextNode(&apos;url&apos;));\n    tr.appendChild(th);\n    th = document.createElement(&apos;th&apos;);\n    th.appendChild(document.createTextNode(&apos;action&apos;));\n    tr.appendChild(th);\n    thead = document.createElement(&apos;thead&apos;);\n    thead.appendChild(tr);\n    table = document.createElement(&apos;table&apos;);\n    table.setAttribute(&apos;border&apos;, 1);\n    table.setAttribute(&apos;width&apos;, &apos;100%&apos;);\n    table.appendChild(thead);\n    table.appendChild(tbody);\n    document.getElementById(&apos;here&apos;).appendChild(table);\n};\n</code></pre><blockquote>\n<p>注意：在 webkit内核的浏览器中，DOM的方法更快。所以，决定使用哪种方法更快取决于你的浏览器。如果在一个性能苛刻的操作中更新一大块 HTML 页面，innerHTML 在大多数浏览器中执行更快。但对于大多数日常操作而言，其差异并不大，所以你应当根据代码可读性，可维护性，团队习惯，代码风格来<br>综合决定采用哪种方法。</p>\n</blockquote>\n<p>　　上面说到的建1000行表也可以用节点克隆来解决，但是性能提高的不是很明显，这里不再细说。</p>\n<hr>\n<p>HTML 集合是用于存放 DOM 节点引用的类数组对象。下列函数的返回值就是一个集合：</p>\n<pre><code>document.getElementsByName()\ndocument.getElementsByClassName()\ndocument.getElementsByTagName()\ndocument.images\ndocument.links\n...\n</code></pre><p>这里有一点需要优化的就是集合的遍历，集合的遍历是没有数组的遍历速度快的，所以尽量的将HTML集合拷贝到一个数组中，再进行遍历，看一下下面的例子：</p>\n<pre><code>function toArray(coll) {\n    for (var i = 0, a = [], len = coll.length; i &lt; len; i++) {\n        a[i] = coll[i];\n    }\n    return a;\n}\nvar coll = document.getElementsByTagName_r(&apos;div&apos;);\nvar arr = toArray(coll)\n//比较下面两个函数的快慢。\n//slower\nfunction loopCollection() {\n    for (var count = 0; count &lt; coll.length; count++) {\n    }\n}\n// faster\nfunction loopCopiedArray() {\n    for (var count = 0; count &lt; arr.length; count++) {\n    }\n}\n</code></pre><p>这个例子中还有很多的地方可以优化，比如“.length”，无论是调用数组还是集合的length属性，都意味着每次都要重新运行查询过程。所以，最好的办法是将length属性缓存到局部变量中，同样的，如果再循环中多次访问同一个集合元素，也用局部变量缓存它：</p>\n<pre><code>function collectionNodesLocal() {\n    var coll = document.getElementsByTagName_r(&apos;div&apos;),\n    len = coll.length,\n    name = &apos;&apos;,\n    el = null;\n    for (var count = 0; count &lt; len; count++) {\n        el = coll[count];\n        name = el.nodeName;\n        name = el.nodeType;\n        name = el.tagName;\n    }\n    return name;\n};\n</code></pre><p>这样才能让你的DOM访问更有效率，节省性能的开销。</p>\n<hr>\n<p>在抓取节点的时候，因为节点的类型有很多，如注释节点和文本节点等。而我们常用的是元素节点，所以，此时选择只表示元素节点的DOM属性:<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img3-1.png\" alt=\"只表示元素节点的 DOM 属性（HTML 标签）和表示所有节点的属性\"></p>\n<p>使用CSS选择器尽量使用浏览器原生的DOM函数，如： querySelectorAll()、querySelector等。</p>\n<hr>\n<p>尽量阻止重排现象，否则会导致你的性能大减。在下述情况中会发生重排版：</p>\n<blockquote>\n<ul>\n<li>添加或删除可见的 DOM 元素.</li>\n<li>元素位置改变.</li>\n<li>元素尺寸改变（因为边距，填充，边框宽度，宽度，高度等属性改变）</li>\n<li>内容改变，例如，文本改变或图片被另一个不同尺寸的所替代</li>\n<li>最初的页面渲染</li>\n<li>浏览器窗口改变尺寸</li>\n</ul>\n</blockquote>\n<p>　　根据改变的性质，渲染树上或大或小的一部分需要重新计算。某些改变可导致重排版整个页面：例如，当一个滚动条出现时。</p>\n<p>　　大多数浏览器通过队列化修改和批量显示优化重排版过程。然而，你可<br>能（经常不由自主地）强迫队列刷新并要求所有计划改变的部分立刻应用。获取布局信息的操作将导致刷新队列动作，这意味着使用了下面这些方法：</p>\n<pre><code>offsetTop, offsetLeft, offsetWidth, offsetHeight\nscrollTop, scrollLeft, scrollWidth, scrollHeight\nclientTop, clientLeft, clientWidth, clientHeight\ngetComputedStyle() (currentStyle in IE)（在 IE 中此函数称为 currentStyle)\n</code></pre><p>在改变风格的过程中，最好不要使用前面列出的那些属性。任何一个访问都将刷新渲染队列，即使你正在获取那些最近未发生改变的或者与最新的改变无关的布局信息。</p>\n<p>在改变CSS属性时，尽量将所有改变合并在一起执行。只修改一次DOM。可以通过cssText来实现：</p>\n<pre><code>var el = document.getElementById(&apos;mydiv&apos;);\nel.style.cssText = &apos;border-left: 1px; border-right: 2px; padding: 5px;&apos;;\n</code></pre><p>下面例子是常见的写法，与上面的例子相比慢了很多。</p>\n<pre><code>var el = document.getElementById(&apos;mydiv&apos;);\nel.style.borderLeft = &apos;1px&apos;;\nel.style.borderRight = &apos;2px&apos;;\nel.style.padding = &apos;5px&apos;;\n</code></pre><p>减少重排的方法一：<br>　　从文档流中摘除该元素–&gt;对其应用多重改变–&gt;将元素带回文档中<br>摘除元素可以用以下方法来进行：</p>\n<blockquote>\n<ul>\n<li>隐藏元素，进行修改，然后再显示它。</li>\n<li>使用一个文档片断在已存 DOM 之外创建一个子树，然后将它拷贝到文档中。</li>\n<li>将原始元素拷贝到一个脱离文档的节点中，修改副本，然后覆盖原始元素。<br>减少重排的方法二：<br>　　在文档之外创建并更新一个文档片断，然后将它附加在原始列表上。文档片断是一个轻量级的 document 对象，它被设计专用于更新、移动节点之类的任务。文档片断一个便利的语法特性是当你向节点附加一个片断时，实际添加的是文档片断的子节点群，而不是片断自己。<br>减少重排的方法三：<br>　　创建要更新节点的副本，然后在副本上操作，最后用新节点覆盖老节点。</li>\n</ul>\n</blockquote>\n<hr>\n<blockquote>\n<ul>\n<li><p>大量的使用hover会降低反应速度，在IE8中更显著。</p>\n</li>\n<li><p>尽量使用时间托管来绑定事件，来提高性能。</p>\n</li>\n</ul>\n</blockquote>\n<hr>\n<h1 id=\"Summary-总结\"><a href=\"#Summary-总结\" class=\"headerlink\" title=\"Summary 总结\"></a>Summary 总结</h1><hr>\n<p>　　DOM 访问和操作是现代网页应用中很重要的一部分。 但每次你通过桥梁从 ECMAScript 岛到达 DOM 岛时，都会被收取“过桥费”。为减少 DOM 编程中的性能损失，请牢记以下几点：</p>\n<blockquote>\n<ul>\n<li>最小化 DOM 访问，在 JavaScript 端做尽可能多的事情。</li>\n<li>在反复访问的地方使用局部变量存放 DOM 引用.</li>\n<li>小心地处理 HTML 集合，因为他们表现出“存在性”，总是对底层文档重新查询。将集合的 length 属性缓存到一个变量中，在迭代中使用这个变量。如果经常操作这个集合，可以将集合拷贝到数组中。</li>\n<li>如果可能的话，使用速度更快的 API，诸如 querySelectorAll()和 firstElementChild。</li>\n<li>注意重绘和重排版；批量修改风格，离线操作 DOM 树，缓存并减少对布局信息的访问。</li>\n<li>动画中使用绝对坐标，使用拖放代理。</li>\n<li>使用事件托管技术最小化事件句柄数量。</li>\n</ul>\n</blockquote>\n","excerpt":"<h1 id=\"第三章-DOM-Scripting-DOM-编程\"><a href=\"#第三章-DOM-Scripting-DOM-编程\" class=\"headerlink\" title=\"第三章 DOM Scripting DOM  编程\"></a><strong>第三章 DOM Scripting DOM  编程</strong></h1><p>　　回去看了一下前面两章的内容，发现写的内容都很多，但是过于繁琐，基本与原文解释的内容差不多，在后面的文章中，我将更多的写自己的理解，而不是更多的原文内容，如果对优化很感兴趣，可以详细的看一下《高性能JavaScript》这本书。在每章结束时，依旧有总结。<br>","more":"<br>　　在这章主要讨论以下三个问题。</p>\n<blockquote>\n<ul>\n<li>1.访问和修改 DOM 元素。</li>\n<li>2.修改 DOM 元素的样式，造成重绘和重新排版。</li>\n<li>3.通过 DOM 事件处理用户响应。<br>　　DOM 在浏览器中主要是用来操作 HTML 文档的。它天生就很慢，当你每次访问 DOM 时都需要耗费性能，这就好比每次 ECMAScript 需要访问 DOM 时，你需要过桥，交一次“过桥费”。所以，当你操作 DOM 次数越多，费用就越高。看一下下面这个例子：</li>\n</ul>\n</blockquote>\n<pre><code>function innerHTMLLoop() {\n    for (var count = 0; count &lt; 15000; count++) {\n        document.getElementById(&apos;here&apos;).innerHTML += &apos;a&apos;;\n    }\n}\n</code></pre><p>　　这个例子中，你每次循环都要访问DOM两次，一次是读取innerHTML，另一次是写入它。再看一下下面的改进版本。</p>\n<pre><code>function innerHTMLLoop2() {\n    var content = &apos;&apos;;\n    for (var count = 0; count &lt; 15000; count++) {\n        content += &apos;a&apos;;\n    }\n    document.getElementById(&apos;here&apos;).innerHTML += content;\n}\n</code></pre><p>　　<strong>使用局部变量存储更新后的内容，在循环结束时一次性写入，如果循环非常大，你可能会发现性能会比之前快了几百倍。</strong></p>\n<p>　　还有一种优化方式，是用 innerHTML 来代替纯DOM ，innerHTML 会比纯 DOM方法快一点，下面两个例子分别建1000行的表：<br>innerHTML方法：</p>\n<pre><code>function tableInnerHTML() {\n    var i, h = [&apos;&lt;table border=&quot;1&quot; width=&quot;100%&quot;&gt;&apos;];\n    h.push(&apos;&lt;thead&gt;&apos;);\n    h.push(&apos;&lt;tr&gt;&lt;th&gt;id&lt;\\/th&gt;&lt;th&gt;yes?&lt;\\/th&gt;&lt;th&gt;name&lt;\\/th&gt;&lt;th&gt;url&lt;\\/th&gt;&lt;th&gt;action&lt;\\/th&gt;&lt;\\/tr&gt;&apos;);\n    h.push(&apos;&lt;\\/thead&gt;&apos;);\n    h.push(&apos;&lt;tbody&gt;&apos;);\n    for (i = 1; i &lt;= 1000; i++) {\n    h.push(&apos;&lt;tr&gt;&lt;td&gt;&apos;);\n    h.push(i);\n    h.push(&apos;&lt;\\/td&gt;&lt;td&gt;&apos;);\n    h.push(&apos;And the answer is... &apos; + (i % 2 ? &apos;yes&apos; : &apos;no&apos;));\n    h.push(&apos;&lt;\\/td&gt;&lt;td&gt;&apos;);\n    h.push(&apos;my name is #&apos; + i);\n    h.push(&apos;&lt;\\/td&gt;&lt;td&gt;&apos;);\n    h.push(&apos;&lt;a href=&quot;http://example.org/&apos; + i + &apos;.html&quot;&gt;http://example.org/&apos; + i + &apos;.html&lt;\\/a&gt;&apos;);\n    h.push(&apos;&lt;\\/td&gt;&lt;td&gt;&apos;);\n    h.push(&apos;&lt;ul&gt;&apos;);\n    h.push(&apos; &lt;li&gt;&lt;a href=&quot;edit.php?id=&apos; + i + &apos;&quot;&gt;edit&lt;\\/a&gt;&lt;\\/li&gt;&apos;);\n    h.push(&apos; &lt;li&gt;&lt;a href=&quot;delete.php?id=&quot;&apos; + i + &apos;-id001&quot;&gt;delete&lt;\\/a&gt;&lt;\\/li&gt;&apos;);\n    h.push(&apos;&lt;\\/ul&gt;&apos;);\n    h.push(&apos;&lt;\\/td&gt;&apos;);\n    h.push(&apos;&lt;\\/tr&gt;&apos;);\n    }\n    h.push(&apos;&lt;\\/tbody&gt;&apos;);\n    h.push(&apos;&lt;\\/table&gt;&apos;);\n    document.getElementById(&apos;here&apos;).innerHTML = h.join(&apos;&apos;);\n};\n</code></pre><p>如果使用 DOM 方法创建同样的表，代码有些冗长：</p>\n<pre><code>function tableDOM() {\n    var i, table, thead, tbody, tr, th, td, a, ul, li;\n    tbody = document.createElement (&apos;tbody&apos;);\n    for (i = 1; i &lt;= 1000; i++) {\n        tr = document.createElement (&apos;tr&apos;);\n        td = document.createElement (&apos;td&apos;);\n        td.appendChild(document.createTextNode((i % 2) ? &apos;yes&apos; : &apos;no&apos;));\n        tr.appendChild(td);\n        td = document.createElement (&apos;td&apos;);\n        td.appendChild(document.createTextNode(i));\n        tr.appendChild(td);\n        td = document.createElement (&apos;td&apos;);\n        td.appendChild(document.createTextNode(&apos;my name is #&apos; + i));\n        tr.appendChild(td);\n        a = document.createElement (&apos;a&apos;);\n        a.setAttribute(&apos;href&apos;, &apos;http://example.org/&apos; + i + &apos;.html&apos;);\n        a.appendChild(document.createTextNode(&apos;http://example.org/&apos; + i + &apos;.html&apos;));\n        td = document.createElement (&apos;td&apos;);\n        td.appendChild(a);\n        tr.appendChild(td);\n        ul = document.createElement (&apos;ul&apos;);\n        a = document.createElement (&apos;a&apos;);\n        a.setAttribute(&apos;href&apos;, &apos;edit.php?id=&apos; + i);\n        a.appendChild(document.createTextNode(&apos;edit&apos;));\n        li = document.createElement (&apos;li&apos;);\n        li.appendChild(a);\n        ul.appendChild(li);\n        a = document.createElement (&apos;a&apos;);\n        a.setAttribute(&apos;href&apos;, &apos;delete.php?id=&apos; + i);\n        a.appendChild(document.createTextNode(&apos;delete&apos;));\n        li = document.createElement (&apos;li&apos;);\n        li.appendChild(a);\n        ul.appendChild(li);\n        td = document.createElement (&apos;td&apos;);\n        td.appendChild(ul);\n        tr.appendChild(td);\n        tbody.appendChild(tr);\n    }\n    tr = document.createElement (&apos;tr&apos;);\n    th = document.createElement (&apos;th&apos;);\n    th.appendChild(document.createTextNode(&apos;yes?&apos;));\n    tr.appendChild(th);\n    th = document.createElement (&apos;th&apos;);\n    th.appendChild(document.createTextNode(&apos;id&apos;));\n    tr.appendChild(th);\n    th = document.createElement (&apos;th&apos;);\n    th.appendChild(document.createTextNode(&apos;name&apos;));\n    tr.appendChild(th);\n    th = document.createElement(&apos;th&apos;);\n    th.appendChild(document.createTextNode(&apos;url&apos;));\n    tr.appendChild(th);\n    th = document.createElement(&apos;th&apos;);\n    th.appendChild(document.createTextNode(&apos;action&apos;));\n    tr.appendChild(th);\n    thead = document.createElement(&apos;thead&apos;);\n    thead.appendChild(tr);\n    table = document.createElement(&apos;table&apos;);\n    table.setAttribute(&apos;border&apos;, 1);\n    table.setAttribute(&apos;width&apos;, &apos;100%&apos;);\n    table.appendChild(thead);\n    table.appendChild(tbody);\n    document.getElementById(&apos;here&apos;).appendChild(table);\n};\n</code></pre><blockquote>\n<p>注意：在 webkit内核的浏览器中，DOM的方法更快。所以，决定使用哪种方法更快取决于你的浏览器。如果在一个性能苛刻的操作中更新一大块 HTML 页面，innerHTML 在大多数浏览器中执行更快。但对于大多数日常操作而言，其差异并不大，所以你应当根据代码可读性，可维护性，团队习惯，代码风格来<br>综合决定采用哪种方法。</p>\n</blockquote>\n<p>　　上面说到的建1000行表也可以用节点克隆来解决，但是性能提高的不是很明显，这里不再细说。</p>\n<hr>\n<p>HTML 集合是用于存放 DOM 节点引用的类数组对象。下列函数的返回值就是一个集合：</p>\n<pre><code>document.getElementsByName()\ndocument.getElementsByClassName()\ndocument.getElementsByTagName()\ndocument.images\ndocument.links\n...\n</code></pre><p>这里有一点需要优化的就是集合的遍历，集合的遍历是没有数组的遍历速度快的，所以尽量的将HTML集合拷贝到一个数组中，再进行遍历，看一下下面的例子：</p>\n<pre><code>function toArray(coll) {\n    for (var i = 0, a = [], len = coll.length; i &lt; len; i++) {\n        a[i] = coll[i];\n    }\n    return a;\n}\nvar coll = document.getElementsByTagName_r(&apos;div&apos;);\nvar arr = toArray(coll)\n//比较下面两个函数的快慢。\n//slower\nfunction loopCollection() {\n    for (var count = 0; count &lt; coll.length; count++) {\n    }\n}\n// faster\nfunction loopCopiedArray() {\n    for (var count = 0; count &lt; arr.length; count++) {\n    }\n}\n</code></pre><p>这个例子中还有很多的地方可以优化，比如“.length”，无论是调用数组还是集合的length属性，都意味着每次都要重新运行查询过程。所以，最好的办法是将length属性缓存到局部变量中，同样的，如果再循环中多次访问同一个集合元素，也用局部变量缓存它：</p>\n<pre><code>function collectionNodesLocal() {\n    var coll = document.getElementsByTagName_r(&apos;div&apos;),\n    len = coll.length,\n    name = &apos;&apos;,\n    el = null;\n    for (var count = 0; count &lt; len; count++) {\n        el = coll[count];\n        name = el.nodeName;\n        name = el.nodeType;\n        name = el.tagName;\n    }\n    return name;\n};\n</code></pre><p>这样才能让你的DOM访问更有效率，节省性能的开销。</p>\n<hr>\n<p>在抓取节点的时候，因为节点的类型有很多，如注释节点和文本节点等。而我们常用的是元素节点，所以，此时选择只表示元素节点的DOM属性:<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img3-1.png\" alt=\"只表示元素节点的 DOM 属性（HTML 标签）和表示所有节点的属性\"></p>\n<p>使用CSS选择器尽量使用浏览器原生的DOM函数，如： querySelectorAll()、querySelector等。</p>\n<hr>\n<p>尽量阻止重排现象，否则会导致你的性能大减。在下述情况中会发生重排版：</p>\n<blockquote>\n<ul>\n<li>添加或删除可见的 DOM 元素.</li>\n<li>元素位置改变.</li>\n<li>元素尺寸改变（因为边距，填充，边框宽度，宽度，高度等属性改变）</li>\n<li>内容改变，例如，文本改变或图片被另一个不同尺寸的所替代</li>\n<li>最初的页面渲染</li>\n<li>浏览器窗口改变尺寸</li>\n</ul>\n</blockquote>\n<p>　　根据改变的性质，渲染树上或大或小的一部分需要重新计算。某些改变可导致重排版整个页面：例如，当一个滚动条出现时。</p>\n<p>　　大多数浏览器通过队列化修改和批量显示优化重排版过程。然而，你可<br>能（经常不由自主地）强迫队列刷新并要求所有计划改变的部分立刻应用。获取布局信息的操作将导致刷新队列动作，这意味着使用了下面这些方法：</p>\n<pre><code>offsetTop, offsetLeft, offsetWidth, offsetHeight\nscrollTop, scrollLeft, scrollWidth, scrollHeight\nclientTop, clientLeft, clientWidth, clientHeight\ngetComputedStyle() (currentStyle in IE)（在 IE 中此函数称为 currentStyle)\n</code></pre><p>在改变风格的过程中，最好不要使用前面列出的那些属性。任何一个访问都将刷新渲染队列，即使你正在获取那些最近未发生改变的或者与最新的改变无关的布局信息。</p>\n<p>在改变CSS属性时，尽量将所有改变合并在一起执行。只修改一次DOM。可以通过cssText来实现：</p>\n<pre><code>var el = document.getElementById(&apos;mydiv&apos;);\nel.style.cssText = &apos;border-left: 1px; border-right: 2px; padding: 5px;&apos;;\n</code></pre><p>下面例子是常见的写法，与上面的例子相比慢了很多。</p>\n<pre><code>var el = document.getElementById(&apos;mydiv&apos;);\nel.style.borderLeft = &apos;1px&apos;;\nel.style.borderRight = &apos;2px&apos;;\nel.style.padding = &apos;5px&apos;;\n</code></pre><p>减少重排的方法一：<br>　　从文档流中摘除该元素–&gt;对其应用多重改变–&gt;将元素带回文档中<br>摘除元素可以用以下方法来进行：</p>\n<blockquote>\n<ul>\n<li>隐藏元素，进行修改，然后再显示它。</li>\n<li>使用一个文档片断在已存 DOM 之外创建一个子树，然后将它拷贝到文档中。</li>\n<li>将原始元素拷贝到一个脱离文档的节点中，修改副本，然后覆盖原始元素。<br>减少重排的方法二：<br>　　在文档之外创建并更新一个文档片断，然后将它附加在原始列表上。文档片断是一个轻量级的 document 对象，它被设计专用于更新、移动节点之类的任务。文档片断一个便利的语法特性是当你向节点附加一个片断时，实际添加的是文档片断的子节点群，而不是片断自己。<br>减少重排的方法三：<br>　　创建要更新节点的副本，然后在副本上操作，最后用新节点覆盖老节点。</li>\n</ul>\n</blockquote>\n<hr>\n<blockquote>\n<ul>\n<li><p>大量的使用hover会降低反应速度，在IE8中更显著。</p>\n</li>\n<li><p>尽量使用时间托管来绑定事件，来提高性能。</p>\n</li>\n</ul>\n</blockquote>\n<hr>\n<h1 id=\"Summary-总结\"><a href=\"#Summary-总结\" class=\"headerlink\" title=\"Summary 总结\"></a>Summary 总结</h1><hr>\n<p>　　DOM 访问和操作是现代网页应用中很重要的一部分。 但每次你通过桥梁从 ECMAScript 岛到达 DOM 岛时，都会被收取“过桥费”。为减少 DOM 编程中的性能损失，请牢记以下几点：</p>\n<blockquote>\n<ul>\n<li>最小化 DOM 访问，在 JavaScript 端做尽可能多的事情。</li>\n<li>在反复访问的地方使用局部变量存放 DOM 引用.</li>\n<li>小心地处理 HTML 集合，因为他们表现出“存在性”，总是对底层文档重新查询。将集合的 length 属性缓存到一个变量中，在迭代中使用这个变量。如果经常操作这个集合，可以将集合拷贝到数组中。</li>\n<li>如果可能的话，使用速度更快的 API，诸如 querySelectorAll()和 firstElementChild。</li>\n<li>注意重绘和重排版；批量修改风格，离线操作 DOM 树，缓存并减少对布局信息的访问。</li>\n<li>动画中使用绝对坐标，使用拖放代理。</li>\n<li>使用事件托管技术最小化事件句柄数量。</li>\n</ul>\n</blockquote>"},{"title":"JavaScript数据访问的优化","date":"2015-07-31T05:42:30.000Z","_content":"**第二章 Data Access 数据访问**\n===\n本文章结尾处有结论，不愿意看原理或者已经懂原理的可以直接看结论。\n<!--more-->\n---\n　　经典计算机科学的一个问题是确定数据应当存放在什么地方， 以实现最佳的读写效率。数据存储的位置关系到访问的速度。在 JavaScript 中，有四种基本的数据访问位置：\n> - 直接量： 包括字符串，数字，布尔值，对象，数组，函数，正则表达式，具有特殊意义的空值（null），以及未定义（undefined）。\n> - 变量：用 var 关键字创建用于存储数据值。\n> - 数组项：具有数字索引，存储一个 JavaScript 数组对象。\n> - 对象成员：具有字符串索引，存储一个 JavaScript 对象。\n\n　　在一些老的浏览器中，直接量和局部变量的访问速度远远快于数组项和对象成员的访问速度（Firefox3 中优化过数组项，所以访问速度非常快）。**所以，如果关心运行速度，建议尽量使用直接量和局部变量，限制数组项和对象成员的使用。下图是对不同数据类型进行 200 000 次读操作所用的时间\n![对不同数据类型进行 200 000 次读操作所用的时间](http://7xkj1z.com1.z0.glb.clouddn.com/高性能js-img2-1.png)\n> 下面介绍几种模式来避免这种情况并优化你的代码。\n\n一.Managing Scope 管理作用域\n===\n---\n　　无论是从性能还是功能考虑，作用域链都是理解JavaScript的关键。但是要理解速度与作用域的关系，首先要理解作用域的工作原理。\n**1.Scope Chains and Identifier Resolution 作用域链和标识符解析**\n在这里不详细叙述作用域的工作原理，只是简单的说明一下作用域链的工作过程。如果想看详细原理，请参看我的文章[作用域链和标识符详细解析](http://www.winnerweb.club/2015/07/31/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E6%A0%87%E8%AF%86%E7%AC%A6%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/)。\n　　每一段 JavaScript 代码（全局代码或者函数）都有一个与之关联的作用域链(scope chain)。这个作用域链是一个对象链表，这组对象定义了这段代码“作用域中”的变量。当JavaScript需要查找变量x的值得时候（这个过程叫做变量解析），它会从链中的第一个对象(第一个对象是局部变量)开始查找，如果这个对象有一个名为x的属性，则会直接使用，若第二个对象依然没有，则会继续寻找下一个对象。以此类推，直至全局对象。若作用域链上没有任何一个对象含有属性x，那么就会返回一个undefined，在严格规范的ECMAScript 5中，会抛出一个异常。函数运行时每个标识符都要经过这样的搜索过程，正是这种搜索过程影响了性能。\n\n**Identifier Resolution Performance 标识符识别性能**\n　　在运行期上下文中，一个标识符所处的位置越深，读写速度也就越慢，所以局部变量访问速度是最快的，全局变量位于作用域链的最后一个位置是最慢的。下图展示了不同深度标识符的读写速度。（第一个写，第二个是读）\n![写操作的标识符识别速度](http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-2.png)\n![读操作的标识符识别速度](http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-3.png)\n　　采用优化JavaScript引擎的浏览器，如Safari4，访问域外标识符时没有性能的损失。其它浏览器都有较大幅度的影响。早期的IE6和Firefox2，有着令人难以置信的陡峭斜坡，如果此图包含它们的数据，曲线高点将超出图表边界。\n> 所以，在没有优化JavaScript引擎的浏览器中，尽可能使用局部变量。用局部变量存储本地范围之外的变量值。如果在函数中多次使用，参考以下例子：\n\n\tfunction initUI(){\n\t\tvar bd = document.body,\n\t\tlinks = document.getElementsByTagName_r(\"a\"),\n\t\ti = 0,\n\t\tlen = links.length;\n\t\twhile(i < len){\n\t\t\tupdate(links[i++]);\n\t\t}\n\t\tdocument.getElementById(\"go-btn\").onclick = function(){\n\t\t\tstart();\n\t\t};\n\t\tbd.className = \"active\";\n\t}\n　　次函数包含对document的引用，而document是全局变量。每次搜索此变量都要遍历整个作用域链。上述代码可以优化为：\n\n\tfunction initUI(){\n\t\tvar doc = document,\n\t\tbd = doc.body,\n\t\tlinks = doc.getElementsByTagName_r(\"a\"),\n\t\ti = 0,\n\t\tlen = links.length;\n\t\twhile(i < len){\n\t\t\tupdate(links[i++]);\n\t\t}\n\t\tdoc.getElementById(\"go-btn\").onclick = function(){\n\t\t\tstart();\n\t\t};\n\t\tbd.className = \"active\";\n\t}\n　　这个简单的函数不会显示出巨大的改进，如果几十个全局变量被反复访问，那么这么做性能将有显著的提高。\n**Scope Chain Augmentation 改变作用域链**\n　　一般来说，一个运行期上下文的作用域链不会被改变。但是，有两种表达式可以在运行时临时改变运行期上下文作用域链。第一个是 with 表达式。第二种是try-catch。with 表达式为所有对象属性创建一个默认操作变量。在其他语言中，类似的功能通常用来避免书写一些\n重复的代码。initUI()函数可以重写成如下样式：\n\n\tfunction initUI(){\n\t\twith (document){ //avoid!\n\t\tvar bd = body,\n\t\tlinks = getElementsByTagName_r(\"a\"),\n\t\ti = 0,\n\t\tlen = links.length;\n\t\twhile(i < len){\n\t\t\tupdate(links[i++]);\n\t\t}\n\t\tgetElementById(\"go-btn\").onclick = function(){\n\t\t\tstart();\n\t\t};\n\t\t\tbd.className = \"active\";\n\t\t}\n\t}\n　　**此重写的 initUI()版本使用了一个with表达式，避免多次书写“document”。这看起来似乎更有效率，而实际上却产生了一个性能问题。**\n当代码流执行到一个with表达式时，运行期上下文的作用域链被临时改变了。一个新的可变对象将被创建，它包含指定对象的所有属性。此对象被插入到作用域链的前端，意味着现在函数的所有局部变量都被推入第二个作用域链对象中，所以访问代价更高了，正因为这个原因，最好不要使用 with 表达式。正如前面提到的，只要简单地将 document 存储在一个\n局部变量中，就可以获得性能上的提升。（见下图）。\n![with 表达式改变作用域链](http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-4.png)。\n　　在 JavaScript 中不只是 with 表达式人为地改变运行期上下文的作用域链，try-catch 表达式的 catch 子句具有相同效果。当 try 块发生错误时，程序流程自动转入 catch 块，并将异常对象推入作用域链前端的一个可变对象中。在 catch 块中，函数的所有局部变量现在被放在第二个作用域链对象中。例如：\n\n\ttry {\n\t\tmethodThatMightCauseAnError();\n\t} catch (ex){\n\t\talert(ex.message); //scope chain is augmented here\n\t}\n**请注意，只要 catch 子句执行完毕，作用域链就会返回到原来的状态。**\n　　如果使用得当， try-catch 表达式是非常有用的语句，所以不建议完全避免。 如果你计划使用一个 try-catch语句，请确保你了解可能发生的错误。一个 try-catch 语句不应该作为 JavaScript 错误的解决办法。如果你知道一个错误会经常发生，那说明应当修正代码本身的问题。\n你可以通过精缩代码的办法最小化catch子句对性能的影响。一个很好的模式是将错误交给一个专用函数来处理。例子如下：\n\n\ttry {\n\t\tmethodThatMightCauseAnError();\n\t} catch (ex){\n\t\thandleError(ex); //delegate to handler method\n\t}\n　　handleError()函数是 catch 子句中运行的唯一代码。此函数以适当方法自由地处理错误，并接收由错误产生的异常对象。由于只有一条语句，没有局部变量访问，作用域链临时改变就不会影响代码的性能。\n**Dynamic Scopes 动态作用域**\n　　无论是 with 表达式还是 try-catch 表达式的 catch 子句，以及包含()的函数，都被认为是动态作用域。一个动态作用域只因代码运行而存在，因此无法通过静态分析（察看代码结构）来确定（是否存在动态作用域）\n\n\tfunction execute(code) {\n\t\t(code);\n\t\tfunction subroutine(){\n\t\t\treturn window;\n\t\t}\n\t\tvar w = subroutine();\n\t\t//what value is w?\n\t};\n　　execute()函数看上去像一个动态作用域，因为它使用了()。w 变量的值与 code 有关。大多数情况下，w将等价于全局的window对象，但是请考虑如下情况：\n\t\n\texecute(\"var window = {};\")\n　　这种情况下，()在 execute()函数中创建了一个局部window变量。所以w将等价于这个局部window变量而不是全局的那个。所以说，不运行这段代码是没有办法了解具体情况的，标识符 window 的确切含义不能预先确定。\n　　优化的 JavaScript 引擎，例如 Safari 的 Nitro 引擎，企图通过分析代码来确定哪些变量应该在任意时刻被访问，来加快标识符识别过程。这些引擎企图避开传统作用域链查找，取代以标识符索引的方式进行快速查找。当涉及一个动态作用域后，此优化方法就不起作用了。引擎需要切回慢速的基于哈希表的标识符识别方法，更像传统的作用域链搜索。\n　　正因为这个原因，只在绝对必要时才推荐使用动态作用域。\n**Closures, Scope, and Memory 闭包，作用域，和内存**\n　　闭包是 JavaScript 最强大的一个方面，它允许函数访问局部范围之外的数据。闭包的使用通过 Douglas\nCrockford的著作流行起来，当今在最复杂的网页应用中无处不在。不过，有一种性能影响与闭包有关。\n　　为了解与闭包有关的性能问题，考虑下面的例子：\n\n\tfunction assignEvents(){\n\t\tvar id = \"xdi9592\";\n\t\tdocument.getElementById(\"save-btn\").onclick = function(event){\n\t\t\tsaveDocument(id);\n\t\t};\n\t}\n　　当 assignEvents()被执行时，一个激活对象被创建，并包含了一些应有的内容，其中包括 id变量。它将成为运行期上下文作用域链上的第一个对象，全局对象是第二个。当闭包创建时，[[Scope]]属性与这些对象一起被初始化（见下图）。\n![assignEvents()运行期上下文的作用域链和闭包](http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-5.png)。\n　　由于闭包的[[Scope]]属性包含与运行期上下文作用域链相同的对象引用，会产生副作用。通常，一个函数的激活对象与运行期上下文一同销毁。当涉及闭包时，激活对象就无法销毁了，因为引用仍然存在于闭包的[[Scope]]属性中。这意味着脚本中的闭包与非闭包函数相比，需要更多内存开销。在大型网页应用中，\n这可能是个问题，尤其在 Internet Explorer 中更被关注。IE 使用非本地 JavaScript 对象实现 DOM 对象，闭包可能导致内存泄露（更多信息参见第 3 章）。\n　　当闭包被执行时，一个运行期上下文将被创建，它的作用域链与[[Scope]]中引用的两个相同的作用域链同时被初始化，然后一个新的激活对象为闭包自身被创建（参见下图）。\n![闭包运行](http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-6.png)。\n　　注意闭包中使用的两个标识符，id 和 saveDocument，存在于作用域链第一个对象之后的位置上。这是闭包最主要的性能关注点：你经常访问一些范围之外的标识符，每次访问都导致一些性能损失。\n>在脚本中最好是小心地使用闭包，内存和运行速度都值得被关注。但是，你可以通过本章早先讨论过的关于域外变量的处理建议，减轻对运行速度的影响：将常用的域外变量存入局部变量中，然后直接访问局部变量。\n\n**Prototypes 原形**\n　　JavaScript中的对象是基于原形的。原形是其他对象的基础，定义并实现了一个新对象所必须具有的成员。这一概念完全不同于传统面向对象编程中“类”的概念，它定义了创建新对象的过程。原形对象为所有给定类型的对象实例所共享，因此所有实例共享原形对象的成员。\n　　一个对象通过一个内部属性绑定到它的原形。Firefox，Safari，和 Chrome 向开发人员开放这一属性，称作__proto__其他浏览器不允许脚本访问这一属性。任何时候你创建一个内置类型的实例，如 Object 或 Array，这些实例自动拥有一个 Object 作为它们的原形。\n　　因此，对象可以有两种类型的成员：实例成员（也称作“own”成员）和原形成员。实例成员直接存在于实例自身，而原形成员则从对象原形继承。考虑下面的例子：\n\n\tvar book = {\n\t\ttitle: \"High Performance JavaScript\",\n\t\tpublisher: \"Yahoo! Press\"\n\t};\n\talert(book.toString()); //\"[object Object]\"\n此代码中，book 对象有两个实例成员：title 和 publisher。注意它并没有定义 toString()接口，但是这个接口却被调用了，也没有抛出错误。toString()函数就是一个 book 对象继承的原形成员。下图显示出它们之间的关系。\n![实例与原形的关系](http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-7.png)。\n　　处理对象成员的过程与变量处理十分相似。当 book.toString()被调用时，对成员进行名为“toString”的搜索，首先从对象实例开始，如果 book 没有名为 toString 的成员，那么就转向搜索原形对象，在那里发现了toString()方法并执行它。通过这种方法，booke 可以访问它的原形所拥有的每个属性或方法。\n　　你可以使用 hasOwnProperty()函数确定一个对象是否具有特定名称的实例成员，（它的参数就是成员名称）。要确定对象是否具有某个名称的属性，你可以使用操作符 in。例如：\n\n\tvar book = {\n\t\ttitle: \"High Performance JavaScript\",\n\t\tpublisher: \"Yahoo! Press\"\n\t};\n\talert(book.hasOwnProperty(\"title\")); //true\n\talert(book.hasOwnProperty(\"toString\")); //false\n\talert(\"title\" in book); //true\n\talert(\"toString\" in book); //true\n此代码中， hasOwnProperty()传入“title”时返回true， 因为title是一个实例成员。 传入“toString”时返回false，因为 toString 不在实例之中。如果使用 in 操作符检测这两个属性，那么返回都是 true，因为它既搜索实例又搜索原形。\n**Prototype Chains 原形链**\n对象的原形决定了一个实例的类型。默认情况下，所有对象都是 Object 的实例，并继承了所有基本方法，如 toString()。你可以用“构造器”创建另外一种类型的原形。例如：\n\t\n\tfunction Book(title, publisher){\n\t\tthis.title = title;\n\t\tthis.publisher = publisher;\n\t}\n\tBook.prototype.sayTitle = function(){\n\t\talert(this.title);\n\t};\n\tvar book1 = new Book(\"High Performance JavaScript\", \"Yahoo! Press\");\n\tvar book2 = new Book(\"JavaScript: The Good Parts\", \"Yahoo! Press\");\n\talert(book1 instanceof Book); //true\n\talert(book1 instanceof Object); //true\n\tbook1.sayTitle(); //\"High Performance JavaScript\"\n\talert(book1.toString()); //\"[object Object]\"\n原型链关系如下图：\n![原形链](http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-8.png)\n　　注意，两个 Book 实例共享同一个原形链。每个实例拥有自己的 title 和 publisher 属性，但其他成员均继承自原形。当 book1.toString()被调用时，搜索工作必须深入原形链才能找到对象成员“toString”。正如你所\n怀疑的那样，深入原形链越深，搜索的速度就会越慢。图2-11显示出成员在原形链中所处的深度与访问时间的关系。\n　　虽然使用优化 JavaScript 引擎的新式浏览器在此任务中表现良好，但是老的浏览器，特别是 Internet Explorer 和 Firefox 3.5，每深入原形链一层都会增加性能损失。记住，搜索实例成员的过程比访问直接量\n或者局部变量负担更重，所以增加遍历原形链的开销正好放大了这种效果。\n\n**Nested Members 嵌套成员**\n由于对象成员可能包含其它成员， 例如不太常见的写法 window.location.href 这种模式每遇到一个点号，JavaScript 引擎就要在对象成员上执行一次解析过程。成员嵌套越深，访问速度越慢。location.href 总是快于 window.location.href，而后者也要\n比 window.location.href.toString()更快。\n**Caching Object Member Values 缓存对象成员的值**\n\n\tfunction hasEitherClass(element, className1, className2){\n\t\treturn element.className == className1 || element.className == className2;\n\t}\n这段代码中element.className被访问了两次，而且在这个函数过程中它的值是不会变的。所以优化如下：\n\n\tfunction hasEitherClass(element, className1, className2){\n\t\tvar currentClassName = element.className;\n\t\treturn currentClassName == className1 || currentClassName == className2;\n\t}\n>一般来说，如果在同一个函数中你要多次读取同一个对象属性，最好将它存入一个局部变量。以局部变量替代属性，避免多余的属性查找带来性能开销。在处理嵌套对象成员时这点特别重要，它们会对运行速度产生难以置信的影响。\n\nSummary 总结\n===\n---\n在JavaScript中，数据存储位置可以对代码整体性能产生重要影响。有四种数据访问类型：直接量，变量，数组项，对象成员。它们有不同的性能考虑。\n\n> - 直接量和局部变量访问速度非常快，数组项和对象成员需要更长时间。\n> - 局部变量比域外变量快，因为它位于作用域链的第一个对象中。变量在作用域链中的位置越深，访问所需的时间就越长。全局变量总是最慢的，因为它们总是位于作用域链的最后一环。\n> - 避免使用 with 表达式， 因为它改变了运行期上下文的作用域链。 而且应当小心对待 try-catch 表达式的catch子句，因为它具有同样效果。\n> - 嵌套对象成员会造成重大性能影响，尽量少用。\n> - 一个属性或方法在原形链中的位置越深，访问它的速度就越慢。\n> - 一般来说，你可以通过这种方法提高JavaScript代码的性能：将经常使用的对象成员，数组项，和域外变量存入局部变量中。然后，访问局部变量的速度会快于那些原始变量。\n\n---\n通过使用这些策略，你可以极大地提高那些需要大量 JavaScript 代码的网页应用的实际性能。","source":"_posts/高性能JavaScript2.md","raw":"title: JavaScript数据访问的优化\ndate: 2015-07-31 13:42:30\ntags: 高性能JavaScript学习笔记\ncategories: 高性能JavaScript-2\n---\n**第二章 Data Access 数据访问**\n===\n本文章结尾处有结论，不愿意看原理或者已经懂原理的可以直接看结论。\n<!--more-->\n---\n　　经典计算机科学的一个问题是确定数据应当存放在什么地方， 以实现最佳的读写效率。数据存储的位置关系到访问的速度。在 JavaScript 中，有四种基本的数据访问位置：\n> - 直接量： 包括字符串，数字，布尔值，对象，数组，函数，正则表达式，具有特殊意义的空值（null），以及未定义（undefined）。\n> - 变量：用 var 关键字创建用于存储数据值。\n> - 数组项：具有数字索引，存储一个 JavaScript 数组对象。\n> - 对象成员：具有字符串索引，存储一个 JavaScript 对象。\n\n　　在一些老的浏览器中，直接量和局部变量的访问速度远远快于数组项和对象成员的访问速度（Firefox3 中优化过数组项，所以访问速度非常快）。**所以，如果关心运行速度，建议尽量使用直接量和局部变量，限制数组项和对象成员的使用。下图是对不同数据类型进行 200 000 次读操作所用的时间\n![对不同数据类型进行 200 000 次读操作所用的时间](http://7xkj1z.com1.z0.glb.clouddn.com/高性能js-img2-1.png)\n> 下面介绍几种模式来避免这种情况并优化你的代码。\n\n一.Managing Scope 管理作用域\n===\n---\n　　无论是从性能还是功能考虑，作用域链都是理解JavaScript的关键。但是要理解速度与作用域的关系，首先要理解作用域的工作原理。\n**1.Scope Chains and Identifier Resolution 作用域链和标识符解析**\n在这里不详细叙述作用域的工作原理，只是简单的说明一下作用域链的工作过程。如果想看详细原理，请参看我的文章[作用域链和标识符详细解析](http://www.winnerweb.club/2015/07/31/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E6%A0%87%E8%AF%86%E7%AC%A6%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/)。\n　　每一段 JavaScript 代码（全局代码或者函数）都有一个与之关联的作用域链(scope chain)。这个作用域链是一个对象链表，这组对象定义了这段代码“作用域中”的变量。当JavaScript需要查找变量x的值得时候（这个过程叫做变量解析），它会从链中的第一个对象(第一个对象是局部变量)开始查找，如果这个对象有一个名为x的属性，则会直接使用，若第二个对象依然没有，则会继续寻找下一个对象。以此类推，直至全局对象。若作用域链上没有任何一个对象含有属性x，那么就会返回一个undefined，在严格规范的ECMAScript 5中，会抛出一个异常。函数运行时每个标识符都要经过这样的搜索过程，正是这种搜索过程影响了性能。\n\n**Identifier Resolution Performance 标识符识别性能**\n　　在运行期上下文中，一个标识符所处的位置越深，读写速度也就越慢，所以局部变量访问速度是最快的，全局变量位于作用域链的最后一个位置是最慢的。下图展示了不同深度标识符的读写速度。（第一个写，第二个是读）\n![写操作的标识符识别速度](http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-2.png)\n![读操作的标识符识别速度](http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-3.png)\n　　采用优化JavaScript引擎的浏览器，如Safari4，访问域外标识符时没有性能的损失。其它浏览器都有较大幅度的影响。早期的IE6和Firefox2，有着令人难以置信的陡峭斜坡，如果此图包含它们的数据，曲线高点将超出图表边界。\n> 所以，在没有优化JavaScript引擎的浏览器中，尽可能使用局部变量。用局部变量存储本地范围之外的变量值。如果在函数中多次使用，参考以下例子：\n\n\tfunction initUI(){\n\t\tvar bd = document.body,\n\t\tlinks = document.getElementsByTagName_r(\"a\"),\n\t\ti = 0,\n\t\tlen = links.length;\n\t\twhile(i < len){\n\t\t\tupdate(links[i++]);\n\t\t}\n\t\tdocument.getElementById(\"go-btn\").onclick = function(){\n\t\t\tstart();\n\t\t};\n\t\tbd.className = \"active\";\n\t}\n　　次函数包含对document的引用，而document是全局变量。每次搜索此变量都要遍历整个作用域链。上述代码可以优化为：\n\n\tfunction initUI(){\n\t\tvar doc = document,\n\t\tbd = doc.body,\n\t\tlinks = doc.getElementsByTagName_r(\"a\"),\n\t\ti = 0,\n\t\tlen = links.length;\n\t\twhile(i < len){\n\t\t\tupdate(links[i++]);\n\t\t}\n\t\tdoc.getElementById(\"go-btn\").onclick = function(){\n\t\t\tstart();\n\t\t};\n\t\tbd.className = \"active\";\n\t}\n　　这个简单的函数不会显示出巨大的改进，如果几十个全局变量被反复访问，那么这么做性能将有显著的提高。\n**Scope Chain Augmentation 改变作用域链**\n　　一般来说，一个运行期上下文的作用域链不会被改变。但是，有两种表达式可以在运行时临时改变运行期上下文作用域链。第一个是 with 表达式。第二种是try-catch。with 表达式为所有对象属性创建一个默认操作变量。在其他语言中，类似的功能通常用来避免书写一些\n重复的代码。initUI()函数可以重写成如下样式：\n\n\tfunction initUI(){\n\t\twith (document){ //avoid!\n\t\tvar bd = body,\n\t\tlinks = getElementsByTagName_r(\"a\"),\n\t\ti = 0,\n\t\tlen = links.length;\n\t\twhile(i < len){\n\t\t\tupdate(links[i++]);\n\t\t}\n\t\tgetElementById(\"go-btn\").onclick = function(){\n\t\t\tstart();\n\t\t};\n\t\t\tbd.className = \"active\";\n\t\t}\n\t}\n　　**此重写的 initUI()版本使用了一个with表达式，避免多次书写“document”。这看起来似乎更有效率，而实际上却产生了一个性能问题。**\n当代码流执行到一个with表达式时，运行期上下文的作用域链被临时改变了。一个新的可变对象将被创建，它包含指定对象的所有属性。此对象被插入到作用域链的前端，意味着现在函数的所有局部变量都被推入第二个作用域链对象中，所以访问代价更高了，正因为这个原因，最好不要使用 with 表达式。正如前面提到的，只要简单地将 document 存储在一个\n局部变量中，就可以获得性能上的提升。（见下图）。\n![with 表达式改变作用域链](http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-4.png)。\n　　在 JavaScript 中不只是 with 表达式人为地改变运行期上下文的作用域链，try-catch 表达式的 catch 子句具有相同效果。当 try 块发生错误时，程序流程自动转入 catch 块，并将异常对象推入作用域链前端的一个可变对象中。在 catch 块中，函数的所有局部变量现在被放在第二个作用域链对象中。例如：\n\n\ttry {\n\t\tmethodThatMightCauseAnError();\n\t} catch (ex){\n\t\talert(ex.message); //scope chain is augmented here\n\t}\n**请注意，只要 catch 子句执行完毕，作用域链就会返回到原来的状态。**\n　　如果使用得当， try-catch 表达式是非常有用的语句，所以不建议完全避免。 如果你计划使用一个 try-catch语句，请确保你了解可能发生的错误。一个 try-catch 语句不应该作为 JavaScript 错误的解决办法。如果你知道一个错误会经常发生，那说明应当修正代码本身的问题。\n你可以通过精缩代码的办法最小化catch子句对性能的影响。一个很好的模式是将错误交给一个专用函数来处理。例子如下：\n\n\ttry {\n\t\tmethodThatMightCauseAnError();\n\t} catch (ex){\n\t\thandleError(ex); //delegate to handler method\n\t}\n　　handleError()函数是 catch 子句中运行的唯一代码。此函数以适当方法自由地处理错误，并接收由错误产生的异常对象。由于只有一条语句，没有局部变量访问，作用域链临时改变就不会影响代码的性能。\n**Dynamic Scopes 动态作用域**\n　　无论是 with 表达式还是 try-catch 表达式的 catch 子句，以及包含()的函数，都被认为是动态作用域。一个动态作用域只因代码运行而存在，因此无法通过静态分析（察看代码结构）来确定（是否存在动态作用域）\n\n\tfunction execute(code) {\n\t\t(code);\n\t\tfunction subroutine(){\n\t\t\treturn window;\n\t\t}\n\t\tvar w = subroutine();\n\t\t//what value is w?\n\t};\n　　execute()函数看上去像一个动态作用域，因为它使用了()。w 变量的值与 code 有关。大多数情况下，w将等价于全局的window对象，但是请考虑如下情况：\n\t\n\texecute(\"var window = {};\")\n　　这种情况下，()在 execute()函数中创建了一个局部window变量。所以w将等价于这个局部window变量而不是全局的那个。所以说，不运行这段代码是没有办法了解具体情况的，标识符 window 的确切含义不能预先确定。\n　　优化的 JavaScript 引擎，例如 Safari 的 Nitro 引擎，企图通过分析代码来确定哪些变量应该在任意时刻被访问，来加快标识符识别过程。这些引擎企图避开传统作用域链查找，取代以标识符索引的方式进行快速查找。当涉及一个动态作用域后，此优化方法就不起作用了。引擎需要切回慢速的基于哈希表的标识符识别方法，更像传统的作用域链搜索。\n　　正因为这个原因，只在绝对必要时才推荐使用动态作用域。\n**Closures, Scope, and Memory 闭包，作用域，和内存**\n　　闭包是 JavaScript 最强大的一个方面，它允许函数访问局部范围之外的数据。闭包的使用通过 Douglas\nCrockford的著作流行起来，当今在最复杂的网页应用中无处不在。不过，有一种性能影响与闭包有关。\n　　为了解与闭包有关的性能问题，考虑下面的例子：\n\n\tfunction assignEvents(){\n\t\tvar id = \"xdi9592\";\n\t\tdocument.getElementById(\"save-btn\").onclick = function(event){\n\t\t\tsaveDocument(id);\n\t\t};\n\t}\n　　当 assignEvents()被执行时，一个激活对象被创建，并包含了一些应有的内容，其中包括 id变量。它将成为运行期上下文作用域链上的第一个对象，全局对象是第二个。当闭包创建时，[[Scope]]属性与这些对象一起被初始化（见下图）。\n![assignEvents()运行期上下文的作用域链和闭包](http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-5.png)。\n　　由于闭包的[[Scope]]属性包含与运行期上下文作用域链相同的对象引用，会产生副作用。通常，一个函数的激活对象与运行期上下文一同销毁。当涉及闭包时，激活对象就无法销毁了，因为引用仍然存在于闭包的[[Scope]]属性中。这意味着脚本中的闭包与非闭包函数相比，需要更多内存开销。在大型网页应用中，\n这可能是个问题，尤其在 Internet Explorer 中更被关注。IE 使用非本地 JavaScript 对象实现 DOM 对象，闭包可能导致内存泄露（更多信息参见第 3 章）。\n　　当闭包被执行时，一个运行期上下文将被创建，它的作用域链与[[Scope]]中引用的两个相同的作用域链同时被初始化，然后一个新的激活对象为闭包自身被创建（参见下图）。\n![闭包运行](http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-6.png)。\n　　注意闭包中使用的两个标识符，id 和 saveDocument，存在于作用域链第一个对象之后的位置上。这是闭包最主要的性能关注点：你经常访问一些范围之外的标识符，每次访问都导致一些性能损失。\n>在脚本中最好是小心地使用闭包，内存和运行速度都值得被关注。但是，你可以通过本章早先讨论过的关于域外变量的处理建议，减轻对运行速度的影响：将常用的域外变量存入局部变量中，然后直接访问局部变量。\n\n**Prototypes 原形**\n　　JavaScript中的对象是基于原形的。原形是其他对象的基础，定义并实现了一个新对象所必须具有的成员。这一概念完全不同于传统面向对象编程中“类”的概念，它定义了创建新对象的过程。原形对象为所有给定类型的对象实例所共享，因此所有实例共享原形对象的成员。\n　　一个对象通过一个内部属性绑定到它的原形。Firefox，Safari，和 Chrome 向开发人员开放这一属性，称作__proto__其他浏览器不允许脚本访问这一属性。任何时候你创建一个内置类型的实例，如 Object 或 Array，这些实例自动拥有一个 Object 作为它们的原形。\n　　因此，对象可以有两种类型的成员：实例成员（也称作“own”成员）和原形成员。实例成员直接存在于实例自身，而原形成员则从对象原形继承。考虑下面的例子：\n\n\tvar book = {\n\t\ttitle: \"High Performance JavaScript\",\n\t\tpublisher: \"Yahoo! Press\"\n\t};\n\talert(book.toString()); //\"[object Object]\"\n此代码中，book 对象有两个实例成员：title 和 publisher。注意它并没有定义 toString()接口，但是这个接口却被调用了，也没有抛出错误。toString()函数就是一个 book 对象继承的原形成员。下图显示出它们之间的关系。\n![实例与原形的关系](http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-7.png)。\n　　处理对象成员的过程与变量处理十分相似。当 book.toString()被调用时，对成员进行名为“toString”的搜索，首先从对象实例开始，如果 book 没有名为 toString 的成员，那么就转向搜索原形对象，在那里发现了toString()方法并执行它。通过这种方法，booke 可以访问它的原形所拥有的每个属性或方法。\n　　你可以使用 hasOwnProperty()函数确定一个对象是否具有特定名称的实例成员，（它的参数就是成员名称）。要确定对象是否具有某个名称的属性，你可以使用操作符 in。例如：\n\n\tvar book = {\n\t\ttitle: \"High Performance JavaScript\",\n\t\tpublisher: \"Yahoo! Press\"\n\t};\n\talert(book.hasOwnProperty(\"title\")); //true\n\talert(book.hasOwnProperty(\"toString\")); //false\n\talert(\"title\" in book); //true\n\talert(\"toString\" in book); //true\n此代码中， hasOwnProperty()传入“title”时返回true， 因为title是一个实例成员。 传入“toString”时返回false，因为 toString 不在实例之中。如果使用 in 操作符检测这两个属性，那么返回都是 true，因为它既搜索实例又搜索原形。\n**Prototype Chains 原形链**\n对象的原形决定了一个实例的类型。默认情况下，所有对象都是 Object 的实例，并继承了所有基本方法，如 toString()。你可以用“构造器”创建另外一种类型的原形。例如：\n\t\n\tfunction Book(title, publisher){\n\t\tthis.title = title;\n\t\tthis.publisher = publisher;\n\t}\n\tBook.prototype.sayTitle = function(){\n\t\talert(this.title);\n\t};\n\tvar book1 = new Book(\"High Performance JavaScript\", \"Yahoo! Press\");\n\tvar book2 = new Book(\"JavaScript: The Good Parts\", \"Yahoo! Press\");\n\talert(book1 instanceof Book); //true\n\talert(book1 instanceof Object); //true\n\tbook1.sayTitle(); //\"High Performance JavaScript\"\n\talert(book1.toString()); //\"[object Object]\"\n原型链关系如下图：\n![原形链](http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-8.png)\n　　注意，两个 Book 实例共享同一个原形链。每个实例拥有自己的 title 和 publisher 属性，但其他成员均继承自原形。当 book1.toString()被调用时，搜索工作必须深入原形链才能找到对象成员“toString”。正如你所\n怀疑的那样，深入原形链越深，搜索的速度就会越慢。图2-11显示出成员在原形链中所处的深度与访问时间的关系。\n　　虽然使用优化 JavaScript 引擎的新式浏览器在此任务中表现良好，但是老的浏览器，特别是 Internet Explorer 和 Firefox 3.5，每深入原形链一层都会增加性能损失。记住，搜索实例成员的过程比访问直接量\n或者局部变量负担更重，所以增加遍历原形链的开销正好放大了这种效果。\n\n**Nested Members 嵌套成员**\n由于对象成员可能包含其它成员， 例如不太常见的写法 window.location.href 这种模式每遇到一个点号，JavaScript 引擎就要在对象成员上执行一次解析过程。成员嵌套越深，访问速度越慢。location.href 总是快于 window.location.href，而后者也要\n比 window.location.href.toString()更快。\n**Caching Object Member Values 缓存对象成员的值**\n\n\tfunction hasEitherClass(element, className1, className2){\n\t\treturn element.className == className1 || element.className == className2;\n\t}\n这段代码中element.className被访问了两次，而且在这个函数过程中它的值是不会变的。所以优化如下：\n\n\tfunction hasEitherClass(element, className1, className2){\n\t\tvar currentClassName = element.className;\n\t\treturn currentClassName == className1 || currentClassName == className2;\n\t}\n>一般来说，如果在同一个函数中你要多次读取同一个对象属性，最好将它存入一个局部变量。以局部变量替代属性，避免多余的属性查找带来性能开销。在处理嵌套对象成员时这点特别重要，它们会对运行速度产生难以置信的影响。\n\nSummary 总结\n===\n---\n在JavaScript中，数据存储位置可以对代码整体性能产生重要影响。有四种数据访问类型：直接量，变量，数组项，对象成员。它们有不同的性能考虑。\n\n> - 直接量和局部变量访问速度非常快，数组项和对象成员需要更长时间。\n> - 局部变量比域外变量快，因为它位于作用域链的第一个对象中。变量在作用域链中的位置越深，访问所需的时间就越长。全局变量总是最慢的，因为它们总是位于作用域链的最后一环。\n> - 避免使用 with 表达式， 因为它改变了运行期上下文的作用域链。 而且应当小心对待 try-catch 表达式的catch子句，因为它具有同样效果。\n> - 嵌套对象成员会造成重大性能影响，尽量少用。\n> - 一个属性或方法在原形链中的位置越深，访问它的速度就越慢。\n> - 一般来说，你可以通过这种方法提高JavaScript代码的性能：将经常使用的对象成员，数组项，和域外变量存入局部变量中。然后，访问局部变量的速度会快于那些原始变量。\n\n---\n通过使用这些策略，你可以极大地提高那些需要大量 JavaScript 代码的网页应用的实际性能。","slug":"高性能JavaScript2","published":1,"updated":"2016-10-31T07:25:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciuyzluud0011e6tbmn3af4yd","content":"<h1 id=\"第二章-Data-Access-数据访问\"><a href=\"#第二章-Data-Access-数据访问\" class=\"headerlink\" title=\"第二章 Data Access 数据访问\"></a><strong>第二章 Data Access 数据访问</strong></h1><p>本文章结尾处有结论，不愿意看原理或者已经懂原理的可以直接看结论。</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><a id=\"more\"></a></h2><p>　　经典计算机科学的一个问题是确定数据应当存放在什么地方， 以实现最佳的读写效率。数据存储的位置关系到访问的速度。在 JavaScript 中，有四种基本的数据访问位置：</p>\n<blockquote>\n<ul>\n<li>直接量： 包括字符串，数字，布尔值，对象，数组，函数，正则表达式，具有特殊意义的空值（null），以及未定义（undefined）。</li>\n<li>变量：用 var 关键字创建用于存储数据值。</li>\n<li>数组项：具有数字索引，存储一个 JavaScript 数组对象。</li>\n<li>对象成员：具有字符串索引，存储一个 JavaScript 对象。</li>\n</ul>\n</blockquote>\n<p>　　在一些老的浏览器中，直接量和局部变量的访问速度远远快于数组项和对象成员的访问速度（Firefox3 中优化过数组项，所以访问速度非常快）。**所以，如果关心运行速度，建议尽量使用直接量和局部变量，限制数组项和对象成员的使用。下图是对不同数据类型进行 200 000 次读操作所用的时间<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/高性能js-img2-1.png\" alt=\"对不同数据类型进行 200 000 次读操作所用的时间\"></p>\n<blockquote>\n<p>下面介绍几种模式来避免这种情况并优化你的代码。</p>\n</blockquote>\n<h1 id=\"一-Managing-Scope-管理作用域\"><a href=\"#一-Managing-Scope-管理作用域\" class=\"headerlink\" title=\"一.Managing Scope 管理作用域\"></a>一.Managing Scope 管理作用域</h1><hr>\n<p>　　无论是从性能还是功能考虑，作用域链都是理解JavaScript的关键。但是要理解速度与作用域的关系，首先要理解作用域的工作原理。<br><strong>1.Scope Chains and Identifier Resolution 作用域链和标识符解析</strong><br>在这里不详细叙述作用域的工作原理，只是简单的说明一下作用域链的工作过程。如果想看详细原理，请参看我的文章<a href=\"http://www.winnerweb.club/2015/07/31/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E6%A0%87%E8%AF%86%E7%AC%A6%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/\" target=\"_blank\" rel=\"external\">作用域链和标识符详细解析</a>。<br>　　每一段 JavaScript 代码（全局代码或者函数）都有一个与之关联的作用域链(scope chain)。这个作用域链是一个对象链表，这组对象定义了这段代码“作用域中”的变量。当JavaScript需要查找变量x的值得时候（这个过程叫做变量解析），它会从链中的第一个对象(第一个对象是局部变量)开始查找，如果这个对象有一个名为x的属性，则会直接使用，若第二个对象依然没有，则会继续寻找下一个对象。以此类推，直至全局对象。若作用域链上没有任何一个对象含有属性x，那么就会返回一个undefined，在严格规范的ECMAScript 5中，会抛出一个异常。函数运行时每个标识符都要经过这样的搜索过程，正是这种搜索过程影响了性能。</p>\n<p><strong>Identifier Resolution Performance 标识符识别性能</strong><br>　　在运行期上下文中，一个标识符所处的位置越深，读写速度也就越慢，所以局部变量访问速度是最快的，全局变量位于作用域链的最后一个位置是最慢的。下图展示了不同深度标识符的读写速度。（第一个写，第二个是读）<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-2.png\" alt=\"写操作的标识符识别速度\"><br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-3.png\" alt=\"读操作的标识符识别速度\"><br>　　采用优化JavaScript引擎的浏览器，如Safari4，访问域外标识符时没有性能的损失。其它浏览器都有较大幅度的影响。早期的IE6和Firefox2，有着令人难以置信的陡峭斜坡，如果此图包含它们的数据，曲线高点将超出图表边界。</p>\n<blockquote>\n<p>所以，在没有优化JavaScript引擎的浏览器中，尽可能使用局部变量。用局部变量存储本地范围之外的变量值。如果在函数中多次使用，参考以下例子：</p>\n</blockquote>\n<pre><code>function initUI(){\n    var bd = document.body,\n    links = document.getElementsByTagName_r(&quot;a&quot;),\n    i = 0,\n    len = links.length;\n    while(i &lt; len){\n        update(links[i++]);\n    }\n    document.getElementById(&quot;go-btn&quot;).onclick = function(){\n        start();\n    };\n    bd.className = &quot;active&quot;;\n}\n</code></pre><p>　　次函数包含对document的引用，而document是全局变量。每次搜索此变量都要遍历整个作用域链。上述代码可以优化为：</p>\n<pre><code>function initUI(){\n    var doc = document,\n    bd = doc.body,\n    links = doc.getElementsByTagName_r(&quot;a&quot;),\n    i = 0,\n    len = links.length;\n    while(i &lt; len){\n        update(links[i++]);\n    }\n    doc.getElementById(&quot;go-btn&quot;).onclick = function(){\n        start();\n    };\n    bd.className = &quot;active&quot;;\n}\n</code></pre><p>　　这个简单的函数不会显示出巨大的改进，如果几十个全局变量被反复访问，那么这么做性能将有显著的提高。<br><strong>Scope Chain Augmentation 改变作用域链</strong><br>　　一般来说，一个运行期上下文的作用域链不会被改变。但是，有两种表达式可以在运行时临时改变运行期上下文作用域链。第一个是 with 表达式。第二种是try-catch。with 表达式为所有对象属性创建一个默认操作变量。在其他语言中，类似的功能通常用来避免书写一些<br>重复的代码。initUI()函数可以重写成如下样式：</p>\n<pre><code>function initUI(){\n    with (document){ //avoid!\n    var bd = body,\n    links = getElementsByTagName_r(&quot;a&quot;),\n    i = 0,\n    len = links.length;\n    while(i &lt; len){\n        update(links[i++]);\n    }\n    getElementById(&quot;go-btn&quot;).onclick = function(){\n        start();\n    };\n        bd.className = &quot;active&quot;;\n    }\n}\n</code></pre><p>　　<strong>此重写的 initUI()版本使用了一个with表达式，避免多次书写“document”。这看起来似乎更有效率，而实际上却产生了一个性能问题。</strong><br>当代码流执行到一个with表达式时，运行期上下文的作用域链被临时改变了。一个新的可变对象将被创建，它包含指定对象的所有属性。此对象被插入到作用域链的前端，意味着现在函数的所有局部变量都被推入第二个作用域链对象中，所以访问代价更高了，正因为这个原因，最好不要使用 with 表达式。正如前面提到的，只要简单地将 document 存储在一个<br>局部变量中，就可以获得性能上的提升。（见下图）。<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-4.png\" alt=\"with 表达式改变作用域链\">。<br>　　在 JavaScript 中不只是 with 表达式人为地改变运行期上下文的作用域链，try-catch 表达式的 catch 子句具有相同效果。当 try 块发生错误时，程序流程自动转入 catch 块，并将异常对象推入作用域链前端的一个可变对象中。在 catch 块中，函数的所有局部变量现在被放在第二个作用域链对象中。例如：</p>\n<pre><code>try {\n    methodThatMightCauseAnError();\n} catch (ex){\n    alert(ex.message); //scope chain is augmented here\n}\n</code></pre><p><strong>请注意，只要 catch 子句执行完毕，作用域链就会返回到原来的状态。</strong><br>　　如果使用得当， try-catch 表达式是非常有用的语句，所以不建议完全避免。 如果你计划使用一个 try-catch语句，请确保你了解可能发生的错误。一个 try-catch 语句不应该作为 JavaScript 错误的解决办法。如果你知道一个错误会经常发生，那说明应当修正代码本身的问题。<br>你可以通过精缩代码的办法最小化catch子句对性能的影响。一个很好的模式是将错误交给一个专用函数来处理。例子如下：</p>\n<pre><code>try {\n    methodThatMightCauseAnError();\n} catch (ex){\n    handleError(ex); //delegate to handler method\n}\n</code></pre><p>　　handleError()函数是 catch 子句中运行的唯一代码。此函数以适当方法自由地处理错误，并接收由错误产生的异常对象。由于只有一条语句，没有局部变量访问，作用域链临时改变就不会影响代码的性能。<br><strong>Dynamic Scopes 动态作用域</strong><br>　　无论是 with 表达式还是 try-catch 表达式的 catch 子句，以及包含()的函数，都被认为是动态作用域。一个动态作用域只因代码运行而存在，因此无法通过静态分析（察看代码结构）来确定（是否存在动态作用域）</p>\n<pre><code>function execute(code) {\n    (code);\n    function subroutine(){\n        return window;\n    }\n    var w = subroutine();\n    //what value is w?\n};\n</code></pre><p>　　execute()函数看上去像一个动态作用域，因为它使用了()。w 变量的值与 code 有关。大多数情况下，w将等价于全局的window对象，但是请考虑如下情况：</p>\n<pre><code>execute(&quot;var window = {};&quot;)\n</code></pre><p>　　这种情况下，()在 execute()函数中创建了一个局部window变量。所以w将等价于这个局部window变量而不是全局的那个。所以说，不运行这段代码是没有办法了解具体情况的，标识符 window 的确切含义不能预先确定。<br>　　优化的 JavaScript 引擎，例如 Safari 的 Nitro 引擎，企图通过分析代码来确定哪些变量应该在任意时刻被访问，来加快标识符识别过程。这些引擎企图避开传统作用域链查找，取代以标识符索引的方式进行快速查找。当涉及一个动态作用域后，此优化方法就不起作用了。引擎需要切回慢速的基于哈希表的标识符识别方法，更像传统的作用域链搜索。<br>　　正因为这个原因，只在绝对必要时才推荐使用动态作用域。<br><strong>Closures, Scope, and Memory 闭包，作用域，和内存</strong><br>　　闭包是 JavaScript 最强大的一个方面，它允许函数访问局部范围之外的数据。闭包的使用通过 Douglas<br>Crockford的著作流行起来，当今在最复杂的网页应用中无处不在。不过，有一种性能影响与闭包有关。<br>　　为了解与闭包有关的性能问题，考虑下面的例子：</p>\n<pre><code>function assignEvents(){\n    var id = &quot;xdi9592&quot;;\n    document.getElementById(&quot;save-btn&quot;).onclick = function(event){\n        saveDocument(id);\n    };\n}\n</code></pre><p>　　当 assignEvents()被执行时，一个激活对象被创建，并包含了一些应有的内容，其中包括 id变量。它将成为运行期上下文作用域链上的第一个对象，全局对象是第二个。当闭包创建时，[[Scope]]属性与这些对象一起被初始化（见下图）。<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-5.png\" alt=\"assignEvents()运行期上下文的作用域链和闭包\">。<br>　　由于闭包的[[Scope]]属性包含与运行期上下文作用域链相同的对象引用，会产生副作用。通常，一个函数的激活对象与运行期上下文一同销毁。当涉及闭包时，激活对象就无法销毁了，因为引用仍然存在于闭包的[[Scope]]属性中。这意味着脚本中的闭包与非闭包函数相比，需要更多内存开销。在大型网页应用中，<br>这可能是个问题，尤其在 Internet Explorer 中更被关注。IE 使用非本地 JavaScript 对象实现 DOM 对象，闭包可能导致内存泄露（更多信息参见第 3 章）。<br>　　当闭包被执行时，一个运行期上下文将被创建，它的作用域链与[[Scope]]中引用的两个相同的作用域链同时被初始化，然后一个新的激活对象为闭包自身被创建（参见下图）。<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-6.png\" alt=\"闭包运行\">。<br>　　注意闭包中使用的两个标识符，id 和 saveDocument，存在于作用域链第一个对象之后的位置上。这是闭包最主要的性能关注点：你经常访问一些范围之外的标识符，每次访问都导致一些性能损失。</p>\n<blockquote>\n<p>在脚本中最好是小心地使用闭包，内存和运行速度都值得被关注。但是，你可以通过本章早先讨论过的关于域外变量的处理建议，减轻对运行速度的影响：将常用的域外变量存入局部变量中，然后直接访问局部变量。</p>\n</blockquote>\n<p><strong>Prototypes 原形</strong><br>　　JavaScript中的对象是基于原形的。原形是其他对象的基础，定义并实现了一个新对象所必须具有的成员。这一概念完全不同于传统面向对象编程中“类”的概念，它定义了创建新对象的过程。原形对象为所有给定类型的对象实例所共享，因此所有实例共享原形对象的成员。<br>　　一个对象通过一个内部属性绑定到它的原形。Firefox，Safari，和 Chrome 向开发人员开放这一属性，称作<strong>proto</strong>其他浏览器不允许脚本访问这一属性。任何时候你创建一个内置类型的实例，如 Object 或 Array，这些实例自动拥有一个 Object 作为它们的原形。<br>　　因此，对象可以有两种类型的成员：实例成员（也称作“own”成员）和原形成员。实例成员直接存在于实例自身，而原形成员则从对象原形继承。考虑下面的例子：</p>\n<pre><code>var book = {\n    title: &quot;High Performance JavaScript&quot;,\n    publisher: &quot;Yahoo! Press&quot;\n};\nalert(book.toString()); //&quot;[object Object]&quot;\n</code></pre><p>此代码中，book 对象有两个实例成员：title 和 publisher。注意它并没有定义 toString()接口，但是这个接口却被调用了，也没有抛出错误。toString()函数就是一个 book 对象继承的原形成员。下图显示出它们之间的关系。<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-7.png\" alt=\"实例与原形的关系\">。<br>　　处理对象成员的过程与变量处理十分相似。当 book.toString()被调用时，对成员进行名为“toString”的搜索，首先从对象实例开始，如果 book 没有名为 toString 的成员，那么就转向搜索原形对象，在那里发现了toString()方法并执行它。通过这种方法，booke 可以访问它的原形所拥有的每个属性或方法。<br>　　你可以使用 hasOwnProperty()函数确定一个对象是否具有特定名称的实例成员，（它的参数就是成员名称）。要确定对象是否具有某个名称的属性，你可以使用操作符 in。例如：</p>\n<pre><code>var book = {\n    title: &quot;High Performance JavaScript&quot;,\n    publisher: &quot;Yahoo! Press&quot;\n};\nalert(book.hasOwnProperty(&quot;title&quot;)); //true\nalert(book.hasOwnProperty(&quot;toString&quot;)); //false\nalert(&quot;title&quot; in book); //true\nalert(&quot;toString&quot; in book); //true\n</code></pre><p>此代码中， hasOwnProperty()传入“title”时返回true， 因为title是一个实例成员。 传入“toString”时返回false，因为 toString 不在实例之中。如果使用 in 操作符检测这两个属性，那么返回都是 true，因为它既搜索实例又搜索原形。<br><strong>Prototype Chains 原形链</strong><br>对象的原形决定了一个实例的类型。默认情况下，所有对象都是 Object 的实例，并继承了所有基本方法，如 toString()。你可以用“构造器”创建另外一种类型的原形。例如：</p>\n<pre><code>function Book(title, publisher){\n    this.title = title;\n    this.publisher = publisher;\n}\nBook.prototype.sayTitle = function(){\n    alert(this.title);\n};\nvar book1 = new Book(&quot;High Performance JavaScript&quot;, &quot;Yahoo! Press&quot;);\nvar book2 = new Book(&quot;JavaScript: The Good Parts&quot;, &quot;Yahoo! Press&quot;);\nalert(book1 instanceof Book); //true\nalert(book1 instanceof Object); //true\nbook1.sayTitle(); //&quot;High Performance JavaScript&quot;\nalert(book1.toString()); //&quot;[object Object]&quot;\n</code></pre><p>原型链关系如下图：<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-8.png\" alt=\"原形链\"><br>　　注意，两个 Book 实例共享同一个原形链。每个实例拥有自己的 title 和 publisher 属性，但其他成员均继承自原形。当 book1.toString()被调用时，搜索工作必须深入原形链才能找到对象成员“toString”。正如你所<br>怀疑的那样，深入原形链越深，搜索的速度就会越慢。图2-11显示出成员在原形链中所处的深度与访问时间的关系。<br>　　虽然使用优化 JavaScript 引擎的新式浏览器在此任务中表现良好，但是老的浏览器，特别是 Internet Explorer 和 Firefox 3.5，每深入原形链一层都会增加性能损失。记住，搜索实例成员的过程比访问直接量<br>或者局部变量负担更重，所以增加遍历原形链的开销正好放大了这种效果。</p>\n<p><strong>Nested Members 嵌套成员</strong><br>由于对象成员可能包含其它成员， 例如不太常见的写法 window.location.href 这种模式每遇到一个点号，JavaScript 引擎就要在对象成员上执行一次解析过程。成员嵌套越深，访问速度越慢。location.href 总是快于 window.location.href，而后者也要<br>比 window.location.href.toString()更快。<br><strong>Caching Object Member Values 缓存对象成员的值</strong></p>\n<pre><code>function hasEitherClass(element, className1, className2){\n    return element.className == className1 || element.className == className2;\n}\n</code></pre><p>这段代码中element.className被访问了两次，而且在这个函数过程中它的值是不会变的。所以优化如下：</p>\n<pre><code>function hasEitherClass(element, className1, className2){\n    var currentClassName = element.className;\n    return currentClassName == className1 || currentClassName == className2;\n}\n</code></pre><blockquote>\n<p>一般来说，如果在同一个函数中你要多次读取同一个对象属性，最好将它存入一个局部变量。以局部变量替代属性，避免多余的属性查找带来性能开销。在处理嵌套对象成员时这点特别重要，它们会对运行速度产生难以置信的影响。</p>\n</blockquote>\n<h1 id=\"Summary-总结\"><a href=\"#Summary-总结\" class=\"headerlink\" title=\"Summary 总结\"></a>Summary 总结</h1><hr>\n<p>在JavaScript中，数据存储位置可以对代码整体性能产生重要影响。有四种数据访问类型：直接量，变量，数组项，对象成员。它们有不同的性能考虑。</p>\n<blockquote>\n<ul>\n<li>直接量和局部变量访问速度非常快，数组项和对象成员需要更长时间。</li>\n<li>局部变量比域外变量快，因为它位于作用域链的第一个对象中。变量在作用域链中的位置越深，访问所需的时间就越长。全局变量总是最慢的，因为它们总是位于作用域链的最后一环。</li>\n<li>避免使用 with 表达式， 因为它改变了运行期上下文的作用域链。 而且应当小心对待 try-catch 表达式的catch子句，因为它具有同样效果。</li>\n<li>嵌套对象成员会造成重大性能影响，尽量少用。</li>\n<li>一个属性或方法在原形链中的位置越深，访问它的速度就越慢。</li>\n<li>一般来说，你可以通过这种方法提高JavaScript代码的性能：将经常使用的对象成员，数组项，和域外变量存入局部变量中。然后，访问局部变量的速度会快于那些原始变量。</li>\n</ul>\n</blockquote>\n<hr>\n<p>通过使用这些策略，你可以极大地提高那些需要大量 JavaScript 代码的网页应用的实际性能。</p>\n","excerpt":"<h1 id=\"第二章-Data-Access-数据访问\"><a href=\"#第二章-Data-Access-数据访问\" class=\"headerlink\" title=\"第二章 Data Access 数据访问\"></a><strong>第二章 Data Access 数据访问</strong></h1><p>本文章结尾处有结论，不愿意看原理或者已经懂原理的可以直接看结论。</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a>","more":"</h2><p>　　经典计算机科学的一个问题是确定数据应当存放在什么地方， 以实现最佳的读写效率。数据存储的位置关系到访问的速度。在 JavaScript 中，有四种基本的数据访问位置：</p>\n<blockquote>\n<ul>\n<li>直接量： 包括字符串，数字，布尔值，对象，数组，函数，正则表达式，具有特殊意义的空值（null），以及未定义（undefined）。</li>\n<li>变量：用 var 关键字创建用于存储数据值。</li>\n<li>数组项：具有数字索引，存储一个 JavaScript 数组对象。</li>\n<li>对象成员：具有字符串索引，存储一个 JavaScript 对象。</li>\n</ul>\n</blockquote>\n<p>　　在一些老的浏览器中，直接量和局部变量的访问速度远远快于数组项和对象成员的访问速度（Firefox3 中优化过数组项，所以访问速度非常快）。**所以，如果关心运行速度，建议尽量使用直接量和局部变量，限制数组项和对象成员的使用。下图是对不同数据类型进行 200 000 次读操作所用的时间<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/高性能js-img2-1.png\" alt=\"对不同数据类型进行 200 000 次读操作所用的时间\"></p>\n<blockquote>\n<p>下面介绍几种模式来避免这种情况并优化你的代码。</p>\n</blockquote>\n<h1 id=\"一-Managing-Scope-管理作用域\"><a href=\"#一-Managing-Scope-管理作用域\" class=\"headerlink\" title=\"一.Managing Scope 管理作用域\"></a>一.Managing Scope 管理作用域</h1><hr>\n<p>　　无论是从性能还是功能考虑，作用域链都是理解JavaScript的关键。但是要理解速度与作用域的关系，首先要理解作用域的工作原理。<br><strong>1.Scope Chains and Identifier Resolution 作用域链和标识符解析</strong><br>在这里不详细叙述作用域的工作原理，只是简单的说明一下作用域链的工作过程。如果想看详细原理，请参看我的文章<a href=\"http://www.winnerweb.club/2015/07/31/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E6%A0%87%E8%AF%86%E7%AC%A6%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/\">作用域链和标识符详细解析</a>。<br>　　每一段 JavaScript 代码（全局代码或者函数）都有一个与之关联的作用域链(scope chain)。这个作用域链是一个对象链表，这组对象定义了这段代码“作用域中”的变量。当JavaScript需要查找变量x的值得时候（这个过程叫做变量解析），它会从链中的第一个对象(第一个对象是局部变量)开始查找，如果这个对象有一个名为x的属性，则会直接使用，若第二个对象依然没有，则会继续寻找下一个对象。以此类推，直至全局对象。若作用域链上没有任何一个对象含有属性x，那么就会返回一个undefined，在严格规范的ECMAScript 5中，会抛出一个异常。函数运行时每个标识符都要经过这样的搜索过程，正是这种搜索过程影响了性能。</p>\n<p><strong>Identifier Resolution Performance 标识符识别性能</strong><br>　　在运行期上下文中，一个标识符所处的位置越深，读写速度也就越慢，所以局部变量访问速度是最快的，全局变量位于作用域链的最后一个位置是最慢的。下图展示了不同深度标识符的读写速度。（第一个写，第二个是读）<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-2.png\" alt=\"写操作的标识符识别速度\"><br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-3.png\" alt=\"读操作的标识符识别速度\"><br>　　采用优化JavaScript引擎的浏览器，如Safari4，访问域外标识符时没有性能的损失。其它浏览器都有较大幅度的影响。早期的IE6和Firefox2，有着令人难以置信的陡峭斜坡，如果此图包含它们的数据，曲线高点将超出图表边界。</p>\n<blockquote>\n<p>所以，在没有优化JavaScript引擎的浏览器中，尽可能使用局部变量。用局部变量存储本地范围之外的变量值。如果在函数中多次使用，参考以下例子：</p>\n</blockquote>\n<pre><code>function initUI(){\n    var bd = document.body,\n    links = document.getElementsByTagName_r(&quot;a&quot;),\n    i = 0,\n    len = links.length;\n    while(i &lt; len){\n        update(links[i++]);\n    }\n    document.getElementById(&quot;go-btn&quot;).onclick = function(){\n        start();\n    };\n    bd.className = &quot;active&quot;;\n}\n</code></pre><p>　　次函数包含对document的引用，而document是全局变量。每次搜索此变量都要遍历整个作用域链。上述代码可以优化为：</p>\n<pre><code>function initUI(){\n    var doc = document,\n    bd = doc.body,\n    links = doc.getElementsByTagName_r(&quot;a&quot;),\n    i = 0,\n    len = links.length;\n    while(i &lt; len){\n        update(links[i++]);\n    }\n    doc.getElementById(&quot;go-btn&quot;).onclick = function(){\n        start();\n    };\n    bd.className = &quot;active&quot;;\n}\n</code></pre><p>　　这个简单的函数不会显示出巨大的改进，如果几十个全局变量被反复访问，那么这么做性能将有显著的提高。<br><strong>Scope Chain Augmentation 改变作用域链</strong><br>　　一般来说，一个运行期上下文的作用域链不会被改变。但是，有两种表达式可以在运行时临时改变运行期上下文作用域链。第一个是 with 表达式。第二种是try-catch。with 表达式为所有对象属性创建一个默认操作变量。在其他语言中，类似的功能通常用来避免书写一些<br>重复的代码。initUI()函数可以重写成如下样式：</p>\n<pre><code>function initUI(){\n    with (document){ //avoid!\n    var bd = body,\n    links = getElementsByTagName_r(&quot;a&quot;),\n    i = 0,\n    len = links.length;\n    while(i &lt; len){\n        update(links[i++]);\n    }\n    getElementById(&quot;go-btn&quot;).onclick = function(){\n        start();\n    };\n        bd.className = &quot;active&quot;;\n    }\n}\n</code></pre><p>　　<strong>此重写的 initUI()版本使用了一个with表达式，避免多次书写“document”。这看起来似乎更有效率，而实际上却产生了一个性能问题。</strong><br>当代码流执行到一个with表达式时，运行期上下文的作用域链被临时改变了。一个新的可变对象将被创建，它包含指定对象的所有属性。此对象被插入到作用域链的前端，意味着现在函数的所有局部变量都被推入第二个作用域链对象中，所以访问代价更高了，正因为这个原因，最好不要使用 with 表达式。正如前面提到的，只要简单地将 document 存储在一个<br>局部变量中，就可以获得性能上的提升。（见下图）。<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-4.png\" alt=\"with 表达式改变作用域链\">。<br>　　在 JavaScript 中不只是 with 表达式人为地改变运行期上下文的作用域链，try-catch 表达式的 catch 子句具有相同效果。当 try 块发生错误时，程序流程自动转入 catch 块，并将异常对象推入作用域链前端的一个可变对象中。在 catch 块中，函数的所有局部变量现在被放在第二个作用域链对象中。例如：</p>\n<pre><code>try {\n    methodThatMightCauseAnError();\n} catch (ex){\n    alert(ex.message); //scope chain is augmented here\n}\n</code></pre><p><strong>请注意，只要 catch 子句执行完毕，作用域链就会返回到原来的状态。</strong><br>　　如果使用得当， try-catch 表达式是非常有用的语句，所以不建议完全避免。 如果你计划使用一个 try-catch语句，请确保你了解可能发生的错误。一个 try-catch 语句不应该作为 JavaScript 错误的解决办法。如果你知道一个错误会经常发生，那说明应当修正代码本身的问题。<br>你可以通过精缩代码的办法最小化catch子句对性能的影响。一个很好的模式是将错误交给一个专用函数来处理。例子如下：</p>\n<pre><code>try {\n    methodThatMightCauseAnError();\n} catch (ex){\n    handleError(ex); //delegate to handler method\n}\n</code></pre><p>　　handleError()函数是 catch 子句中运行的唯一代码。此函数以适当方法自由地处理错误，并接收由错误产生的异常对象。由于只有一条语句，没有局部变量访问，作用域链临时改变就不会影响代码的性能。<br><strong>Dynamic Scopes 动态作用域</strong><br>　　无论是 with 表达式还是 try-catch 表达式的 catch 子句，以及包含()的函数，都被认为是动态作用域。一个动态作用域只因代码运行而存在，因此无法通过静态分析（察看代码结构）来确定（是否存在动态作用域）</p>\n<pre><code>function execute(code) {\n    (code);\n    function subroutine(){\n        return window;\n    }\n    var w = subroutine();\n    //what value is w?\n};\n</code></pre><p>　　execute()函数看上去像一个动态作用域，因为它使用了()。w 变量的值与 code 有关。大多数情况下，w将等价于全局的window对象，但是请考虑如下情况：</p>\n<pre><code>execute(&quot;var window = {};&quot;)\n</code></pre><p>　　这种情况下，()在 execute()函数中创建了一个局部window变量。所以w将等价于这个局部window变量而不是全局的那个。所以说，不运行这段代码是没有办法了解具体情况的，标识符 window 的确切含义不能预先确定。<br>　　优化的 JavaScript 引擎，例如 Safari 的 Nitro 引擎，企图通过分析代码来确定哪些变量应该在任意时刻被访问，来加快标识符识别过程。这些引擎企图避开传统作用域链查找，取代以标识符索引的方式进行快速查找。当涉及一个动态作用域后，此优化方法就不起作用了。引擎需要切回慢速的基于哈希表的标识符识别方法，更像传统的作用域链搜索。<br>　　正因为这个原因，只在绝对必要时才推荐使用动态作用域。<br><strong>Closures, Scope, and Memory 闭包，作用域，和内存</strong><br>　　闭包是 JavaScript 最强大的一个方面，它允许函数访问局部范围之外的数据。闭包的使用通过 Douglas<br>Crockford的著作流行起来，当今在最复杂的网页应用中无处不在。不过，有一种性能影响与闭包有关。<br>　　为了解与闭包有关的性能问题，考虑下面的例子：</p>\n<pre><code>function assignEvents(){\n    var id = &quot;xdi9592&quot;;\n    document.getElementById(&quot;save-btn&quot;).onclick = function(event){\n        saveDocument(id);\n    };\n}\n</code></pre><p>　　当 assignEvents()被执行时，一个激活对象被创建，并包含了一些应有的内容，其中包括 id变量。它将成为运行期上下文作用域链上的第一个对象，全局对象是第二个。当闭包创建时，[[Scope]]属性与这些对象一起被初始化（见下图）。<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-5.png\" alt=\"assignEvents()运行期上下文的作用域链和闭包\">。<br>　　由于闭包的[[Scope]]属性包含与运行期上下文作用域链相同的对象引用，会产生副作用。通常，一个函数的激活对象与运行期上下文一同销毁。当涉及闭包时，激活对象就无法销毁了，因为引用仍然存在于闭包的[[Scope]]属性中。这意味着脚本中的闭包与非闭包函数相比，需要更多内存开销。在大型网页应用中，<br>这可能是个问题，尤其在 Internet Explorer 中更被关注。IE 使用非本地 JavaScript 对象实现 DOM 对象，闭包可能导致内存泄露（更多信息参见第 3 章）。<br>　　当闭包被执行时，一个运行期上下文将被创建，它的作用域链与[[Scope]]中引用的两个相同的作用域链同时被初始化，然后一个新的激活对象为闭包自身被创建（参见下图）。<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-6.png\" alt=\"闭包运行\">。<br>　　注意闭包中使用的两个标识符，id 和 saveDocument，存在于作用域链第一个对象之后的位置上。这是闭包最主要的性能关注点：你经常访问一些范围之外的标识符，每次访问都导致一些性能损失。</p>\n<blockquote>\n<p>在脚本中最好是小心地使用闭包，内存和运行速度都值得被关注。但是，你可以通过本章早先讨论过的关于域外变量的处理建议，减轻对运行速度的影响：将常用的域外变量存入局部变量中，然后直接访问局部变量。</p>\n</blockquote>\n<p><strong>Prototypes 原形</strong><br>　　JavaScript中的对象是基于原形的。原形是其他对象的基础，定义并实现了一个新对象所必须具有的成员。这一概念完全不同于传统面向对象编程中“类”的概念，它定义了创建新对象的过程。原形对象为所有给定类型的对象实例所共享，因此所有实例共享原形对象的成员。<br>　　一个对象通过一个内部属性绑定到它的原形。Firefox，Safari，和 Chrome 向开发人员开放这一属性，称作<strong>proto</strong>其他浏览器不允许脚本访问这一属性。任何时候你创建一个内置类型的实例，如 Object 或 Array，这些实例自动拥有一个 Object 作为它们的原形。<br>　　因此，对象可以有两种类型的成员：实例成员（也称作“own”成员）和原形成员。实例成员直接存在于实例自身，而原形成员则从对象原形继承。考虑下面的例子：</p>\n<pre><code>var book = {\n    title: &quot;High Performance JavaScript&quot;,\n    publisher: &quot;Yahoo! Press&quot;\n};\nalert(book.toString()); //&quot;[object Object]&quot;\n</code></pre><p>此代码中，book 对象有两个实例成员：title 和 publisher。注意它并没有定义 toString()接口，但是这个接口却被调用了，也没有抛出错误。toString()函数就是一个 book 对象继承的原形成员。下图显示出它们之间的关系。<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-7.png\" alt=\"实例与原形的关系\">。<br>　　处理对象成员的过程与变量处理十分相似。当 book.toString()被调用时，对成员进行名为“toString”的搜索，首先从对象实例开始，如果 book 没有名为 toString 的成员，那么就转向搜索原形对象，在那里发现了toString()方法并执行它。通过这种方法，booke 可以访问它的原形所拥有的每个属性或方法。<br>　　你可以使用 hasOwnProperty()函数确定一个对象是否具有特定名称的实例成员，（它的参数就是成员名称）。要确定对象是否具有某个名称的属性，你可以使用操作符 in。例如：</p>\n<pre><code>var book = {\n    title: &quot;High Performance JavaScript&quot;,\n    publisher: &quot;Yahoo! Press&quot;\n};\nalert(book.hasOwnProperty(&quot;title&quot;)); //true\nalert(book.hasOwnProperty(&quot;toString&quot;)); //false\nalert(&quot;title&quot; in book); //true\nalert(&quot;toString&quot; in book); //true\n</code></pre><p>此代码中， hasOwnProperty()传入“title”时返回true， 因为title是一个实例成员。 传入“toString”时返回false，因为 toString 不在实例之中。如果使用 in 操作符检测这两个属性，那么返回都是 true，因为它既搜索实例又搜索原形。<br><strong>Prototype Chains 原形链</strong><br>对象的原形决定了一个实例的类型。默认情况下，所有对象都是 Object 的实例，并继承了所有基本方法，如 toString()。你可以用“构造器”创建另外一种类型的原形。例如：</p>\n<pre><code>function Book(title, publisher){\n    this.title = title;\n    this.publisher = publisher;\n}\nBook.prototype.sayTitle = function(){\n    alert(this.title);\n};\nvar book1 = new Book(&quot;High Performance JavaScript&quot;, &quot;Yahoo! Press&quot;);\nvar book2 = new Book(&quot;JavaScript: The Good Parts&quot;, &quot;Yahoo! Press&quot;);\nalert(book1 instanceof Book); //true\nalert(book1 instanceof Object); //true\nbook1.sayTitle(); //&quot;High Performance JavaScript&quot;\nalert(book1.toString()); //&quot;[object Object]&quot;\n</code></pre><p>原型链关系如下图：<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/高性能JavaScript-img2-8.png\" alt=\"原形链\"><br>　　注意，两个 Book 实例共享同一个原形链。每个实例拥有自己的 title 和 publisher 属性，但其他成员均继承自原形。当 book1.toString()被调用时，搜索工作必须深入原形链才能找到对象成员“toString”。正如你所<br>怀疑的那样，深入原形链越深，搜索的速度就会越慢。图2-11显示出成员在原形链中所处的深度与访问时间的关系。<br>　　虽然使用优化 JavaScript 引擎的新式浏览器在此任务中表现良好，但是老的浏览器，特别是 Internet Explorer 和 Firefox 3.5，每深入原形链一层都会增加性能损失。记住，搜索实例成员的过程比访问直接量<br>或者局部变量负担更重，所以增加遍历原形链的开销正好放大了这种效果。</p>\n<p><strong>Nested Members 嵌套成员</strong><br>由于对象成员可能包含其它成员， 例如不太常见的写法 window.location.href 这种模式每遇到一个点号，JavaScript 引擎就要在对象成员上执行一次解析过程。成员嵌套越深，访问速度越慢。location.href 总是快于 window.location.href，而后者也要<br>比 window.location.href.toString()更快。<br><strong>Caching Object Member Values 缓存对象成员的值</strong></p>\n<pre><code>function hasEitherClass(element, className1, className2){\n    return element.className == className1 || element.className == className2;\n}\n</code></pre><p>这段代码中element.className被访问了两次，而且在这个函数过程中它的值是不会变的。所以优化如下：</p>\n<pre><code>function hasEitherClass(element, className1, className2){\n    var currentClassName = element.className;\n    return currentClassName == className1 || currentClassName == className2;\n}\n</code></pre><blockquote>\n<p>一般来说，如果在同一个函数中你要多次读取同一个对象属性，最好将它存入一个局部变量。以局部变量替代属性，避免多余的属性查找带来性能开销。在处理嵌套对象成员时这点特别重要，它们会对运行速度产生难以置信的影响。</p>\n</blockquote>\n<h1 id=\"Summary-总结\"><a href=\"#Summary-总结\" class=\"headerlink\" title=\"Summary 总结\"></a>Summary 总结</h1><hr>\n<p>在JavaScript中，数据存储位置可以对代码整体性能产生重要影响。有四种数据访问类型：直接量，变量，数组项，对象成员。它们有不同的性能考虑。</p>\n<blockquote>\n<ul>\n<li>直接量和局部变量访问速度非常快，数组项和对象成员需要更长时间。</li>\n<li>局部变量比域外变量快，因为它位于作用域链的第一个对象中。变量在作用域链中的位置越深，访问所需的时间就越长。全局变量总是最慢的，因为它们总是位于作用域链的最后一环。</li>\n<li>避免使用 with 表达式， 因为它改变了运行期上下文的作用域链。 而且应当小心对待 try-catch 表达式的catch子句，因为它具有同样效果。</li>\n<li>嵌套对象成员会造成重大性能影响，尽量少用。</li>\n<li>一个属性或方法在原形链中的位置越深，访问它的速度就越慢。</li>\n<li>一般来说，你可以通过这种方法提高JavaScript代码的性能：将经常使用的对象成员，数组项，和域外变量存入局部变量中。然后，访问局部变量的速度会快于那些原始变量。</li>\n</ul>\n</blockquote>\n<hr>\n<p>通过使用这些策略，你可以极大地提高那些需要大量 JavaScript 代码的网页应用的实际性能。</p>"},{"title":"JavaScript加载和运行的优化","date":"2015-07-29T09:28:18.000Z","_content":"**第一章 Loading and Execution 加载和运行**\n===\n本文章结尾处有结论，不愿意看原理或者已经懂原理的可以直接看结论。\n<!--more-->\n---\n一.Script Positioning 脚本位置\n===\n---\n　　JavaScript在浏览器中的性能，是开发者所要面对的最重要的可用性问题。这个问题因JavaScript的阻塞特征而复杂，也就是说，当JavaScript运行时其他的事情不能被浏览器处理。事实上，大多数浏览器使用单进程处理UI更新和JavaScript运行等多个任务，而同一时间只能有一个任务被执行。JavaScript运行了多长时间，那么在浏览器空闲下来响应用户输入之前的等待时间就有多长。\n　　从基本层面说，这意味着< script>标签的出现使整个页面因脚本解析、运行而出现等待。不论实际的JavaScript代码是内联的还是包含在一个不相干的外部文件中，页面下载和解析过程必须停下，等待脚本完成这些处理，然后才能继续。这是页面生命周期必不可少的部分，因为脚本可能在运行过程中修改页面内容。典型的例子是 document.write()函数，例如：\n\n\t<html>\n\t<head>\n\t<title>Script Example</title>\n\t</head>\n\t<body>\n\t\t<p>\n\t\t\t<script type=\"text/javascript\">\n\t\t\t\tdocument.write(\"The date is \" + (new Date()).toDateString());\n\t\t\t</script>\n\t\t</p>\n\t</body>\n\t</html>\n\n　　当浏览器遇到一个< script>标签时，正如上面代码中一样，无法预知JavaScript是否在< p>标签中添加内容，所以浏览器要停下来，先运行JavaScript代码，再继续解析和翻译下面的页面。 在使用src属性加载JavaScript的过程中也会出现这样的问题。浏览器必须先下载外部的代码，占用一段时间，然后解析并运行这段代码。在这个过程中，后续的页面解析和用户交互式完全被阻塞的。\nHTML4文档中指出，一个< script>标签可以放在HTML文档的< head>或< body>中，可以在其中多次出现。传统上，< script>标签用于加载外部的JavaScript文件。< head>部分除了此类代码还包含< link>标签用于加载CSS文件和其他页面的中间件。也就是说，最好把行为所依赖的部分放在一起，首先加载它们，使得页面可以得到正确的外观和行为。如下列代码：\n\t\n\t<head>\n\t<title>Script Example</title>\n\t\t<-- Example of inefficient script positioning -->\n\t\t<script type=\"text/javascript\" src=\"file1.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"file2.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"file3.js\"></script>\n\t\t<link rel=\"stylesheet\" type=\"text/css\" href=\"styles.css\">\n\t</head>\n\t<body>\n\t\t<p>Hello world!</p>\n\t</body>\n\t</html>\n\n　　但是在浏览器遇到< body>标签前，不会渲染页面的任何成分，所以这种方式也许会让用户等待在空白的界面很久。下面这个图，说明了加载的整个过程。\n![GitHub Mark](http://7xkj1z.com1.z0.glb.clouddn.com/高性能js-img1.png \"GitHub Mark\")\n　　从图中可以看出，第一个JavaScript文件开始下载，并阻塞了其他文件的下载过程。在file1.js下载完之后和file2.js开始下载中之前还会有一个延迟，这个延迟是file1.js完全运行所花费的时间。每个文件必须等到前一个文件下载并运行完毕才能开始自己的下载过程。而当这些文件下载时，用户面对的就是一个空白的屏幕。这就是当今大多数浏览器的行为模式。\n　　IE8，Firefox 3.5，Safari 4，和Chrome2允许并行下载两个JavaScript文件。这样当一个< script>标签在下载时就不会阻塞其它的< script>标签了。但是依然会阻塞其它资源的下载，比如图片。而且，就算脚本直接下载不会互相阻塞，但是页面还是要等在所有的JavaScript代码下载并执行完毕后才能继续。所以，脚本阻塞依旧是问题。\n>因为脚本阻塞其它页面的资源下载，所以推荐的办法是：将所有的< script>标签尽可能的接近< body>标签的底部位置，尽量减少对整个页面加载的影响。如：\n\n\t<html>\n\t<head>\n\t<title>Script Example</title>\n\t\t<link rel=\"stylesheet\" type=\"text/css\" href=\"styles.css\">\n\t</head>\n\t<body>\n\t\t<p>Hello world!</p>\n\t\t<-- Example of recommended script positioning -->\n\t\t<script type=\"text/javascript\" src=\"file1.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"file2.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"file3.js\"></script>\n\t</body>\n\t</html>\n>**这正是“Yahoo! 优越性能小组”关于JavaScript 的第一条定律：*将脚本放在底部*。**\n\n二.Grouping Scripts  成组脚本\n===\n---\n　　因为每个< script>标签下载时都会阻塞页面解析过程，所以限制页面的< script>标签总数也可以改善性能（内联脚本和外联脚本都适用）。每个HTTP请求都会产生额外的性能负担，下载一个 100KB 的文件比下载四个 25KB 的文件要快。所以尽量减少外部脚本的数量。这一系列的工作可通过一个打包工具实现（在第9章有介绍），或者一个实时工具，诸如“[Yahoo! combo handler](http://yui.yahooapis.com/combo?2.7.0/build/yahoo/yahoo-min.js&2.7.0/build/event/event-min.js)”。\nYahoo!适用一个“联合语把柄”来解决这个问题，例如，下面的 URL 包含两个文件：\nhttp://yui.yahooapis.com/combo?2.7.0/build/yahoo/yahoo-min.js&2.7.0/build/event/event-min.js\n　　这个URL调用了2.7.0版本的 yahoo-min.js 和 event-min.js 文件。这些文件在服务器上是两个分离的文件，但是当服务器收到此URL请求时，两个文件就会被合并在一起返回给客户。这样一个< script>标签就可以加载它们：\n\n\t<html>\n\t<head>\n\t<title>Script Example</title>\n\t\t<link rel=\"stylesheet\" type=\"text/css\" href=\"styles.css\">\n\t</head>\n\t<body>\n\t<p>Hello world!</p>\n\t\t<-- Example of recommended script positioning -->\n\t\t<script type=\"text/javascript\"\n\t\t\tsrc=\"http://yui.yahooapis.com/combo?2.7.0/build/yahoo/yahoo-min.js&2.7.0/build/event/event-min.js\">\n\t\t</script>\n\t</body>\n\t</html>\n>这是在HTML页面中包含多个外部JavaScript的最佳方法。\n\n三.Nonblocking Scripts 非阻塞脚本\n===\n---\n　　JavaScript 倾向于阻塞浏览器某些处理过程，如 HTTP请求和界面刷新，这是开发者面临的最显著的性能问题。保持JavaScript文件短小，并限制 HTTP 请求的数量，只是创建反应迅速的网页应用的第一步。一个应用程序所包含的功能越多，所需要的 JavaScript 代码就越大，保持源码短小并不总是一种选择。尽管下载一个大JavaScript文件只产生一次HTTP请求，却会锁定浏览器一大段时间。为避开这种情况，你需要向页面中逐步添加 JavaScript，某种程度上说不会阻塞浏览器。\n非阻塞脚本的秘密在于，等页面完成加载之后，再加载 JavaScript 源码。从技术角度讲，这意味着在window 的 load 事件发出之后开始下载代码。有几种方法可以实现这种效果。\n**1.Deferred Scripts 延期脚本**\n　　HTML4中定义的defer属性就表明了这段脚本不会修改DOM，所以代码可以稍后执行。defer只被IE4和Firefox 3.5及以上版本支持，它并不是一个理想的跨浏览器解决方案。如果浏览器支持，这种方法是一种很有用的解决方案：\n\n\t<script type=\"text/javascript\" src=\"file1.js\" defer></script>\nJavaScript文件将在< script>标签被解析时启动下载，但是不会执行，知道DOM加载完成（onlaod事件被调用之前）。这样当一个defer的JavaScript文件被下载时，不会阻塞浏览器的其他处理过程，即其它资源也可以一起并行下载。\n\n\t<html>\n\t<head>\n\t<title>Script Defer Example</title>\n\t</head>\n\t<body>\n\t\t<script defer>\n\t\t\talert(\"defer\");\n\t\t</script>\n\t\t<script>\n\t\t\talert(\"script\");\n\t\t</script>\n\t\t<script>\n\t\t\twindow.onload = function(){\n\t\t\t\talert(\"load\");\n\t\t\t};\n\t\t</script>\n\t</body>\n\t</html>\n　　以上代码阐述了defer的执行过程，如果浏览器不支持defer那么这段程序将按顺序执行，即defer、script、load。如果浏览器支持defer属性，弹出框的顺序为：script、defer、load。这里有一点需要注意：\n> **defer的< script>标签不是跟在第二个后面运行，而是在onload事件语句之前被调用**\n\n　　如果你的目标浏览器只包括 IE 和 Firefox 3.5，那么 defer 脚本确实有用。如果你需要支持跨领域的多种浏览器，那么还有更一致的实现方式\n**2.Dynamic Script Elements 动态脚本元素**\nDOM可以用JavaScript动态创建HTML的几乎所有文档内容，就是因为< script>标签与页面其它的标签没有什么不同：引用变量可以通过DOM进行检索，可以从文档中移动、删除和创建。一个新的< script>标签很容易被标准的DOM函数创建。\n\n\tvar script = document.createElement (\"script\");\n\tscript.type = \"text/javascript\";\n\tscript.src = \"file1.js\";\n\tdocument.getElementsByTagName_r(\"head\")[0].appendChild(script);\n　　而这个被创建的标签加载file1.js源文件。这个文件在元素添加到页面之后立刻开始下载。此技术的重点在于：无论在何处启动下载，文件的下载和运行都不会阻塞其它的页面处理过程。你甚至可以将这些代码放在< head>部分而不会对其余部分的页面代码造成影响（除了用于下载文件的HTTP链接）。\n当文件使用动态脚本节点下载时，返回的代码通常立即执行（除了 Firefox 和 Opera，他们将等待此前的所有动态脚本节点执行完毕）。当脚本是“自运行”类型时这一机制运行正常，但是如果脚本只包含供页面其他脚本调用调用的接口，则会带来问题。这种情况下，你需要跟踪脚本下载完成并准备妥善的情况。可以使用动态< script>节点发出事件得到相关信息。Firefox, Opera, Chorme 和 Safari 3+会在< script>节点接收完成之后发出一个load事件。你可以监听这一事件，以得到脚本准备好的通知：\n\n\tvar script = document.createElement (\"script\")\n\tscript.type = \"text/javascript\";\n\t//Firefox, Opera, Chrome, Safari 3+\n\tscript.onload = function(){\n\talert(\"Script loaded!\");\n\t};\n\tscript.src = \"file1.js\";\n\tdocument.getElementsByTagName_r(\"head\")[0].appendChild(script);\n　　IE中支持另一种实现方式，它发出一个readystatechange事件，< script>标签有一个readyState属性，它的值随着下载外部文件的过程而改变。readyState有五种取值：\n\n\t\"uninitialized\" The default state 默认状态\n\t\"loading\" Download has begun 下载开始\n\t\"loaded\" Download has completed 下载完成\n\t\"interactive\" Data is completely downloaded but isn't fully available 下载完成但尚不可用\n\t\"complete\" All data is ready to be used 所有数据已经准备好\n　　微软的文档说，在一个生命周期中这些值并不一定都会出现，但并没有说哪些不会。在实践中，我们最有用的是\"loaded\"和\"complete\",而这两个属性值也不是全会出现，有时有\"loade\"而不出现\"complete\"，有时反之。所以最安全的办法就是在readystatachange事件中检查这两个状态，且当一种状态出现时删除readystatachange事件句柄（保证不被处理两次）;\n\n\tvar script = document.createElement (\"script\")\n\tscript.type = \"text/javascript\";\n\t//Internet Explorer\n\tscript.onreadystatechange = function(){\n\tif (script.readyState == \"loaded\" || script.readyState == \"complete\"){\n\t\tscript.onreadystatechange = null;\n\t\talert(\"Script loaded.\");\n\t}\n\t};\n\tscript.src = \"file1.js\";\n\tdocument.getElementsByTagName_r(\"head\")[0].appendChild(script);\n>下面总结上面所说，写一个兼容性的实现JavaScript的动态加载。\n\n\tfunction loadScript(url, callback){\n\tvar script = document.createElement (\"script\")\n\tscript.type = \"text/javascript\";\n\tif (script.readyState){ //IE\n\t\tscript.onreadystatechange = function(){\n\t\t\tif (script.readyState == \"loaded\" || script.readyState == \"complete\"){\n\t\t\t\tscript.onreadystatechange = null;\n\t\t\t\tcallback();\n\t\t\t}\n\t\t};\n\t} else { //Others\n\t\tscript.onload = function(){\n\t\t\tcallback();\n\t\t};\n\t}\n\t\tscript.src = url;\n\t\tdocument.getElementsByTagName_r(\"head\")[0].appendChild(script);\n\t}\n　　此函数传入两个参数：JavaScript文件的URL，和一个JavaScript接收完成的回调函数。此函数的使用方法如下：\n\n\tloadScript(\"file1.js\", function(){\n\t\talert(\"File is loaded!\");\n\t});\n　　当多个JavaScript文件同时加载时，除了Firefox和Opera能保证按顺序加载，其它浏览器都不能。所以可以利用回调函数来控制顺序：\n\n\tloadScript(\"file1.js\", function(){\n\t\tloadScript(\"file2.js\", function(){\n\t\t\tloadScript(\"file3.js\", function(){\n\t\t\t\talert(\"All files are loaded!\");\n\t\t\t});\n\t\t});\n\t});\n\n　　如果多个文件的次序十分重要，更好的办法是将这些文件按照正确的次序连接成一个文件。独立文件可以一次性下载所有代码（由于这是异步进行的，使用一个大文件并没有什么损失）。\n>动态脚本加载是非阻塞 JavaScript 下载中最常用的模式，因为它可以跨浏览器，而且简单易用。\n\n**3.XMLHttpRequest Script Injection XHR**\n　　还有一种非阻塞方式获得脚本的方法是XMLHttpRequst(XHR)对象将脚本注入页面中。\n\n\tvar xhr = new XMLHttpRequest();\n\txhr.open(\"get\", \"file1.js\", true);\n\txhr.onreadystatechange = function(){\n\t\tif (xhr.readyState == 4){\n\t\t\tif (xhr.status >= 200 && xhr.status < 300 || xhr.status == 304){\n\t\t\t\tvar script = document.createElement (\"script\");\n\t\t\t\tscript.type = \"text/javascript\";\n\t\t\t\tscript.text = xhr.responseText;\n\t\t\t\tdocument.body.appendChild(script);\n\t\t\t}\n\t\t}\n\t};\n\txhr.send(null);\n\n　　这段代码向服务器发送一个获取文件file1.js的get请求。然后检测readyState是不是4，再继续检测TTTP状态码status（200表示有效回应，304是缓存响应），如果是有效相应就新建一个< script>元素，将其文本属性设置为返回响应的responseText字符串。\n> + 这种方法的主要优点是， 你可以下载不立即执行的 JavaScript 代码。由于代码返回在< script>标签之外（换句话说不受< script>标签约束），它下载后不会自动执行，这使得你可以推迟执行，直到一切都准备好了。另一个优点是，同样的代码在所有现代浏览器中都不会引发异常。\n> + 此方法最主要的限制是：JavaScript 文件必须与页面放置在同一个域内。正因为这个原因，大型网页通常不采用XHR脚本注入技术。\n\n**4.Recommended Nonblocking Pattern 推荐的非阻塞模式**\n>推荐的向页面加载大量 JavaScript 的方法分为两个步骤：第一步，包含动态加载 JavaScript 所需的代码，然后加载页面初始化所需的除 JavaScript 之外的部分。这部分代码尽量小，可能只包含loadScript()函数，它下载和运行非常迅速，不会对页面造成很大干扰。当初始代码准备好之后，用它来加载其余的 JavaScript。例如：\n\n\t<script type=\"text/javascript\" src=\"loader.js\"></script>\n\t<script type=\"text/javascript\">\n\t\tloadScript(\"the-rest.js\", function(){\n\t\t\tApplication.init();\n\t\t});\n\t</script>\n　　将这段代码放到< /body>标签之前。首先，这样可以确保JavaScript运行不会影响页面其它部分显示。其次，当第二部分 JavaScript 文件完成下载，所有应用程序所必须的 DOM 已经创建好了，并做好被访问的准备，避免使用额外的事件处理（例如 window.onload）来得知页面是否已经准备好了。\n>也可以直接将loadScript函数嵌入在页面中，来避免另一次HTTP请求。\n\n　　如果你决定使用这种方法，建议你使用“YUI Compressor”(参见第 9 章)或者类似的工具将初始化脚本缩小到最小字节尺寸。一旦页面初始化代码下载完成，你还可以使用loadScript()函数加载页面所需的额外功能函数。\n\n**The YUI3 approach**\n　　YUI 3 的核心设计理念为：用一个很小的初始代码，下载其余的功能代码。要在页面上使用YUI 3，首先包含 YUI 的种子文件.\n\n\t<script type=\"text/javascript\"\n\tsrc=http://yui.yahooapis.com/combo?3.0.0/build/yui/yui-min.js></script>\n　　此种子文件大约 10KB（gzipped 压缩后 6KB）包含从 Yahoo! CDN 下载 YUI 组件所需的足够功能。举例来说，如果你想使用DOM功能，你可以指出它的名字（\"dom\"），传递给 YUI 的 use()函数，再提供一个回调函数，当代码准备好时这个回调函数将被调用\n\n\tYUI().use(\"dom\", function(Y){\n\t\tY.DOM.addClass(docment.body, \"loaded\");\n\t})\n**The LazyLoad library**\n　　作为一个更通用的工具，Yahoo! Search 的 Ryan Grove 创建了 LazyLoad 库（参见 http://github.com/rgrove/lazyload/）。LazyLoad 是一个更强大的 loadScript()函数。LazyLoad 精缩之后只有大约 1.5KB（精缩，而不是用 gzip 压缩的）。lazyLoad可以下载多个JavaScript文件，并且能保证执行顺序，只需要LazyLoad.js()函数传递一个URL队列给它。但是仍应该尽可能的减少文件的数量。每次下载都是一个单独的HTTP请求。\n**The LABjs library**\n　　另一个非阻塞 JavaScript 加载库是 LABjs（http://labjs.com/），Kyle Simpson 写的一个开源库，由 Steve Souders 赞助。此库对加载过程进行更精细的控制，并尝试并行下载尽可能多的代码。LABjs 也相当小，只有 4.50KB（精缩，而不是用 gzip 压缩的），所以具有最小的页面代码尺寸。用法举例：\n\n\t<script type=\"text/javascript\" src=\"lab.js\"></script>\n\t<script type=\"text/javascript\">\n\t\t$LAB.script(\"the-rest.js\")\n\t\t\t.wait(function(){\n\t\t\tApplication.init();\n\t\t});\n\t</script>\n　　$LAB.script()函数用于下载一个 JavaScript 文件，$LAB.wait()函数用于指出一个函数，该函数等待文件下载完成并运行之后才会被调用。LABjs 鼓励链操作，每个函数返回一个指向$LAB 对象的引用。要下载多个 JavaScript 文件，那么就链入另一个$LAB.script()调用\n\n\t<script type=\"text/javascript\" src=\"lab.js\"></script>\n\t<script type=\"text/javascript\">\n\t\t$LAB.script(\"first-file.js\")\n\t\t\t.script(\"the-rest.js\")\n\t\t\t.wait(function(){\n\t\t\t\tApplication.init();\n\t\t\t});\n\t</script>\n\n　　LABjs 通过 wait()函数允许你指定哪些文件应该等待其他文件。在前面的例子中，first-file.js 的代码不保证在 the-rest.js 之前运行。为保证这一点，你必须在第一个 script()函数之后添加一个 wait()调用：\n\n\t<script type=\"text/javascript\" src=\"lab.js\"></script>\n\t<script type=\"text/javascript\">\n\t\t$LAB.script(\"first-file.js\").wait()\n\t\t\t.script(\"the-rest.js\")\n\t\t\t.wait(function(){\n\t\t\t\tApplication.init();\n\t\t\t});\n\t</script>\n　　现在，first-file.js 的代码保证会在 the-rest.js 之前执行，虽然两个文件的内容是并行下载的。\n\n**总结：**\n===\n---\n　　JavaScript代码的执行会阻塞其它浏览器的处理过程，比如界面的绘制等。只要遇到< script>标签，页面就必须要等待JavaScript代码的下载（如果是外部的）和执行。这样会影响性能，可能会让浏览者对着空白的浏览器等待很久。通过这一章的学习，可以总结出集中减少JavaScript对性能的影响：\n\n> - 1.将所有的< script>标签尽量放在页面底部，也就是< /body>之前。这样可以保证页面在脚本运行前完成解析。\n> - 2.将脚本成组打包。< script>标签的数量越少，页面加载速度也就越快，响应也会加速（外部脚本和内联代码都适用）。\n> - 3.用几种非阻塞方式下载JavaScript：\n>> - < script>标签加入defer(IE 及 Firefox3.5以上版本)。\n>> - 用 DOM 动态创建< script>元素，用它下载并执行代码。\n>> - 用 XHR 对象来下载代码，并注入页面中（需要同源）。\n\n---\n** *通过使用上述策略，你可以极大提高那些大量使用 JavaScript 代码的网页应用的实际性能。* **","source":"_posts/高性能JavaScript1.md","raw":"title: JavaScript加载和运行的优化\ndate: 2015-07-29 17:28:18\ntags: 高性能JavaScript学习笔记\ncategories: 高性能JavaScript-1\n---\n**第一章 Loading and Execution 加载和运行**\n===\n本文章结尾处有结论，不愿意看原理或者已经懂原理的可以直接看结论。\n<!--more-->\n---\n一.Script Positioning 脚本位置\n===\n---\n　　JavaScript在浏览器中的性能，是开发者所要面对的最重要的可用性问题。这个问题因JavaScript的阻塞特征而复杂，也就是说，当JavaScript运行时其他的事情不能被浏览器处理。事实上，大多数浏览器使用单进程处理UI更新和JavaScript运行等多个任务，而同一时间只能有一个任务被执行。JavaScript运行了多长时间，那么在浏览器空闲下来响应用户输入之前的等待时间就有多长。\n　　从基本层面说，这意味着< script>标签的出现使整个页面因脚本解析、运行而出现等待。不论实际的JavaScript代码是内联的还是包含在一个不相干的外部文件中，页面下载和解析过程必须停下，等待脚本完成这些处理，然后才能继续。这是页面生命周期必不可少的部分，因为脚本可能在运行过程中修改页面内容。典型的例子是 document.write()函数，例如：\n\n\t<html>\n\t<head>\n\t<title>Script Example</title>\n\t</head>\n\t<body>\n\t\t<p>\n\t\t\t<script type=\"text/javascript\">\n\t\t\t\tdocument.write(\"The date is \" + (new Date()).toDateString());\n\t\t\t</script>\n\t\t</p>\n\t</body>\n\t</html>\n\n　　当浏览器遇到一个< script>标签时，正如上面代码中一样，无法预知JavaScript是否在< p>标签中添加内容，所以浏览器要停下来，先运行JavaScript代码，再继续解析和翻译下面的页面。 在使用src属性加载JavaScript的过程中也会出现这样的问题。浏览器必须先下载外部的代码，占用一段时间，然后解析并运行这段代码。在这个过程中，后续的页面解析和用户交互式完全被阻塞的。\nHTML4文档中指出，一个< script>标签可以放在HTML文档的< head>或< body>中，可以在其中多次出现。传统上，< script>标签用于加载外部的JavaScript文件。< head>部分除了此类代码还包含< link>标签用于加载CSS文件和其他页面的中间件。也就是说，最好把行为所依赖的部分放在一起，首先加载它们，使得页面可以得到正确的外观和行为。如下列代码：\n\t\n\t<head>\n\t<title>Script Example</title>\n\t\t<-- Example of inefficient script positioning -->\n\t\t<script type=\"text/javascript\" src=\"file1.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"file2.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"file3.js\"></script>\n\t\t<link rel=\"stylesheet\" type=\"text/css\" href=\"styles.css\">\n\t</head>\n\t<body>\n\t\t<p>Hello world!</p>\n\t</body>\n\t</html>\n\n　　但是在浏览器遇到< body>标签前，不会渲染页面的任何成分，所以这种方式也许会让用户等待在空白的界面很久。下面这个图，说明了加载的整个过程。\n![GitHub Mark](http://7xkj1z.com1.z0.glb.clouddn.com/高性能js-img1.png \"GitHub Mark\")\n　　从图中可以看出，第一个JavaScript文件开始下载，并阻塞了其他文件的下载过程。在file1.js下载完之后和file2.js开始下载中之前还会有一个延迟，这个延迟是file1.js完全运行所花费的时间。每个文件必须等到前一个文件下载并运行完毕才能开始自己的下载过程。而当这些文件下载时，用户面对的就是一个空白的屏幕。这就是当今大多数浏览器的行为模式。\n　　IE8，Firefox 3.5，Safari 4，和Chrome2允许并行下载两个JavaScript文件。这样当一个< script>标签在下载时就不会阻塞其它的< script>标签了。但是依然会阻塞其它资源的下载，比如图片。而且，就算脚本直接下载不会互相阻塞，但是页面还是要等在所有的JavaScript代码下载并执行完毕后才能继续。所以，脚本阻塞依旧是问题。\n>因为脚本阻塞其它页面的资源下载，所以推荐的办法是：将所有的< script>标签尽可能的接近< body>标签的底部位置，尽量减少对整个页面加载的影响。如：\n\n\t<html>\n\t<head>\n\t<title>Script Example</title>\n\t\t<link rel=\"stylesheet\" type=\"text/css\" href=\"styles.css\">\n\t</head>\n\t<body>\n\t\t<p>Hello world!</p>\n\t\t<-- Example of recommended script positioning -->\n\t\t<script type=\"text/javascript\" src=\"file1.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"file2.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"file3.js\"></script>\n\t</body>\n\t</html>\n>**这正是“Yahoo! 优越性能小组”关于JavaScript 的第一条定律：*将脚本放在底部*。**\n\n二.Grouping Scripts  成组脚本\n===\n---\n　　因为每个< script>标签下载时都会阻塞页面解析过程，所以限制页面的< script>标签总数也可以改善性能（内联脚本和外联脚本都适用）。每个HTTP请求都会产生额外的性能负担，下载一个 100KB 的文件比下载四个 25KB 的文件要快。所以尽量减少外部脚本的数量。这一系列的工作可通过一个打包工具实现（在第9章有介绍），或者一个实时工具，诸如“[Yahoo! combo handler](http://yui.yahooapis.com/combo?2.7.0/build/yahoo/yahoo-min.js&2.7.0/build/event/event-min.js)”。\nYahoo!适用一个“联合语把柄”来解决这个问题，例如，下面的 URL 包含两个文件：\nhttp://yui.yahooapis.com/combo?2.7.0/build/yahoo/yahoo-min.js&2.7.0/build/event/event-min.js\n　　这个URL调用了2.7.0版本的 yahoo-min.js 和 event-min.js 文件。这些文件在服务器上是两个分离的文件，但是当服务器收到此URL请求时，两个文件就会被合并在一起返回给客户。这样一个< script>标签就可以加载它们：\n\n\t<html>\n\t<head>\n\t<title>Script Example</title>\n\t\t<link rel=\"stylesheet\" type=\"text/css\" href=\"styles.css\">\n\t</head>\n\t<body>\n\t<p>Hello world!</p>\n\t\t<-- Example of recommended script positioning -->\n\t\t<script type=\"text/javascript\"\n\t\t\tsrc=\"http://yui.yahooapis.com/combo?2.7.0/build/yahoo/yahoo-min.js&2.7.0/build/event/event-min.js\">\n\t\t</script>\n\t</body>\n\t</html>\n>这是在HTML页面中包含多个外部JavaScript的最佳方法。\n\n三.Nonblocking Scripts 非阻塞脚本\n===\n---\n　　JavaScript 倾向于阻塞浏览器某些处理过程，如 HTTP请求和界面刷新，这是开发者面临的最显著的性能问题。保持JavaScript文件短小，并限制 HTTP 请求的数量，只是创建反应迅速的网页应用的第一步。一个应用程序所包含的功能越多，所需要的 JavaScript 代码就越大，保持源码短小并不总是一种选择。尽管下载一个大JavaScript文件只产生一次HTTP请求，却会锁定浏览器一大段时间。为避开这种情况，你需要向页面中逐步添加 JavaScript，某种程度上说不会阻塞浏览器。\n非阻塞脚本的秘密在于，等页面完成加载之后，再加载 JavaScript 源码。从技术角度讲，这意味着在window 的 load 事件发出之后开始下载代码。有几种方法可以实现这种效果。\n**1.Deferred Scripts 延期脚本**\n　　HTML4中定义的defer属性就表明了这段脚本不会修改DOM，所以代码可以稍后执行。defer只被IE4和Firefox 3.5及以上版本支持，它并不是一个理想的跨浏览器解决方案。如果浏览器支持，这种方法是一种很有用的解决方案：\n\n\t<script type=\"text/javascript\" src=\"file1.js\" defer></script>\nJavaScript文件将在< script>标签被解析时启动下载，但是不会执行，知道DOM加载完成（onlaod事件被调用之前）。这样当一个defer的JavaScript文件被下载时，不会阻塞浏览器的其他处理过程，即其它资源也可以一起并行下载。\n\n\t<html>\n\t<head>\n\t<title>Script Defer Example</title>\n\t</head>\n\t<body>\n\t\t<script defer>\n\t\t\talert(\"defer\");\n\t\t</script>\n\t\t<script>\n\t\t\talert(\"script\");\n\t\t</script>\n\t\t<script>\n\t\t\twindow.onload = function(){\n\t\t\t\talert(\"load\");\n\t\t\t};\n\t\t</script>\n\t</body>\n\t</html>\n　　以上代码阐述了defer的执行过程，如果浏览器不支持defer那么这段程序将按顺序执行，即defer、script、load。如果浏览器支持defer属性，弹出框的顺序为：script、defer、load。这里有一点需要注意：\n> **defer的< script>标签不是跟在第二个后面运行，而是在onload事件语句之前被调用**\n\n　　如果你的目标浏览器只包括 IE 和 Firefox 3.5，那么 defer 脚本确实有用。如果你需要支持跨领域的多种浏览器，那么还有更一致的实现方式\n**2.Dynamic Script Elements 动态脚本元素**\nDOM可以用JavaScript动态创建HTML的几乎所有文档内容，就是因为< script>标签与页面其它的标签没有什么不同：引用变量可以通过DOM进行检索，可以从文档中移动、删除和创建。一个新的< script>标签很容易被标准的DOM函数创建。\n\n\tvar script = document.createElement (\"script\");\n\tscript.type = \"text/javascript\";\n\tscript.src = \"file1.js\";\n\tdocument.getElementsByTagName_r(\"head\")[0].appendChild(script);\n　　而这个被创建的标签加载file1.js源文件。这个文件在元素添加到页面之后立刻开始下载。此技术的重点在于：无论在何处启动下载，文件的下载和运行都不会阻塞其它的页面处理过程。你甚至可以将这些代码放在< head>部分而不会对其余部分的页面代码造成影响（除了用于下载文件的HTTP链接）。\n当文件使用动态脚本节点下载时，返回的代码通常立即执行（除了 Firefox 和 Opera，他们将等待此前的所有动态脚本节点执行完毕）。当脚本是“自运行”类型时这一机制运行正常，但是如果脚本只包含供页面其他脚本调用调用的接口，则会带来问题。这种情况下，你需要跟踪脚本下载完成并准备妥善的情况。可以使用动态< script>节点发出事件得到相关信息。Firefox, Opera, Chorme 和 Safari 3+会在< script>节点接收完成之后发出一个load事件。你可以监听这一事件，以得到脚本准备好的通知：\n\n\tvar script = document.createElement (\"script\")\n\tscript.type = \"text/javascript\";\n\t//Firefox, Opera, Chrome, Safari 3+\n\tscript.onload = function(){\n\talert(\"Script loaded!\");\n\t};\n\tscript.src = \"file1.js\";\n\tdocument.getElementsByTagName_r(\"head\")[0].appendChild(script);\n　　IE中支持另一种实现方式，它发出一个readystatechange事件，< script>标签有一个readyState属性，它的值随着下载外部文件的过程而改变。readyState有五种取值：\n\n\t\"uninitialized\" The default state 默认状态\n\t\"loading\" Download has begun 下载开始\n\t\"loaded\" Download has completed 下载完成\n\t\"interactive\" Data is completely downloaded but isn't fully available 下载完成但尚不可用\n\t\"complete\" All data is ready to be used 所有数据已经准备好\n　　微软的文档说，在一个生命周期中这些值并不一定都会出现，但并没有说哪些不会。在实践中，我们最有用的是\"loaded\"和\"complete\",而这两个属性值也不是全会出现，有时有\"loade\"而不出现\"complete\"，有时反之。所以最安全的办法就是在readystatachange事件中检查这两个状态，且当一种状态出现时删除readystatachange事件句柄（保证不被处理两次）;\n\n\tvar script = document.createElement (\"script\")\n\tscript.type = \"text/javascript\";\n\t//Internet Explorer\n\tscript.onreadystatechange = function(){\n\tif (script.readyState == \"loaded\" || script.readyState == \"complete\"){\n\t\tscript.onreadystatechange = null;\n\t\talert(\"Script loaded.\");\n\t}\n\t};\n\tscript.src = \"file1.js\";\n\tdocument.getElementsByTagName_r(\"head\")[0].appendChild(script);\n>下面总结上面所说，写一个兼容性的实现JavaScript的动态加载。\n\n\tfunction loadScript(url, callback){\n\tvar script = document.createElement (\"script\")\n\tscript.type = \"text/javascript\";\n\tif (script.readyState){ //IE\n\t\tscript.onreadystatechange = function(){\n\t\t\tif (script.readyState == \"loaded\" || script.readyState == \"complete\"){\n\t\t\t\tscript.onreadystatechange = null;\n\t\t\t\tcallback();\n\t\t\t}\n\t\t};\n\t} else { //Others\n\t\tscript.onload = function(){\n\t\t\tcallback();\n\t\t};\n\t}\n\t\tscript.src = url;\n\t\tdocument.getElementsByTagName_r(\"head\")[0].appendChild(script);\n\t}\n　　此函数传入两个参数：JavaScript文件的URL，和一个JavaScript接收完成的回调函数。此函数的使用方法如下：\n\n\tloadScript(\"file1.js\", function(){\n\t\talert(\"File is loaded!\");\n\t});\n　　当多个JavaScript文件同时加载时，除了Firefox和Opera能保证按顺序加载，其它浏览器都不能。所以可以利用回调函数来控制顺序：\n\n\tloadScript(\"file1.js\", function(){\n\t\tloadScript(\"file2.js\", function(){\n\t\t\tloadScript(\"file3.js\", function(){\n\t\t\t\talert(\"All files are loaded!\");\n\t\t\t});\n\t\t});\n\t});\n\n　　如果多个文件的次序十分重要，更好的办法是将这些文件按照正确的次序连接成一个文件。独立文件可以一次性下载所有代码（由于这是异步进行的，使用一个大文件并没有什么损失）。\n>动态脚本加载是非阻塞 JavaScript 下载中最常用的模式，因为它可以跨浏览器，而且简单易用。\n\n**3.XMLHttpRequest Script Injection XHR**\n　　还有一种非阻塞方式获得脚本的方法是XMLHttpRequst(XHR)对象将脚本注入页面中。\n\n\tvar xhr = new XMLHttpRequest();\n\txhr.open(\"get\", \"file1.js\", true);\n\txhr.onreadystatechange = function(){\n\t\tif (xhr.readyState == 4){\n\t\t\tif (xhr.status >= 200 && xhr.status < 300 || xhr.status == 304){\n\t\t\t\tvar script = document.createElement (\"script\");\n\t\t\t\tscript.type = \"text/javascript\";\n\t\t\t\tscript.text = xhr.responseText;\n\t\t\t\tdocument.body.appendChild(script);\n\t\t\t}\n\t\t}\n\t};\n\txhr.send(null);\n\n　　这段代码向服务器发送一个获取文件file1.js的get请求。然后检测readyState是不是4，再继续检测TTTP状态码status（200表示有效回应，304是缓存响应），如果是有效相应就新建一个< script>元素，将其文本属性设置为返回响应的responseText字符串。\n> + 这种方法的主要优点是， 你可以下载不立即执行的 JavaScript 代码。由于代码返回在< script>标签之外（换句话说不受< script>标签约束），它下载后不会自动执行，这使得你可以推迟执行，直到一切都准备好了。另一个优点是，同样的代码在所有现代浏览器中都不会引发异常。\n> + 此方法最主要的限制是：JavaScript 文件必须与页面放置在同一个域内。正因为这个原因，大型网页通常不采用XHR脚本注入技术。\n\n**4.Recommended Nonblocking Pattern 推荐的非阻塞模式**\n>推荐的向页面加载大量 JavaScript 的方法分为两个步骤：第一步，包含动态加载 JavaScript 所需的代码，然后加载页面初始化所需的除 JavaScript 之外的部分。这部分代码尽量小，可能只包含loadScript()函数，它下载和运行非常迅速，不会对页面造成很大干扰。当初始代码准备好之后，用它来加载其余的 JavaScript。例如：\n\n\t<script type=\"text/javascript\" src=\"loader.js\"></script>\n\t<script type=\"text/javascript\">\n\t\tloadScript(\"the-rest.js\", function(){\n\t\t\tApplication.init();\n\t\t});\n\t</script>\n　　将这段代码放到< /body>标签之前。首先，这样可以确保JavaScript运行不会影响页面其它部分显示。其次，当第二部分 JavaScript 文件完成下载，所有应用程序所必须的 DOM 已经创建好了，并做好被访问的准备，避免使用额外的事件处理（例如 window.onload）来得知页面是否已经准备好了。\n>也可以直接将loadScript函数嵌入在页面中，来避免另一次HTTP请求。\n\n　　如果你决定使用这种方法，建议你使用“YUI Compressor”(参见第 9 章)或者类似的工具将初始化脚本缩小到最小字节尺寸。一旦页面初始化代码下载完成，你还可以使用loadScript()函数加载页面所需的额外功能函数。\n\n**The YUI3 approach**\n　　YUI 3 的核心设计理念为：用一个很小的初始代码，下载其余的功能代码。要在页面上使用YUI 3，首先包含 YUI 的种子文件.\n\n\t<script type=\"text/javascript\"\n\tsrc=http://yui.yahooapis.com/combo?3.0.0/build/yui/yui-min.js></script>\n　　此种子文件大约 10KB（gzipped 压缩后 6KB）包含从 Yahoo! CDN 下载 YUI 组件所需的足够功能。举例来说，如果你想使用DOM功能，你可以指出它的名字（\"dom\"），传递给 YUI 的 use()函数，再提供一个回调函数，当代码准备好时这个回调函数将被调用\n\n\tYUI().use(\"dom\", function(Y){\n\t\tY.DOM.addClass(docment.body, \"loaded\");\n\t})\n**The LazyLoad library**\n　　作为一个更通用的工具，Yahoo! Search 的 Ryan Grove 创建了 LazyLoad 库（参见 http://github.com/rgrove/lazyload/）。LazyLoad 是一个更强大的 loadScript()函数。LazyLoad 精缩之后只有大约 1.5KB（精缩，而不是用 gzip 压缩的）。lazyLoad可以下载多个JavaScript文件，并且能保证执行顺序，只需要LazyLoad.js()函数传递一个URL队列给它。但是仍应该尽可能的减少文件的数量。每次下载都是一个单独的HTTP请求。\n**The LABjs library**\n　　另一个非阻塞 JavaScript 加载库是 LABjs（http://labjs.com/），Kyle Simpson 写的一个开源库，由 Steve Souders 赞助。此库对加载过程进行更精细的控制，并尝试并行下载尽可能多的代码。LABjs 也相当小，只有 4.50KB（精缩，而不是用 gzip 压缩的），所以具有最小的页面代码尺寸。用法举例：\n\n\t<script type=\"text/javascript\" src=\"lab.js\"></script>\n\t<script type=\"text/javascript\">\n\t\t$LAB.script(\"the-rest.js\")\n\t\t\t.wait(function(){\n\t\t\tApplication.init();\n\t\t});\n\t</script>\n　　$LAB.script()函数用于下载一个 JavaScript 文件，$LAB.wait()函数用于指出一个函数，该函数等待文件下载完成并运行之后才会被调用。LABjs 鼓励链操作，每个函数返回一个指向$LAB 对象的引用。要下载多个 JavaScript 文件，那么就链入另一个$LAB.script()调用\n\n\t<script type=\"text/javascript\" src=\"lab.js\"></script>\n\t<script type=\"text/javascript\">\n\t\t$LAB.script(\"first-file.js\")\n\t\t\t.script(\"the-rest.js\")\n\t\t\t.wait(function(){\n\t\t\t\tApplication.init();\n\t\t\t});\n\t</script>\n\n　　LABjs 通过 wait()函数允许你指定哪些文件应该等待其他文件。在前面的例子中，first-file.js 的代码不保证在 the-rest.js 之前运行。为保证这一点，你必须在第一个 script()函数之后添加一个 wait()调用：\n\n\t<script type=\"text/javascript\" src=\"lab.js\"></script>\n\t<script type=\"text/javascript\">\n\t\t$LAB.script(\"first-file.js\").wait()\n\t\t\t.script(\"the-rest.js\")\n\t\t\t.wait(function(){\n\t\t\t\tApplication.init();\n\t\t\t});\n\t</script>\n　　现在，first-file.js 的代码保证会在 the-rest.js 之前执行，虽然两个文件的内容是并行下载的。\n\n**总结：**\n===\n---\n　　JavaScript代码的执行会阻塞其它浏览器的处理过程，比如界面的绘制等。只要遇到< script>标签，页面就必须要等待JavaScript代码的下载（如果是外部的）和执行。这样会影响性能，可能会让浏览者对着空白的浏览器等待很久。通过这一章的学习，可以总结出集中减少JavaScript对性能的影响：\n\n> - 1.将所有的< script>标签尽量放在页面底部，也就是< /body>之前。这样可以保证页面在脚本运行前完成解析。\n> - 2.将脚本成组打包。< script>标签的数量越少，页面加载速度也就越快，响应也会加速（外部脚本和内联代码都适用）。\n> - 3.用几种非阻塞方式下载JavaScript：\n>> - < script>标签加入defer(IE 及 Firefox3.5以上版本)。\n>> - 用 DOM 动态创建< script>元素，用它下载并执行代码。\n>> - 用 XHR 对象来下载代码，并注入页面中（需要同源）。\n\n---\n** *通过使用上述策略，你可以极大提高那些大量使用 JavaScript 代码的网页应用的实际性能。* **","slug":"高性能JavaScript1","published":1,"updated":"2016-10-31T07:25:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciuyzluuh0014e6tbq0ox48g5","content":"<h1 id=\"第一章-Loading-and-Execution-加载和运行\"><a href=\"#第一章-Loading-and-Execution-加载和运行\" class=\"headerlink\" title=\"第一章 Loading and Execution 加载和运行\"></a><strong>第一章 Loading and Execution 加载和运行</strong></h1><p>本文章结尾处有结论，不愿意看原理或者已经懂原理的可以直接看结论。</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><a id=\"more\"></a></h2><h1 id=\"一-Script-Positioning-脚本位置\"><a href=\"#一-Script-Positioning-脚本位置\" class=\"headerlink\" title=\"一.Script Positioning 脚本位置\"></a>一.Script Positioning 脚本位置</h1><hr>\n<p>　　JavaScript在浏览器中的性能，是开发者所要面对的最重要的可用性问题。这个问题因JavaScript的阻塞特征而复杂，也就是说，当JavaScript运行时其他的事情不能被浏览器处理。事实上，大多数浏览器使用单进程处理UI更新和JavaScript运行等多个任务，而同一时间只能有一个任务被执行。JavaScript运行了多长时间，那么在浏览器空闲下来响应用户输入之前的等待时间就有多长。<br>　　从基本层面说，这意味着&lt; script&gt;标签的出现使整个页面因脚本解析、运行而出现等待。不论实际的JavaScript代码是内联的还是包含在一个不相干的外部文件中，页面下载和解析过程必须停下，等待脚本完成这些处理，然后才能继续。这是页面生命周期必不可少的部分，因为脚本可能在运行过程中修改页面内容。典型的例子是 document.write()函数，例如：</p>\n<pre><code>&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Script Example&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;p&gt;\n        &lt;script type=&quot;text/javascript&quot;&gt;\n            document.write(&quot;The date is &quot; + (new Date()).toDateString());\n        &lt;/script&gt;\n    &lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>　　当浏览器遇到一个&lt; script&gt;标签时，正如上面代码中一样，无法预知JavaScript是否在&lt; p&gt;标签中添加内容，所以浏览器要停下来，先运行JavaScript代码，再继续解析和翻译下面的页面。 在使用src属性加载JavaScript的过程中也会出现这样的问题。浏览器必须先下载外部的代码，占用一段时间，然后解析并运行这段代码。在这个过程中，后续的页面解析和用户交互式完全被阻塞的。<br>HTML4文档中指出，一个&lt; script&gt;标签可以放在HTML文档的&lt; head&gt;或&lt; body&gt;中，可以在其中多次出现。传统上，&lt; script&gt;标签用于加载外部的JavaScript文件。&lt; head&gt;部分除了此类代码还包含&lt; link&gt;标签用于加载CSS文件和其他页面的中间件。也就是说，最好把行为所依赖的部分放在一起，首先加载它们，使得页面可以得到正确的外观和行为。如下列代码：</p>\n<pre><code>&lt;head&gt;\n&lt;title&gt;Script Example&lt;/title&gt;\n    &lt;-- Example of inefficient script positioning --&gt;\n    &lt;script type=&quot;text/javascript&quot; src=&quot;file1.js&quot;&gt;&lt;/script&gt;\n    &lt;script type=&quot;text/javascript&quot; src=&quot;file2.js&quot;&gt;&lt;/script&gt;\n    &lt;script type=&quot;text/javascript&quot; src=&quot;file3.js&quot;&gt;&lt;/script&gt;\n    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styles.css&quot;&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;p&gt;Hello world!&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>　　但是在浏览器遇到&lt; body&gt;标签前，不会渲染页面的任何成分，所以这种方式也许会让用户等待在空白的界面很久。下面这个图，说明了加载的整个过程。<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/高性能js-img1.png\" alt=\"GitHub Mark\" title=\"GitHub Mark\"><br>　　从图中可以看出，第一个JavaScript文件开始下载，并阻塞了其他文件的下载过程。在file1.js下载完之后和file2.js开始下载中之前还会有一个延迟，这个延迟是file1.js完全运行所花费的时间。每个文件必须等到前一个文件下载并运行完毕才能开始自己的下载过程。而当这些文件下载时，用户面对的就是一个空白的屏幕。这就是当今大多数浏览器的行为模式。<br>　　IE8，Firefox 3.5，Safari 4，和Chrome2允许并行下载两个JavaScript文件。这样当一个&lt; script&gt;标签在下载时就不会阻塞其它的&lt; script&gt;标签了。但是依然会阻塞其它资源的下载，比如图片。而且，就算脚本直接下载不会互相阻塞，但是页面还是要等在所有的JavaScript代码下载并执行完毕后才能继续。所以，脚本阻塞依旧是问题。</p>\n<blockquote>\n<p>因为脚本阻塞其它页面的资源下载，所以推荐的办法是：将所有的&lt; script&gt;标签尽可能的接近&lt; body&gt;标签的底部位置，尽量减少对整个页面加载的影响。如：</p>\n</blockquote>\n<pre><code>&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Script Example&lt;/title&gt;\n    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styles.css&quot;&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;p&gt;Hello world!&lt;/p&gt;\n    &lt;-- Example of recommended script positioning --&gt;\n    &lt;script type=&quot;text/javascript&quot; src=&quot;file1.js&quot;&gt;&lt;/script&gt;\n    &lt;script type=&quot;text/javascript&quot; src=&quot;file2.js&quot;&gt;&lt;/script&gt;\n    &lt;script type=&quot;text/javascript&quot; src=&quot;file3.js&quot;&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><blockquote>\n<p><strong>这正是“Yahoo! 优越性能小组”关于JavaScript 的第一条定律：<em>将脚本放在底部</em>。</strong></p>\n</blockquote>\n<h1 id=\"二-Grouping-Scripts-成组脚本\"><a href=\"#二-Grouping-Scripts-成组脚本\" class=\"headerlink\" title=\"二.Grouping Scripts  成组脚本\"></a>二.Grouping Scripts  成组脚本</h1><hr>\n<p>　　因为每个&lt; script&gt;标签下载时都会阻塞页面解析过程，所以限制页面的&lt; script&gt;标签总数也可以改善性能（内联脚本和外联脚本都适用）。每个HTTP请求都会产生额外的性能负担，下载一个 100KB 的文件比下载四个 25KB 的文件要快。所以尽量减少外部脚本的数量。这一系列的工作可通过一个打包工具实现（在第9章有介绍），或者一个实时工具，诸如“<a href=\"http://yui.yahooapis.com/combo?2.7.0/build/yahoo/yahoo-min.js&amp;2.7.0/build/event/event-min.js\" target=\"_blank\" rel=\"external\">Yahoo! combo handler</a>”。<br>Yahoo!适用一个“联合语把柄”来解决这个问题，例如，下面的 URL 包含两个文件：<br><a href=\"http://yui.yahooapis.com/combo?2.7.0/build/yahoo/yahoo-min.js&amp;2.7.0/build/event/event-min.js\" target=\"_blank\" rel=\"external\">http://yui.yahooapis.com/combo?2.7.0/build/yahoo/yahoo-min.js&amp;2.7.0/build/event/event-min.js</a><br>　　这个URL调用了2.7.0版本的 yahoo-min.js 和 event-min.js 文件。这些文件在服务器上是两个分离的文件，但是当服务器收到此URL请求时，两个文件就会被合并在一起返回给客户。这样一个&lt; script&gt;标签就可以加载它们：</p>\n<pre><code>&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Script Example&lt;/title&gt;\n    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styles.css&quot;&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;p&gt;Hello world!&lt;/p&gt;\n    &lt;-- Example of recommended script positioning --&gt;\n    &lt;script type=&quot;text/javascript&quot;\n        src=&quot;http://yui.yahooapis.com/combo?2.7.0/build/yahoo/yahoo-min.js&amp;2.7.0/build/event/event-min.js&quot;&gt;\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><blockquote>\n<p>这是在HTML页面中包含多个外部JavaScript的最佳方法。</p>\n</blockquote>\n<h1 id=\"三-Nonblocking-Scripts-非阻塞脚本\"><a href=\"#三-Nonblocking-Scripts-非阻塞脚本\" class=\"headerlink\" title=\"三.Nonblocking Scripts 非阻塞脚本\"></a>三.Nonblocking Scripts 非阻塞脚本</h1><hr>\n<p>　　JavaScript 倾向于阻塞浏览器某些处理过程，如 HTTP请求和界面刷新，这是开发者面临的最显著的性能问题。保持JavaScript文件短小，并限制 HTTP 请求的数量，只是创建反应迅速的网页应用的第一步。一个应用程序所包含的功能越多，所需要的 JavaScript 代码就越大，保持源码短小并不总是一种选择。尽管下载一个大JavaScript文件只产生一次HTTP请求，却会锁定浏览器一大段时间。为避开这种情况，你需要向页面中逐步添加 JavaScript，某种程度上说不会阻塞浏览器。<br>非阻塞脚本的秘密在于，等页面完成加载之后，再加载 JavaScript 源码。从技术角度讲，这意味着在window 的 load 事件发出之后开始下载代码。有几种方法可以实现这种效果。<br><strong>1.Deferred Scripts 延期脚本</strong><br>　　HTML4中定义的defer属性就表明了这段脚本不会修改DOM，所以代码可以稍后执行。defer只被IE4和Firefox 3.5及以上版本支持，它并不是一个理想的跨浏览器解决方案。如果浏览器支持，这种方法是一种很有用的解决方案：</p>\n<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;file1.js&quot; defer&gt;&lt;/script&gt;\n</code></pre><p>JavaScript文件将在&lt; script&gt;标签被解析时启动下载，但是不会执行，知道DOM加载完成（onlaod事件被调用之前）。这样当一个defer的JavaScript文件被下载时，不会阻塞浏览器的其他处理过程，即其它资源也可以一起并行下载。</p>\n<pre><code>&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Script Defer Example&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;script defer&gt;\n        alert(&quot;defer&quot;);\n    &lt;/script&gt;\n    &lt;script&gt;\n        alert(&quot;script&quot;);\n    &lt;/script&gt;\n    &lt;script&gt;\n        window.onload = function(){\n            alert(&quot;load&quot;);\n        };\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>　　以上代码阐述了defer的执行过程，如果浏览器不支持defer那么这段程序将按顺序执行，即defer、script、load。如果浏览器支持defer属性，弹出框的顺序为：script、defer、load。这里有一点需要注意：</p>\n<blockquote>\n<p><strong>defer的&lt; script&gt;标签不是跟在第二个后面运行，而是在onload事件语句之前被调用</strong></p>\n</blockquote>\n<p>　　如果你的目标浏览器只包括 IE 和 Firefox 3.5，那么 defer 脚本确实有用。如果你需要支持跨领域的多种浏览器，那么还有更一致的实现方式<br><strong>2.Dynamic Script Elements 动态脚本元素</strong><br>DOM可以用JavaScript动态创建HTML的几乎所有文档内容，就是因为&lt; script&gt;标签与页面其它的标签没有什么不同：引用变量可以通过DOM进行检索，可以从文档中移动、删除和创建。一个新的&lt; script&gt;标签很容易被标准的DOM函数创建。</p>\n<pre><code>var script = document.createElement (&quot;script&quot;);\nscript.type = &quot;text/javascript&quot;;\nscript.src = &quot;file1.js&quot;;\ndocument.getElementsByTagName_r(&quot;head&quot;)[0].appendChild(script);\n</code></pre><p>　　而这个被创建的标签加载file1.js源文件。这个文件在元素添加到页面之后立刻开始下载。此技术的重点在于：无论在何处启动下载，文件的下载和运行都不会阻塞其它的页面处理过程。你甚至可以将这些代码放在&lt; head&gt;部分而不会对其余部分的页面代码造成影响（除了用于下载文件的HTTP链接）。<br>当文件使用动态脚本节点下载时，返回的代码通常立即执行（除了 Firefox 和 Opera，他们将等待此前的所有动态脚本节点执行完毕）。当脚本是“自运行”类型时这一机制运行正常，但是如果脚本只包含供页面其他脚本调用调用的接口，则会带来问题。这种情况下，你需要跟踪脚本下载完成并准备妥善的情况。可以使用动态&lt; script&gt;节点发出事件得到相关信息。Firefox, Opera, Chorme 和 Safari 3+会在&lt; script&gt;节点接收完成之后发出一个load事件。你可以监听这一事件，以得到脚本准备好的通知：</p>\n<pre><code>var script = document.createElement (&quot;script&quot;)\nscript.type = &quot;text/javascript&quot;;\n//Firefox, Opera, Chrome, Safari 3+\nscript.onload = function(){\nalert(&quot;Script loaded!&quot;);\n};\nscript.src = &quot;file1.js&quot;;\ndocument.getElementsByTagName_r(&quot;head&quot;)[0].appendChild(script);\n</code></pre><p>　　IE中支持另一种实现方式，它发出一个readystatechange事件，&lt; script&gt;标签有一个readyState属性，它的值随着下载外部文件的过程而改变。readyState有五种取值：</p>\n<pre><code>&quot;uninitialized&quot; The default state 默认状态\n&quot;loading&quot; Download has begun 下载开始\n&quot;loaded&quot; Download has completed 下载完成\n&quot;interactive&quot; Data is completely downloaded but isn&apos;t fully available 下载完成但尚不可用\n&quot;complete&quot; All data is ready to be used 所有数据已经准备好\n</code></pre><p>　　微软的文档说，在一个生命周期中这些值并不一定都会出现，但并没有说哪些不会。在实践中，我们最有用的是”loaded”和”complete”,而这两个属性值也不是全会出现，有时有”loade”而不出现”complete”，有时反之。所以最安全的办法就是在readystatachange事件中检查这两个状态，且当一种状态出现时删除readystatachange事件句柄（保证不被处理两次）;</p>\n<pre><code>var script = document.createElement (&quot;script&quot;)\nscript.type = &quot;text/javascript&quot;;\n//Internet Explorer\nscript.onreadystatechange = function(){\nif (script.readyState == &quot;loaded&quot; || script.readyState == &quot;complete&quot;){\n    script.onreadystatechange = null;\n    alert(&quot;Script loaded.&quot;);\n}\n};\nscript.src = &quot;file1.js&quot;;\ndocument.getElementsByTagName_r(&quot;head&quot;)[0].appendChild(script);\n</code></pre><blockquote>\n<p>下面总结上面所说，写一个兼容性的实现JavaScript的动态加载。</p>\n</blockquote>\n<pre><code>function loadScript(url, callback){\nvar script = document.createElement (&quot;script&quot;)\nscript.type = &quot;text/javascript&quot;;\nif (script.readyState){ //IE\n    script.onreadystatechange = function(){\n        if (script.readyState == &quot;loaded&quot; || script.readyState == &quot;complete&quot;){\n            script.onreadystatechange = null;\n            callback();\n        }\n    };\n} else { //Others\n    script.onload = function(){\n        callback();\n    };\n}\n    script.src = url;\n    document.getElementsByTagName_r(&quot;head&quot;)[0].appendChild(script);\n}\n</code></pre><p>　　此函数传入两个参数：JavaScript文件的URL，和一个JavaScript接收完成的回调函数。此函数的使用方法如下：</p>\n<pre><code>loadScript(&quot;file1.js&quot;, function(){\n    alert(&quot;File is loaded!&quot;);\n});\n</code></pre><p>　　当多个JavaScript文件同时加载时，除了Firefox和Opera能保证按顺序加载，其它浏览器都不能。所以可以利用回调函数来控制顺序：</p>\n<pre><code>loadScript(&quot;file1.js&quot;, function(){\n    loadScript(&quot;file2.js&quot;, function(){\n        loadScript(&quot;file3.js&quot;, function(){\n            alert(&quot;All files are loaded!&quot;);\n        });\n    });\n});\n</code></pre><p>　　如果多个文件的次序十分重要，更好的办法是将这些文件按照正确的次序连接成一个文件。独立文件可以一次性下载所有代码（由于这是异步进行的，使用一个大文件并没有什么损失）。</p>\n<blockquote>\n<p>动态脚本加载是非阻塞 JavaScript 下载中最常用的模式，因为它可以跨浏览器，而且简单易用。</p>\n</blockquote>\n<p><strong>3.XMLHttpRequest Script Injection XHR</strong><br>　　还有一种非阻塞方式获得脚本的方法是XMLHttpRequst(XHR)对象将脚本注入页面中。</p>\n<pre><code>var xhr = new XMLHttpRequest();\nxhr.open(&quot;get&quot;, &quot;file1.js&quot;, true);\nxhr.onreadystatechange = function(){\n    if (xhr.readyState == 4){\n        if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304){\n            var script = document.createElement (&quot;script&quot;);\n            script.type = &quot;text/javascript&quot;;\n            script.text = xhr.responseText;\n            document.body.appendChild(script);\n        }\n    }\n};\nxhr.send(null);\n</code></pre><p>　　这段代码向服务器发送一个获取文件file1.js的get请求。然后检测readyState是不是4，再继续检测TTTP状态码status（200表示有效回应，304是缓存响应），如果是有效相应就新建一个&lt; script&gt;元素，将其文本属性设置为返回响应的responseText字符串。</p>\n<blockquote>\n<ul>\n<li>这种方法的主要优点是， 你可以下载不立即执行的 JavaScript 代码。由于代码返回在&lt; script&gt;标签之外（换句话说不受&lt; script&gt;标签约束），它下载后不会自动执行，这使得你可以推迟执行，直到一切都准备好了。另一个优点是，同样的代码在所有现代浏览器中都不会引发异常。</li>\n<li>此方法最主要的限制是：JavaScript 文件必须与页面放置在同一个域内。正因为这个原因，大型网页通常不采用XHR脚本注入技术。</li>\n</ul>\n</blockquote>\n<p><strong>4.Recommended Nonblocking Pattern 推荐的非阻塞模式</strong></p>\n<blockquote>\n<p>推荐的向页面加载大量 JavaScript 的方法分为两个步骤：第一步，包含动态加载 JavaScript 所需的代码，然后加载页面初始化所需的除 JavaScript 之外的部分。这部分代码尽量小，可能只包含loadScript()函数，它下载和运行非常迅速，不会对页面造成很大干扰。当初始代码准备好之后，用它来加载其余的 JavaScript。例如：</p>\n</blockquote>\n<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;loader.js&quot;&gt;&lt;/script&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n    loadScript(&quot;the-rest.js&quot;, function(){\n        Application.init();\n    });\n&lt;/script&gt;\n</code></pre><p>　　将这段代码放到&lt; /body&gt;标签之前。首先，这样可以确保JavaScript运行不会影响页面其它部分显示。其次，当第二部分 JavaScript 文件完成下载，所有应用程序所必须的 DOM 已经创建好了，并做好被访问的准备，避免使用额外的事件处理（例如 window.onload）来得知页面是否已经准备好了。</p>\n<blockquote>\n<p>也可以直接将loadScript函数嵌入在页面中，来避免另一次HTTP请求。</p>\n</blockquote>\n<p>　　如果你决定使用这种方法，建议你使用“YUI Compressor”(参见第 9 章)或者类似的工具将初始化脚本缩小到最小字节尺寸。一旦页面初始化代码下载完成，你还可以使用loadScript()函数加载页面所需的额外功能函数。</p>\n<p><strong>The YUI3 approach</strong><br>　　YUI 3 的核心设计理念为：用一个很小的初始代码，下载其余的功能代码。要在页面上使用YUI 3，首先包含 YUI 的种子文件.</p>\n<pre><code>&lt;script type=&quot;text/javascript&quot;\nsrc=http://yui.yahooapis.com/combo?3.0.0/build/yui/yui-min.js&gt;&lt;/script&gt;\n</code></pre><p>　　此种子文件大约 10KB（gzipped 压缩后 6KB）包含从 Yahoo! CDN 下载 YUI 组件所需的足够功能。举例来说，如果你想使用DOM功能，你可以指出它的名字（”dom”），传递给 YUI 的 use()函数，再提供一个回调函数，当代码准备好时这个回调函数将被调用</p>\n<pre><code>YUI().use(&quot;dom&quot;, function(Y){\n    Y.DOM.addClass(docment.body, &quot;loaded&quot;);\n})\n</code></pre><p><strong>The LazyLoad library</strong><br>　　作为一个更通用的工具，Yahoo! Search 的 Ryan Grove 创建了 LazyLoad 库（参见 <a href=\"http://github.com/rgrove/lazyload/）。LazyLoad\" target=\"_blank\" rel=\"external\">http://github.com/rgrove/lazyload/）。LazyLoad</a> 是一个更强大的 loadScript()函数。LazyLoad 精缩之后只有大约 1.5KB（精缩，而不是用 gzip 压缩的）。lazyLoad可以下载多个JavaScript文件，并且能保证执行顺序，只需要LazyLoad.js()函数传递一个URL队列给它。但是仍应该尽可能的减少文件的数量。每次下载都是一个单独的HTTP请求。<br><strong>The LABjs library</strong><br>　　另一个非阻塞 JavaScript 加载库是 LABjs（<a href=\"http://labjs.com/），Kyle\" target=\"_blank\" rel=\"external\">http://labjs.com/），Kyle</a> Simpson 写的一个开源库，由 Steve Souders 赞助。此库对加载过程进行更精细的控制，并尝试并行下载尽可能多的代码。LABjs 也相当小，只有 4.50KB（精缩，而不是用 gzip 压缩的），所以具有最小的页面代码尺寸。用法举例：</p>\n<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;lab.js&quot;&gt;&lt;/script&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n    $LAB.script(&quot;the-rest.js&quot;)\n        .wait(function(){\n        Application.init();\n    });\n&lt;/script&gt;\n</code></pre><p>　　$LAB.script()函数用于下载一个 JavaScript 文件，$LAB.wait()函数用于指出一个函数，该函数等待文件下载完成并运行之后才会被调用。LABjs 鼓励链操作，每个函数返回一个指向$LAB 对象的引用。要下载多个 JavaScript 文件，那么就链入另一个$LAB.script()调用</p>\n<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;lab.js&quot;&gt;&lt;/script&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n    $LAB.script(&quot;first-file.js&quot;)\n        .script(&quot;the-rest.js&quot;)\n        .wait(function(){\n            Application.init();\n        });\n&lt;/script&gt;\n</code></pre><p>　　LABjs 通过 wait()函数允许你指定哪些文件应该等待其他文件。在前面的例子中，first-file.js 的代码不保证在 the-rest.js 之前运行。为保证这一点，你必须在第一个 script()函数之后添加一个 wait()调用：</p>\n<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;lab.js&quot;&gt;&lt;/script&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n    $LAB.script(&quot;first-file.js&quot;).wait()\n        .script(&quot;the-rest.js&quot;)\n        .wait(function(){\n            Application.init();\n        });\n&lt;/script&gt;\n</code></pre><p>　　现在，first-file.js 的代码保证会在 the-rest.js 之前执行，虽然两个文件的内容是并行下载的。</p>\n<h1 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a><strong>总结：</strong></h1><hr>\n<p>　　JavaScript代码的执行会阻塞其它浏览器的处理过程，比如界面的绘制等。只要遇到&lt; script&gt;标签，页面就必须要等待JavaScript代码的下载（如果是外部的）和执行。这样会影响性能，可能会让浏览者对着空白的浏览器等待很久。通过这一章的学习，可以总结出集中减少JavaScript对性能的影响：</p>\n<blockquote>\n<ul>\n<li>1.将所有的&lt; script&gt;标签尽量放在页面底部，也就是&lt; /body&gt;之前。这样可以保证页面在脚本运行前完成解析。</li>\n<li>2.将脚本成组打包。&lt; script&gt;标签的数量越少，页面加载速度也就越快，响应也会加速（外部脚本和内联代码都适用）。</li>\n<li>3.用几种非阻塞方式下载JavaScript：<blockquote>\n<ul>\n<li>&lt; script&gt;标签加入defer(IE 及 Firefox3.5以上版本)。</li>\n<li>用 DOM 动态创建&lt; script&gt;元素，用它下载并执行代码。</li>\n<li>用 XHR 对象来下载代码，并注入页面中（需要同源）。</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<hr>\n<p><strong> <em>通过使用上述策略，你可以极大提高那些大量使用 JavaScript 代码的网页应用的实际性能。</em> </strong></p>\n","excerpt":"<h1 id=\"第一章-Loading-and-Execution-加载和运行\"><a href=\"#第一章-Loading-and-Execution-加载和运行\" class=\"headerlink\" title=\"第一章 Loading and Execution 加载和运行\"></a><strong>第一章 Loading and Execution 加载和运行</strong></h1><p>本文章结尾处有结论，不愿意看原理或者已经懂原理的可以直接看结论。</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a>","more":"</h2><h1 id=\"一-Script-Positioning-脚本位置\"><a href=\"#一-Script-Positioning-脚本位置\" class=\"headerlink\" title=\"一.Script Positioning 脚本位置\"></a>一.Script Positioning 脚本位置</h1><hr>\n<p>　　JavaScript在浏览器中的性能，是开发者所要面对的最重要的可用性问题。这个问题因JavaScript的阻塞特征而复杂，也就是说，当JavaScript运行时其他的事情不能被浏览器处理。事实上，大多数浏览器使用单进程处理UI更新和JavaScript运行等多个任务，而同一时间只能有一个任务被执行。JavaScript运行了多长时间，那么在浏览器空闲下来响应用户输入之前的等待时间就有多长。<br>　　从基本层面说，这意味着&lt; script&gt;标签的出现使整个页面因脚本解析、运行而出现等待。不论实际的JavaScript代码是内联的还是包含在一个不相干的外部文件中，页面下载和解析过程必须停下，等待脚本完成这些处理，然后才能继续。这是页面生命周期必不可少的部分，因为脚本可能在运行过程中修改页面内容。典型的例子是 document.write()函数，例如：</p>\n<pre><code>&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Script Example&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;p&gt;\n        &lt;script type=&quot;text/javascript&quot;&gt;\n            document.write(&quot;The date is &quot; + (new Date()).toDateString());\n        &lt;/script&gt;\n    &lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>　　当浏览器遇到一个&lt; script&gt;标签时，正如上面代码中一样，无法预知JavaScript是否在&lt; p&gt;标签中添加内容，所以浏览器要停下来，先运行JavaScript代码，再继续解析和翻译下面的页面。 在使用src属性加载JavaScript的过程中也会出现这样的问题。浏览器必须先下载外部的代码，占用一段时间，然后解析并运行这段代码。在这个过程中，后续的页面解析和用户交互式完全被阻塞的。<br>HTML4文档中指出，一个&lt; script&gt;标签可以放在HTML文档的&lt; head&gt;或&lt; body&gt;中，可以在其中多次出现。传统上，&lt; script&gt;标签用于加载外部的JavaScript文件。&lt; head&gt;部分除了此类代码还包含&lt; link&gt;标签用于加载CSS文件和其他页面的中间件。也就是说，最好把行为所依赖的部分放在一起，首先加载它们，使得页面可以得到正确的外观和行为。如下列代码：</p>\n<pre><code>&lt;head&gt;\n&lt;title&gt;Script Example&lt;/title&gt;\n    &lt;-- Example of inefficient script positioning --&gt;\n    &lt;script type=&quot;text/javascript&quot; src=&quot;file1.js&quot;&gt;&lt;/script&gt;\n    &lt;script type=&quot;text/javascript&quot; src=&quot;file2.js&quot;&gt;&lt;/script&gt;\n    &lt;script type=&quot;text/javascript&quot; src=&quot;file3.js&quot;&gt;&lt;/script&gt;\n    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styles.css&quot;&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;p&gt;Hello world!&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>　　但是在浏览器遇到&lt; body&gt;标签前，不会渲染页面的任何成分，所以这种方式也许会让用户等待在空白的界面很久。下面这个图，说明了加载的整个过程。<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/高性能js-img1.png\" alt=\"GitHub Mark\" title=\"GitHub Mark\"><br>　　从图中可以看出，第一个JavaScript文件开始下载，并阻塞了其他文件的下载过程。在file1.js下载完之后和file2.js开始下载中之前还会有一个延迟，这个延迟是file1.js完全运行所花费的时间。每个文件必须等到前一个文件下载并运行完毕才能开始自己的下载过程。而当这些文件下载时，用户面对的就是一个空白的屏幕。这就是当今大多数浏览器的行为模式。<br>　　IE8，Firefox 3.5，Safari 4，和Chrome2允许并行下载两个JavaScript文件。这样当一个&lt; script&gt;标签在下载时就不会阻塞其它的&lt; script&gt;标签了。但是依然会阻塞其它资源的下载，比如图片。而且，就算脚本直接下载不会互相阻塞，但是页面还是要等在所有的JavaScript代码下载并执行完毕后才能继续。所以，脚本阻塞依旧是问题。</p>\n<blockquote>\n<p>因为脚本阻塞其它页面的资源下载，所以推荐的办法是：将所有的&lt; script&gt;标签尽可能的接近&lt; body&gt;标签的底部位置，尽量减少对整个页面加载的影响。如：</p>\n</blockquote>\n<pre><code>&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Script Example&lt;/title&gt;\n    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styles.css&quot;&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;p&gt;Hello world!&lt;/p&gt;\n    &lt;-- Example of recommended script positioning --&gt;\n    &lt;script type=&quot;text/javascript&quot; src=&quot;file1.js&quot;&gt;&lt;/script&gt;\n    &lt;script type=&quot;text/javascript&quot; src=&quot;file2.js&quot;&gt;&lt;/script&gt;\n    &lt;script type=&quot;text/javascript&quot; src=&quot;file3.js&quot;&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><blockquote>\n<p><strong>这正是“Yahoo! 优越性能小组”关于JavaScript 的第一条定律：<em>将脚本放在底部</em>。</strong></p>\n</blockquote>\n<h1 id=\"二-Grouping-Scripts-成组脚本\"><a href=\"#二-Grouping-Scripts-成组脚本\" class=\"headerlink\" title=\"二.Grouping Scripts  成组脚本\"></a>二.Grouping Scripts  成组脚本</h1><hr>\n<p>　　因为每个&lt; script&gt;标签下载时都会阻塞页面解析过程，所以限制页面的&lt; script&gt;标签总数也可以改善性能（内联脚本和外联脚本都适用）。每个HTTP请求都会产生额外的性能负担，下载一个 100KB 的文件比下载四个 25KB 的文件要快。所以尽量减少外部脚本的数量。这一系列的工作可通过一个打包工具实现（在第9章有介绍），或者一个实时工具，诸如“<a href=\"http://yui.yahooapis.com/combo?2.7.0/build/yahoo/yahoo-min.js&amp;2.7.0/build/event/event-min.js\">Yahoo! combo handler</a>”。<br>Yahoo!适用一个“联合语把柄”来解决这个问题，例如，下面的 URL 包含两个文件：<br><a href=\"http://yui.yahooapis.com/combo?2.7.0/build/yahoo/yahoo-min.js&amp;2.7.0/build/event/event-min.js\">http://yui.yahooapis.com/combo?2.7.0/build/yahoo/yahoo-min.js&amp;2.7.0/build/event/event-min.js</a><br>　　这个URL调用了2.7.0版本的 yahoo-min.js 和 event-min.js 文件。这些文件在服务器上是两个分离的文件，但是当服务器收到此URL请求时，两个文件就会被合并在一起返回给客户。这样一个&lt; script&gt;标签就可以加载它们：</p>\n<pre><code>&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Script Example&lt;/title&gt;\n    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styles.css&quot;&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;p&gt;Hello world!&lt;/p&gt;\n    &lt;-- Example of recommended script positioning --&gt;\n    &lt;script type=&quot;text/javascript&quot;\n        src=&quot;http://yui.yahooapis.com/combo?2.7.0/build/yahoo/yahoo-min.js&amp;2.7.0/build/event/event-min.js&quot;&gt;\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><blockquote>\n<p>这是在HTML页面中包含多个外部JavaScript的最佳方法。</p>\n</blockquote>\n<h1 id=\"三-Nonblocking-Scripts-非阻塞脚本\"><a href=\"#三-Nonblocking-Scripts-非阻塞脚本\" class=\"headerlink\" title=\"三.Nonblocking Scripts 非阻塞脚本\"></a>三.Nonblocking Scripts 非阻塞脚本</h1><hr>\n<p>　　JavaScript 倾向于阻塞浏览器某些处理过程，如 HTTP请求和界面刷新，这是开发者面临的最显著的性能问题。保持JavaScript文件短小，并限制 HTTP 请求的数量，只是创建反应迅速的网页应用的第一步。一个应用程序所包含的功能越多，所需要的 JavaScript 代码就越大，保持源码短小并不总是一种选择。尽管下载一个大JavaScript文件只产生一次HTTP请求，却会锁定浏览器一大段时间。为避开这种情况，你需要向页面中逐步添加 JavaScript，某种程度上说不会阻塞浏览器。<br>非阻塞脚本的秘密在于，等页面完成加载之后，再加载 JavaScript 源码。从技术角度讲，这意味着在window 的 load 事件发出之后开始下载代码。有几种方法可以实现这种效果。<br><strong>1.Deferred Scripts 延期脚本</strong><br>　　HTML4中定义的defer属性就表明了这段脚本不会修改DOM，所以代码可以稍后执行。defer只被IE4和Firefox 3.5及以上版本支持，它并不是一个理想的跨浏览器解决方案。如果浏览器支持，这种方法是一种很有用的解决方案：</p>\n<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;file1.js&quot; defer&gt;&lt;/script&gt;\n</code></pre><p>JavaScript文件将在&lt; script&gt;标签被解析时启动下载，但是不会执行，知道DOM加载完成（onlaod事件被调用之前）。这样当一个defer的JavaScript文件被下载时，不会阻塞浏览器的其他处理过程，即其它资源也可以一起并行下载。</p>\n<pre><code>&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Script Defer Example&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;script defer&gt;\n        alert(&quot;defer&quot;);\n    &lt;/script&gt;\n    &lt;script&gt;\n        alert(&quot;script&quot;);\n    &lt;/script&gt;\n    &lt;script&gt;\n        window.onload = function(){\n            alert(&quot;load&quot;);\n        };\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>　　以上代码阐述了defer的执行过程，如果浏览器不支持defer那么这段程序将按顺序执行，即defer、script、load。如果浏览器支持defer属性，弹出框的顺序为：script、defer、load。这里有一点需要注意：</p>\n<blockquote>\n<p><strong>defer的&lt; script&gt;标签不是跟在第二个后面运行，而是在onload事件语句之前被调用</strong></p>\n</blockquote>\n<p>　　如果你的目标浏览器只包括 IE 和 Firefox 3.5，那么 defer 脚本确实有用。如果你需要支持跨领域的多种浏览器，那么还有更一致的实现方式<br><strong>2.Dynamic Script Elements 动态脚本元素</strong><br>DOM可以用JavaScript动态创建HTML的几乎所有文档内容，就是因为&lt; script&gt;标签与页面其它的标签没有什么不同：引用变量可以通过DOM进行检索，可以从文档中移动、删除和创建。一个新的&lt; script&gt;标签很容易被标准的DOM函数创建。</p>\n<pre><code>var script = document.createElement (&quot;script&quot;);\nscript.type = &quot;text/javascript&quot;;\nscript.src = &quot;file1.js&quot;;\ndocument.getElementsByTagName_r(&quot;head&quot;)[0].appendChild(script);\n</code></pre><p>　　而这个被创建的标签加载file1.js源文件。这个文件在元素添加到页面之后立刻开始下载。此技术的重点在于：无论在何处启动下载，文件的下载和运行都不会阻塞其它的页面处理过程。你甚至可以将这些代码放在&lt; head&gt;部分而不会对其余部分的页面代码造成影响（除了用于下载文件的HTTP链接）。<br>当文件使用动态脚本节点下载时，返回的代码通常立即执行（除了 Firefox 和 Opera，他们将等待此前的所有动态脚本节点执行完毕）。当脚本是“自运行”类型时这一机制运行正常，但是如果脚本只包含供页面其他脚本调用调用的接口，则会带来问题。这种情况下，你需要跟踪脚本下载完成并准备妥善的情况。可以使用动态&lt; script&gt;节点发出事件得到相关信息。Firefox, Opera, Chorme 和 Safari 3+会在&lt; script&gt;节点接收完成之后发出一个load事件。你可以监听这一事件，以得到脚本准备好的通知：</p>\n<pre><code>var script = document.createElement (&quot;script&quot;)\nscript.type = &quot;text/javascript&quot;;\n//Firefox, Opera, Chrome, Safari 3+\nscript.onload = function(){\nalert(&quot;Script loaded!&quot;);\n};\nscript.src = &quot;file1.js&quot;;\ndocument.getElementsByTagName_r(&quot;head&quot;)[0].appendChild(script);\n</code></pre><p>　　IE中支持另一种实现方式，它发出一个readystatechange事件，&lt; script&gt;标签有一个readyState属性，它的值随着下载外部文件的过程而改变。readyState有五种取值：</p>\n<pre><code>&quot;uninitialized&quot; The default state 默认状态\n&quot;loading&quot; Download has begun 下载开始\n&quot;loaded&quot; Download has completed 下载完成\n&quot;interactive&quot; Data is completely downloaded but isn&apos;t fully available 下载完成但尚不可用\n&quot;complete&quot; All data is ready to be used 所有数据已经准备好\n</code></pre><p>　　微软的文档说，在一个生命周期中这些值并不一定都会出现，但并没有说哪些不会。在实践中，我们最有用的是”loaded”和”complete”,而这两个属性值也不是全会出现，有时有”loade”而不出现”complete”，有时反之。所以最安全的办法就是在readystatachange事件中检查这两个状态，且当一种状态出现时删除readystatachange事件句柄（保证不被处理两次）;</p>\n<pre><code>var script = document.createElement (&quot;script&quot;)\nscript.type = &quot;text/javascript&quot;;\n//Internet Explorer\nscript.onreadystatechange = function(){\nif (script.readyState == &quot;loaded&quot; || script.readyState == &quot;complete&quot;){\n    script.onreadystatechange = null;\n    alert(&quot;Script loaded.&quot;);\n}\n};\nscript.src = &quot;file1.js&quot;;\ndocument.getElementsByTagName_r(&quot;head&quot;)[0].appendChild(script);\n</code></pre><blockquote>\n<p>下面总结上面所说，写一个兼容性的实现JavaScript的动态加载。</p>\n</blockquote>\n<pre><code>function loadScript(url, callback){\nvar script = document.createElement (&quot;script&quot;)\nscript.type = &quot;text/javascript&quot;;\nif (script.readyState){ //IE\n    script.onreadystatechange = function(){\n        if (script.readyState == &quot;loaded&quot; || script.readyState == &quot;complete&quot;){\n            script.onreadystatechange = null;\n            callback();\n        }\n    };\n} else { //Others\n    script.onload = function(){\n        callback();\n    };\n}\n    script.src = url;\n    document.getElementsByTagName_r(&quot;head&quot;)[0].appendChild(script);\n}\n</code></pre><p>　　此函数传入两个参数：JavaScript文件的URL，和一个JavaScript接收完成的回调函数。此函数的使用方法如下：</p>\n<pre><code>loadScript(&quot;file1.js&quot;, function(){\n    alert(&quot;File is loaded!&quot;);\n});\n</code></pre><p>　　当多个JavaScript文件同时加载时，除了Firefox和Opera能保证按顺序加载，其它浏览器都不能。所以可以利用回调函数来控制顺序：</p>\n<pre><code>loadScript(&quot;file1.js&quot;, function(){\n    loadScript(&quot;file2.js&quot;, function(){\n        loadScript(&quot;file3.js&quot;, function(){\n            alert(&quot;All files are loaded!&quot;);\n        });\n    });\n});\n</code></pre><p>　　如果多个文件的次序十分重要，更好的办法是将这些文件按照正确的次序连接成一个文件。独立文件可以一次性下载所有代码（由于这是异步进行的，使用一个大文件并没有什么损失）。</p>\n<blockquote>\n<p>动态脚本加载是非阻塞 JavaScript 下载中最常用的模式，因为它可以跨浏览器，而且简单易用。</p>\n</blockquote>\n<p><strong>3.XMLHttpRequest Script Injection XHR</strong><br>　　还有一种非阻塞方式获得脚本的方法是XMLHttpRequst(XHR)对象将脚本注入页面中。</p>\n<pre><code>var xhr = new XMLHttpRequest();\nxhr.open(&quot;get&quot;, &quot;file1.js&quot;, true);\nxhr.onreadystatechange = function(){\n    if (xhr.readyState == 4){\n        if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304){\n            var script = document.createElement (&quot;script&quot;);\n            script.type = &quot;text/javascript&quot;;\n            script.text = xhr.responseText;\n            document.body.appendChild(script);\n        }\n    }\n};\nxhr.send(null);\n</code></pre><p>　　这段代码向服务器发送一个获取文件file1.js的get请求。然后检测readyState是不是4，再继续检测TTTP状态码status（200表示有效回应，304是缓存响应），如果是有效相应就新建一个&lt; script&gt;元素，将其文本属性设置为返回响应的responseText字符串。</p>\n<blockquote>\n<ul>\n<li>这种方法的主要优点是， 你可以下载不立即执行的 JavaScript 代码。由于代码返回在&lt; script&gt;标签之外（换句话说不受&lt; script&gt;标签约束），它下载后不会自动执行，这使得你可以推迟执行，直到一切都准备好了。另一个优点是，同样的代码在所有现代浏览器中都不会引发异常。</li>\n<li>此方法最主要的限制是：JavaScript 文件必须与页面放置在同一个域内。正因为这个原因，大型网页通常不采用XHR脚本注入技术。</li>\n</ul>\n</blockquote>\n<p><strong>4.Recommended Nonblocking Pattern 推荐的非阻塞模式</strong></p>\n<blockquote>\n<p>推荐的向页面加载大量 JavaScript 的方法分为两个步骤：第一步，包含动态加载 JavaScript 所需的代码，然后加载页面初始化所需的除 JavaScript 之外的部分。这部分代码尽量小，可能只包含loadScript()函数，它下载和运行非常迅速，不会对页面造成很大干扰。当初始代码准备好之后，用它来加载其余的 JavaScript。例如：</p>\n</blockquote>\n<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;loader.js&quot;&gt;&lt;/script&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n    loadScript(&quot;the-rest.js&quot;, function(){\n        Application.init();\n    });\n&lt;/script&gt;\n</code></pre><p>　　将这段代码放到&lt; /body&gt;标签之前。首先，这样可以确保JavaScript运行不会影响页面其它部分显示。其次，当第二部分 JavaScript 文件完成下载，所有应用程序所必须的 DOM 已经创建好了，并做好被访问的准备，避免使用额外的事件处理（例如 window.onload）来得知页面是否已经准备好了。</p>\n<blockquote>\n<p>也可以直接将loadScript函数嵌入在页面中，来避免另一次HTTP请求。</p>\n</blockquote>\n<p>　　如果你决定使用这种方法，建议你使用“YUI Compressor”(参见第 9 章)或者类似的工具将初始化脚本缩小到最小字节尺寸。一旦页面初始化代码下载完成，你还可以使用loadScript()函数加载页面所需的额外功能函数。</p>\n<p><strong>The YUI3 approach</strong><br>　　YUI 3 的核心设计理念为：用一个很小的初始代码，下载其余的功能代码。要在页面上使用YUI 3，首先包含 YUI 的种子文件.</p>\n<pre><code>&lt;script type=&quot;text/javascript&quot;\nsrc=http://yui.yahooapis.com/combo?3.0.0/build/yui/yui-min.js&gt;&lt;/script&gt;\n</code></pre><p>　　此种子文件大约 10KB（gzipped 压缩后 6KB）包含从 Yahoo! CDN 下载 YUI 组件所需的足够功能。举例来说，如果你想使用DOM功能，你可以指出它的名字（”dom”），传递给 YUI 的 use()函数，再提供一个回调函数，当代码准备好时这个回调函数将被调用</p>\n<pre><code>YUI().use(&quot;dom&quot;, function(Y){\n    Y.DOM.addClass(docment.body, &quot;loaded&quot;);\n})\n</code></pre><p><strong>The LazyLoad library</strong><br>　　作为一个更通用的工具，Yahoo! Search 的 Ryan Grove 创建了 LazyLoad 库（参见 <a href=\"http://github.com/rgrove/lazyload/）。LazyLoad\">http://github.com/rgrove/lazyload/）。LazyLoad</a> 是一个更强大的 loadScript()函数。LazyLoad 精缩之后只有大约 1.5KB（精缩，而不是用 gzip 压缩的）。lazyLoad可以下载多个JavaScript文件，并且能保证执行顺序，只需要LazyLoad.js()函数传递一个URL队列给它。但是仍应该尽可能的减少文件的数量。每次下载都是一个单独的HTTP请求。<br><strong>The LABjs library</strong><br>　　另一个非阻塞 JavaScript 加载库是 LABjs（<a href=\"http://labjs.com/），Kyle\">http://labjs.com/），Kyle</a> Simpson 写的一个开源库，由 Steve Souders 赞助。此库对加载过程进行更精细的控制，并尝试并行下载尽可能多的代码。LABjs 也相当小，只有 4.50KB（精缩，而不是用 gzip 压缩的），所以具有最小的页面代码尺寸。用法举例：</p>\n<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;lab.js&quot;&gt;&lt;/script&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n    $LAB.script(&quot;the-rest.js&quot;)\n        .wait(function(){\n        Application.init();\n    });\n&lt;/script&gt;\n</code></pre><p>　　$LAB.script()函数用于下载一个 JavaScript 文件，$LAB.wait()函数用于指出一个函数，该函数等待文件下载完成并运行之后才会被调用。LABjs 鼓励链操作，每个函数返回一个指向$LAB 对象的引用。要下载多个 JavaScript 文件，那么就链入另一个$LAB.script()调用</p>\n<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;lab.js&quot;&gt;&lt;/script&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n    $LAB.script(&quot;first-file.js&quot;)\n        .script(&quot;the-rest.js&quot;)\n        .wait(function(){\n            Application.init();\n        });\n&lt;/script&gt;\n</code></pre><p>　　LABjs 通过 wait()函数允许你指定哪些文件应该等待其他文件。在前面的例子中，first-file.js 的代码不保证在 the-rest.js 之前运行。为保证这一点，你必须在第一个 script()函数之后添加一个 wait()调用：</p>\n<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;lab.js&quot;&gt;&lt;/script&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n    $LAB.script(&quot;first-file.js&quot;).wait()\n        .script(&quot;the-rest.js&quot;)\n        .wait(function(){\n            Application.init();\n        });\n&lt;/script&gt;\n</code></pre><p>　　现在，first-file.js 的代码保证会在 the-rest.js 之前执行，虽然两个文件的内容是并行下载的。</p>\n<h1 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a><strong>总结：</strong></h1><hr>\n<p>　　JavaScript代码的执行会阻塞其它浏览器的处理过程，比如界面的绘制等。只要遇到&lt; script&gt;标签，页面就必须要等待JavaScript代码的下载（如果是外部的）和执行。这样会影响性能，可能会让浏览者对着空白的浏览器等待很久。通过这一章的学习，可以总结出集中减少JavaScript对性能的影响：</p>\n<blockquote>\n<ul>\n<li>1.将所有的&lt; script&gt;标签尽量放在页面底部，也就是&lt; /body&gt;之前。这样可以保证页面在脚本运行前完成解析。</li>\n<li>2.将脚本成组打包。&lt; script&gt;标签的数量越少，页面加载速度也就越快，响应也会加速（外部脚本和内联代码都适用）。</li>\n<li>3.用几种非阻塞方式下载JavaScript：<blockquote>\n<ul>\n<li>&lt; script&gt;标签加入defer(IE 及 Firefox3.5以上版本)。</li>\n<li>用 DOM 动态创建&lt; script&gt;元素，用它下载并执行代码。</li>\n<li>用 XHR 对象来下载代码，并注入页面中（需要同源）。</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<hr>\n<p><strong> <em>通过使用上述策略，你可以极大提高那些大量使用 JavaScript 代码的网页应用的实际性能。</em> </strong></p>"},{"title":"JavaScript 响应接口的优化","date":"2015-08-04T00:02:42.000Z","_content":"**第六章 Responsive Interfaces 响应接口**\n===\n<!--more-->\n---\n> - 浏览器在JavaScript运行上采取了限制：调用栈尺寸的限制和运行时间的限制。\n\t\n每种浏览器的行为大致相同。当脚本执行时，UI 不随用户交互而更新。此时 JavaScript 任务作为用户交互的结果被创建被放入队列，然后当原始JavaScript任务完成时队列中的任务被执行。用户交互导致的UI更新被自动跳过，因为优先考虑的是页面上的动态部分。因此，当一个脚本运行时点击一个按钮，将看不到它被按下的样子，即使它的 onclick 句柄被执行了。尽管浏览器尝试在这些情况下做一些符合逻辑的事情，但所有这些行为导致了一个间断的用户体验。因此最好的方法是，通过限制任何 JavaScript 任务在 100 毫秒或更少时间内完成，避免此类情况出现。这种\n测量应当在你要支持的最慢的浏览器上执行\n> - 解决上面的办法可以使用定时器来分割JavaScript运行的时间。使每部分JavaScript代码可以在100ms内完成。\n> - 定时器的延迟时间精度不准确，所以不能用定时器来判断精确的时间。\n> - 一种基本异步代码模式如下：\n\n\tvar todo = items.concat(); //create a clone of the original\n\tsetTimeout(function(){\n\t\t//get next item in the array and process it\n\t\tprocess(todo.shift());\n\t\t//if there's more items to process, create another timer\n\t\tif(todo.length > 0){\n\t\t\tsetTimeout(arguments.callee, 25);\n\t\t} else {\n\t\t\tcallback(items);\n\t\t}\n\t}, 25);\n\n下面封装此模式：\n\t\n\tfunction processArray(items, process, callback){\n\t\tvar todo = items.concat(); //create a clone of the original\n\t\tsetTimeout(function(){\n\t\t\tprocess(todo.shift());\n\t\t\tif (todo.length > 0){\n\t\t\t\tsetTimeout(arguments.callee, 25);\n\t\t\t} else {\n\t\t\t\tcallback(items);\n\t\t\t}\n\t\t}, 25);\n\t}\n\n> - 可通过原生的 Date 对象跟踪代码的运行时间。这是大多数 JavaScript 分析工具所采用的工作方式:\n\n\tvar start = +new Date(),\n\tstop;\n\tsomeLongProcess();\n\tstop = +new Date();\n\tif(stop-start < 50){\n\t\talert(\"Just about right.\");\n\t} else {\n\t\talert(\"Taking too long.\");\n\t}\n> - 定时器使你的 JavaScript 代码整体性能表现出巨大差异，但过度使用它们会对性能产生负面影响。同一时间只有一个定时器存在，只有当这个定时器结束时才创建一个新的定时器，以这种方式使用定时器不会带来性能问题。\n\n> - 工人线程在 UI 线程之外运行，这种阻塞不会影响 UI 响应。例如：\n\n\t//inside code.js\n\timportScripts(\"file1.js\", \"file2.js\");\n\tself.onmessage = function(event){\n\t\tself.postMessage(\"Hello, \" + event.data + \"!\");\n\t};\n\n> - 工人线程可以另以下任务受益：\n\n- 编/解码一个大字符串\n- 复杂数学运算（包括图像或视频处理）\n- 给一个大数组排序\n\n---\nSummary 总结\n===\n---\nJavaScript和用户界面更新在同一个进程内运行，同一时刻只有其中一个可以运行。 这意味着当JavaScript代码正在运行时，用户界面不能响应输入，反之亦然。有效地管理 UI 线程就是要确保 JavaScript 不能运行太长时间，以免影响用户体验。最后，请牢记如下几点：\n\n> - JavaScript 运行时间不应该超过 100 毫秒。过长的运行时间导致 UI 更新出现可察觉的延迟，从而对整体用户体验产生负面影响。\n> - JavaScript 运行期间，浏览器响应用户交互的行为存在差异。无论如何，JavaScript 长时间运行将导致用户体验混乱和脱节。\n> - 定时器可用于安排代码推迟执行，它使得你可以将长运行脚本分解成一系列较小的任务。\n> - 网页工人线程是新式浏览器才支持的特性，它允许你在 UI 线程之外运行 JavaScript 代码而避免锁定 UI。\n> - 网页应用程序越复杂，积极主动地管理 UI 线程就越显得重要。没有什么 JavaScript 代码可以重要到允许影响用户体验的程度。","source":"_posts/高性能JavaScript6.md","raw":"title: JavaScript 响应接口的优化\ndate: 2015-08-4 08:02:42\ntags: 高性能JavaScript学习笔记\ncategories: 高性能JavaScript-6\n---\n**第六章 Responsive Interfaces 响应接口**\n===\n<!--more-->\n---\n> - 浏览器在JavaScript运行上采取了限制：调用栈尺寸的限制和运行时间的限制。\n\t\n每种浏览器的行为大致相同。当脚本执行时，UI 不随用户交互而更新。此时 JavaScript 任务作为用户交互的结果被创建被放入队列，然后当原始JavaScript任务完成时队列中的任务被执行。用户交互导致的UI更新被自动跳过，因为优先考虑的是页面上的动态部分。因此，当一个脚本运行时点击一个按钮，将看不到它被按下的样子，即使它的 onclick 句柄被执行了。尽管浏览器尝试在这些情况下做一些符合逻辑的事情，但所有这些行为导致了一个间断的用户体验。因此最好的方法是，通过限制任何 JavaScript 任务在 100 毫秒或更少时间内完成，避免此类情况出现。这种\n测量应当在你要支持的最慢的浏览器上执行\n> - 解决上面的办法可以使用定时器来分割JavaScript运行的时间。使每部分JavaScript代码可以在100ms内完成。\n> - 定时器的延迟时间精度不准确，所以不能用定时器来判断精确的时间。\n> - 一种基本异步代码模式如下：\n\n\tvar todo = items.concat(); //create a clone of the original\n\tsetTimeout(function(){\n\t\t//get next item in the array and process it\n\t\tprocess(todo.shift());\n\t\t//if there's more items to process, create another timer\n\t\tif(todo.length > 0){\n\t\t\tsetTimeout(arguments.callee, 25);\n\t\t} else {\n\t\t\tcallback(items);\n\t\t}\n\t}, 25);\n\n下面封装此模式：\n\t\n\tfunction processArray(items, process, callback){\n\t\tvar todo = items.concat(); //create a clone of the original\n\t\tsetTimeout(function(){\n\t\t\tprocess(todo.shift());\n\t\t\tif (todo.length > 0){\n\t\t\t\tsetTimeout(arguments.callee, 25);\n\t\t\t} else {\n\t\t\t\tcallback(items);\n\t\t\t}\n\t\t}, 25);\n\t}\n\n> - 可通过原生的 Date 对象跟踪代码的运行时间。这是大多数 JavaScript 分析工具所采用的工作方式:\n\n\tvar start = +new Date(),\n\tstop;\n\tsomeLongProcess();\n\tstop = +new Date();\n\tif(stop-start < 50){\n\t\talert(\"Just about right.\");\n\t} else {\n\t\talert(\"Taking too long.\");\n\t}\n> - 定时器使你的 JavaScript 代码整体性能表现出巨大差异，但过度使用它们会对性能产生负面影响。同一时间只有一个定时器存在，只有当这个定时器结束时才创建一个新的定时器，以这种方式使用定时器不会带来性能问题。\n\n> - 工人线程在 UI 线程之外运行，这种阻塞不会影响 UI 响应。例如：\n\n\t//inside code.js\n\timportScripts(\"file1.js\", \"file2.js\");\n\tself.onmessage = function(event){\n\t\tself.postMessage(\"Hello, \" + event.data + \"!\");\n\t};\n\n> - 工人线程可以另以下任务受益：\n\n- 编/解码一个大字符串\n- 复杂数学运算（包括图像或视频处理）\n- 给一个大数组排序\n\n---\nSummary 总结\n===\n---\nJavaScript和用户界面更新在同一个进程内运行，同一时刻只有其中一个可以运行。 这意味着当JavaScript代码正在运行时，用户界面不能响应输入，反之亦然。有效地管理 UI 线程就是要确保 JavaScript 不能运行太长时间，以免影响用户体验。最后，请牢记如下几点：\n\n> - JavaScript 运行时间不应该超过 100 毫秒。过长的运行时间导致 UI 更新出现可察觉的延迟，从而对整体用户体验产生负面影响。\n> - JavaScript 运行期间，浏览器响应用户交互的行为存在差异。无论如何，JavaScript 长时间运行将导致用户体验混乱和脱节。\n> - 定时器可用于安排代码推迟执行，它使得你可以将长运行脚本分解成一系列较小的任务。\n> - 网页工人线程是新式浏览器才支持的特性，它允许你在 UI 线程之外运行 JavaScript 代码而避免锁定 UI。\n> - 网页应用程序越复杂，积极主动地管理 UI 线程就越显得重要。没有什么 JavaScript 代码可以重要到允许影响用户体验的程度。","slug":"高性能JavaScript6","published":1,"updated":"2016-10-31T07:25:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciuyzluuo0018e6tbkzbk1tjk","content":"<h1 id=\"第六章-Responsive-Interfaces-响应接口\"><a href=\"#第六章-Responsive-Interfaces-响应接口\" class=\"headerlink\" title=\"第六章 Responsive Interfaces 响应接口\"></a><strong>第六章 Responsive Interfaces 响应接口</strong></h1><h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><a id=\"more\"></a></h2><blockquote>\n<ul>\n<li>浏览器在JavaScript运行上采取了限制：调用栈尺寸的限制和运行时间的限制。</li>\n</ul>\n</blockquote>\n<p>每种浏览器的行为大致相同。当脚本执行时，UI 不随用户交互而更新。此时 JavaScript 任务作为用户交互的结果被创建被放入队列，然后当原始JavaScript任务完成时队列中的任务被执行。用户交互导致的UI更新被自动跳过，因为优先考虑的是页面上的动态部分。因此，当一个脚本运行时点击一个按钮，将看不到它被按下的样子，即使它的 onclick 句柄被执行了。尽管浏览器尝试在这些情况下做一些符合逻辑的事情，但所有这些行为导致了一个间断的用户体验。因此最好的方法是，通过限制任何 JavaScript 任务在 100 毫秒或更少时间内完成，避免此类情况出现。这种<br>测量应当在你要支持的最慢的浏览器上执行</p>\n<blockquote>\n<ul>\n<li>解决上面的办法可以使用定时器来分割JavaScript运行的时间。使每部分JavaScript代码可以在100ms内完成。</li>\n<li>定时器的延迟时间精度不准确，所以不能用定时器来判断精确的时间。</li>\n<li>一种基本异步代码模式如下：</li>\n</ul>\n</blockquote>\n<pre><code>var todo = items.concat(); //create a clone of the original\nsetTimeout(function(){\n    //get next item in the array and process it\n    process(todo.shift());\n    //if there&apos;s more items to process, create another timer\n    if(todo.length &gt; 0){\n        setTimeout(arguments.callee, 25);\n    } else {\n        callback(items);\n    }\n}, 25);\n</code></pre><p>下面封装此模式：</p>\n<pre><code>function processArray(items, process, callback){\n    var todo = items.concat(); //create a clone of the original\n    setTimeout(function(){\n        process(todo.shift());\n        if (todo.length &gt; 0){\n            setTimeout(arguments.callee, 25);\n        } else {\n            callback(items);\n        }\n    }, 25);\n}\n</code></pre><blockquote>\n<ul>\n<li>可通过原生的 Date 对象跟踪代码的运行时间。这是大多数 JavaScript 分析工具所采用的工作方式:</li>\n</ul>\n</blockquote>\n<pre><code>var start = +new Date(),\nstop;\nsomeLongProcess();\nstop = +new Date();\nif(stop-start &lt; 50){\n    alert(&quot;Just about right.&quot;);\n} else {\n    alert(&quot;Taking too long.&quot;);\n}\n</code></pre><blockquote>\n<ul>\n<li><p>定时器使你的 JavaScript 代码整体性能表现出巨大差异，但过度使用它们会对性能产生负面影响。同一时间只有一个定时器存在，只有当这个定时器结束时才创建一个新的定时器，以这种方式使用定时器不会带来性能问题。</p>\n</li>\n<li><p>工人线程在 UI 线程之外运行，这种阻塞不会影响 UI 响应。例如：</p>\n</li>\n</ul>\n</blockquote>\n<pre><code>//inside code.js\nimportScripts(&quot;file1.js&quot;, &quot;file2.js&quot;);\nself.onmessage = function(event){\n    self.postMessage(&quot;Hello, &quot; + event.data + &quot;!&quot;);\n};\n</code></pre><blockquote>\n<ul>\n<li>工人线程可以另以下任务受益：</li>\n</ul>\n</blockquote>\n<ul>\n<li>编/解码一个大字符串</li>\n<li>复杂数学运算（包括图像或视频处理）</li>\n<li>给一个大数组排序</li>\n</ul>\n<hr>\n<h1 id=\"Summary-总结\"><a href=\"#Summary-总结\" class=\"headerlink\" title=\"Summary 总结\"></a>Summary 总结</h1><hr>\n<p>JavaScript和用户界面更新在同一个进程内运行，同一时刻只有其中一个可以运行。 这意味着当JavaScript代码正在运行时，用户界面不能响应输入，反之亦然。有效地管理 UI 线程就是要确保 JavaScript 不能运行太长时间，以免影响用户体验。最后，请牢记如下几点：</p>\n<blockquote>\n<ul>\n<li>JavaScript 运行时间不应该超过 100 毫秒。过长的运行时间导致 UI 更新出现可察觉的延迟，从而对整体用户体验产生负面影响。</li>\n<li>JavaScript 运行期间，浏览器响应用户交互的行为存在差异。无论如何，JavaScript 长时间运行将导致用户体验混乱和脱节。</li>\n<li>定时器可用于安排代码推迟执行，它使得你可以将长运行脚本分解成一系列较小的任务。</li>\n<li>网页工人线程是新式浏览器才支持的特性，它允许你在 UI 线程之外运行 JavaScript 代码而避免锁定 UI。</li>\n<li>网页应用程序越复杂，积极主动地管理 UI 线程就越显得重要。没有什么 JavaScript 代码可以重要到允许影响用户体验的程度。</li>\n</ul>\n</blockquote>\n","excerpt":"<h1 id=\"第六章-Responsive-Interfaces-响应接口\"><a href=\"#第六章-Responsive-Interfaces-响应接口\" class=\"headerlink\" title=\"第六章 Responsive Interfaces 响应接口\"></a><strong>第六章 Responsive Interfaces 响应接口</strong></h1><h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a>","more":"</h2><blockquote>\n<ul>\n<li>浏览器在JavaScript运行上采取了限制：调用栈尺寸的限制和运行时间的限制。</li>\n</ul>\n</blockquote>\n<p>每种浏览器的行为大致相同。当脚本执行时，UI 不随用户交互而更新。此时 JavaScript 任务作为用户交互的结果被创建被放入队列，然后当原始JavaScript任务完成时队列中的任务被执行。用户交互导致的UI更新被自动跳过，因为优先考虑的是页面上的动态部分。因此，当一个脚本运行时点击一个按钮，将看不到它被按下的样子，即使它的 onclick 句柄被执行了。尽管浏览器尝试在这些情况下做一些符合逻辑的事情，但所有这些行为导致了一个间断的用户体验。因此最好的方法是，通过限制任何 JavaScript 任务在 100 毫秒或更少时间内完成，避免此类情况出现。这种<br>测量应当在你要支持的最慢的浏览器上执行</p>\n<blockquote>\n<ul>\n<li>解决上面的办法可以使用定时器来分割JavaScript运行的时间。使每部分JavaScript代码可以在100ms内完成。</li>\n<li>定时器的延迟时间精度不准确，所以不能用定时器来判断精确的时间。</li>\n<li>一种基本异步代码模式如下：</li>\n</ul>\n</blockquote>\n<pre><code>var todo = items.concat(); //create a clone of the original\nsetTimeout(function(){\n    //get next item in the array and process it\n    process(todo.shift());\n    //if there&apos;s more items to process, create another timer\n    if(todo.length &gt; 0){\n        setTimeout(arguments.callee, 25);\n    } else {\n        callback(items);\n    }\n}, 25);\n</code></pre><p>下面封装此模式：</p>\n<pre><code>function processArray(items, process, callback){\n    var todo = items.concat(); //create a clone of the original\n    setTimeout(function(){\n        process(todo.shift());\n        if (todo.length &gt; 0){\n            setTimeout(arguments.callee, 25);\n        } else {\n            callback(items);\n        }\n    }, 25);\n}\n</code></pre><blockquote>\n<ul>\n<li>可通过原生的 Date 对象跟踪代码的运行时间。这是大多数 JavaScript 分析工具所采用的工作方式:</li>\n</ul>\n</blockquote>\n<pre><code>var start = +new Date(),\nstop;\nsomeLongProcess();\nstop = +new Date();\nif(stop-start &lt; 50){\n    alert(&quot;Just about right.&quot;);\n} else {\n    alert(&quot;Taking too long.&quot;);\n}\n</code></pre><blockquote>\n<ul>\n<li><p>定时器使你的 JavaScript 代码整体性能表现出巨大差异，但过度使用它们会对性能产生负面影响。同一时间只有一个定时器存在，只有当这个定时器结束时才创建一个新的定时器，以这种方式使用定时器不会带来性能问题。</p>\n</li>\n<li><p>工人线程在 UI 线程之外运行，这种阻塞不会影响 UI 响应。例如：</p>\n</li>\n</ul>\n</blockquote>\n<pre><code>//inside code.js\nimportScripts(&quot;file1.js&quot;, &quot;file2.js&quot;);\nself.onmessage = function(event){\n    self.postMessage(&quot;Hello, &quot; + event.data + &quot;!&quot;);\n};\n</code></pre><blockquote>\n<ul>\n<li>工人线程可以另以下任务受益：</li>\n</ul>\n</blockquote>\n<ul>\n<li>编/解码一个大字符串</li>\n<li>复杂数学运算（包括图像或视频处理）</li>\n<li>给一个大数组排序</li>\n</ul>\n<hr>\n<h1 id=\"Summary-总结\"><a href=\"#Summary-总结\" class=\"headerlink\" title=\"Summary 总结\"></a>Summary 总结</h1><hr>\n<p>JavaScript和用户界面更新在同一个进程内运行，同一时刻只有其中一个可以运行。 这意味着当JavaScript代码正在运行时，用户界面不能响应输入，反之亦然。有效地管理 UI 线程就是要确保 JavaScript 不能运行太长时间，以免影响用户体验。最后，请牢记如下几点：</p>\n<blockquote>\n<ul>\n<li>JavaScript 运行时间不应该超过 100 毫秒。过长的运行时间导致 UI 更新出现可察觉的延迟，从而对整体用户体验产生负面影响。</li>\n<li>JavaScript 运行期间，浏览器响应用户交互的行为存在差异。无论如何，JavaScript 长时间运行将导致用户体验混乱和脱节。</li>\n<li>定时器可用于安排代码推迟执行，它使得你可以将长运行脚本分解成一系列较小的任务。</li>\n<li>网页工人线程是新式浏览器才支持的特性，它允许你在 UI 线程之外运行 JavaScript 代码而避免锁定 UI。</li>\n<li>网页应用程序越复杂，积极主动地管理 UI 线程就越显得重要。没有什么 JavaScript 代码可以重要到允许影响用户体验的程度。</li>\n</ul>\n</blockquote>"},{"title":"JavaScript Ajax优化","date":"2015-08-04T06:42:31.000Z","_content":"**第七章 Ajax 异步 JavaScript 和 XML**\n===\n<!--more-->\n---\n> - 向服务器请求数据的五种常用技术：\n\n- XMLHttpRequest (XHR)\n- Dynamic script tag insertion 动态脚本标签插入\n- iframes\n- Comet\n- Multipart XHR 多部分的 XHR\n\n在现代高性能 JavaScript 中使用的三种技术是 XHR，动态脚本标签插入和多部分的 XHR。\n\n> - 由于 XHR 提供了高级别的控制，浏览器在上面增加了一些限制。你不能使用 XHR 从当前运行的代码域之外请求数据，而且老版本的 IE 也不提供 readyState 3，它不支持流。从请求返回的数据像一个字符串或者一个 XML 对象那样对待，这意味着处理大量数据将相当缓慢。尽管有这些缺点，XHR 仍旧是最常用的请求数据技术，也是最强大的。它应当成为你的首选。\n\n> - GET请求在IE中有长度限制，只有当URL和参数的长度超过了2048个字符时才能使用POST提取数据。\n\n---\n> - 动态脚本标签插入克服了XHR最大的限制——同源。它可以从不同的服务器上获取数据，但是因此，它也是不安全的，包括修改任何内容、将用户重定向到另一个站点，或跟踪他们在页面上的操作并将数据发送给第三方。\n\n\tvar scriptElement = document.createElement('script');\n\tscriptElement.src = 'http://any-domain.com/javascript/lib.js';\n\tdocument.getElementsByTagName_r('head')[0].appendChild(scriptElement);\n> - 多部分的XHR（MXHR）允许你只用一个 HTTP 请求就可以从服务器端获取多个资源。\n\n---\n> - 当数据只需发送给服务器时，有两种广泛应用的技术：XHR 和灯标。\n\n虽然 XHR 主要用于从服务器获取数据， 它也可以用来将数据发回。 数据可以用 GET 或 POST 方式发回，以及任意数量的 HTTP 信息头。这给你很大灵活性。当你向服务器发回的数据量超过浏览器的最大 URL\n长度时 XHR 特别有用。这种情况下，你可以用 POST 方式发回数据：\n\n\tvar url = '/data.php';\n\tvar params = [\n\t'id=934875',\n\t'limit=20'\n\t];\n\tvar req = new XMLHttpRequest();\n\treq.onerror = function() {\n\t\t// Error.\n\t};\n\treq.onreadystatechange = function() {\n\t\tif (req.readyState == 4) {\n\t\t\t// Success.\n\t\t}\n\t};\n\treq.open('POST', url, true);\n\treq.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n\treq.setRequestHeader('Content-Length', params.length);\n\treq.send(params.join('&'));\n\n> - 灯标是向服务器回送数据最快和最有效的方法。服务器根本不需要发回任何响应正文，所以你不必担心客户端下载数据。唯一的缺点是接收到的响应类型是受限的。如果你需要向客户端返回大量数据，那么使用 XHR。如果你只关心将数据发送到服务器端（可能需要极少的回复），那么使用图像灯标。\n\n---\n> - XML 与 JSON 相比显得非常冗杂。而且 JSON 在JavaScript可以直接简单的使用();\n\n> 当使用 XHR 时 JSON 数据作为一个字符串返回。\n该字符串使用()转换为一个本地对象。然而，当使用动态脚本标签插入时，JSON 数据被视为另一个JavaScript 文件并作为本地码执行。为做到这一点，数据必须被包装在回调函数之中。这就是所谓的“JSON填充”或 JSON-P。下面是我们用 JSON-P 格式书写的用户列表：\n\n\tparseJSON([\n\t\t{\"id\":1, \"username\":\"alice\", \"realname\":\"Alice Smith\", \"email\":\"alice@alicesmith.com\"},\n\t\t{\"id\":2, \"username\":\"bob\", \"realname\":\"Bob Jones\", \"email\":\"bob@bobjones.com\"},\n\t\t{\"id\":3, \"username\":\"carol\", \"realname\":\"Carol Williams\", \"email\":\"carol@carolwilliams.com\"},\n\t\t{\"id\":4, \"username\":\"dave\", \"realname\":\"Dave Johnson\", \"email\":\"dave@davejohnson.com\"}\n\t]);\n　　最快的 JSON 格式是使用数组的 JSON-P 格式。虽然这只比使用 XHR 的 JSON 略快，但是这种差异随着列表尺寸的增大而增大。 如果你所从事的项目需要一个10'000或100'000个单元构成的列表， 那么JSON-P 比 JSON 好很多。\n　　JSON-P 必须是可执行的 JavaScript，它使用动态\n脚本标签注入技术可在任何网站中被任何人调用。从另一个角度说，JSON 在运行之前并不是有效的\nJavaScript，使用 XHR 时只是被当作字符串获取。不要将任何敏感的数据编码为 JSON-P，因为你无法确定它是否包含私密信息，或者包含随机的 URL 或 cookie。\n\n---\nSummary 总结\n===\n---\n高性能 Ajax 包括：知道你项目的具体需求，选择正确的数据格式和与之相配的传输技术。\n\n> - 作为数据格式，纯文本和 HTML 是高度限制的，但它们可节省客户端的 CPU 周期。XML 被广泛应用普遍支持，但它非常冗长且解析缓慢。JSON 是轻量级的，解析迅速。字符分隔的自定义格式非常轻量，在大量数据集解析时速度最快，但需要编写额外的程序在服务器端构造格式，并在客户端解析。\n> - 减少请求数量，可通过 JavaScript 和 CSS 文件打包，或者使用 MXHR。\n> - 缩短页面的加载时间，在页面其它内容加载之后，使用 Ajax 获取少量重要文件。\n> - 确保代码错误不要直接显示给用户，并在服务器端处理错误。\n> - 学会何时使用一个健壮的 Ajax 库，何时编写自己的底层 Ajax 代码。\n\n---\nAjax 是提升你网站潜在性能之最大的改进区域之一，因为很多网站大量使用异步请求，又因为它提供\n了许多不相关问题的解决方案，这些问题诸如，需要加载太多资源。对 XHR 的创造性应用是如此的与众不同，它不是呆滞不友好的界面，而是响应迅速且高效的代名词；它不会引起用户的憎恨，谁见了它都会爱上它。\n","source":"_posts/高性能JavaScript7.md","raw":"title: JavaScript Ajax优化\ndate: 2015-08-4 14:42:31\ntags: 高性能JavaScript学习笔记\ncategories: 高性能JavaScript-7\n---\n**第七章 Ajax 异步 JavaScript 和 XML**\n===\n<!--more-->\n---\n> - 向服务器请求数据的五种常用技术：\n\n- XMLHttpRequest (XHR)\n- Dynamic script tag insertion 动态脚本标签插入\n- iframes\n- Comet\n- Multipart XHR 多部分的 XHR\n\n在现代高性能 JavaScript 中使用的三种技术是 XHR，动态脚本标签插入和多部分的 XHR。\n\n> - 由于 XHR 提供了高级别的控制，浏览器在上面增加了一些限制。你不能使用 XHR 从当前运行的代码域之外请求数据，而且老版本的 IE 也不提供 readyState 3，它不支持流。从请求返回的数据像一个字符串或者一个 XML 对象那样对待，这意味着处理大量数据将相当缓慢。尽管有这些缺点，XHR 仍旧是最常用的请求数据技术，也是最强大的。它应当成为你的首选。\n\n> - GET请求在IE中有长度限制，只有当URL和参数的长度超过了2048个字符时才能使用POST提取数据。\n\n---\n> - 动态脚本标签插入克服了XHR最大的限制——同源。它可以从不同的服务器上获取数据，但是因此，它也是不安全的，包括修改任何内容、将用户重定向到另一个站点，或跟踪他们在页面上的操作并将数据发送给第三方。\n\n\tvar scriptElement = document.createElement('script');\n\tscriptElement.src = 'http://any-domain.com/javascript/lib.js';\n\tdocument.getElementsByTagName_r('head')[0].appendChild(scriptElement);\n> - 多部分的XHR（MXHR）允许你只用一个 HTTP 请求就可以从服务器端获取多个资源。\n\n---\n> - 当数据只需发送给服务器时，有两种广泛应用的技术：XHR 和灯标。\n\n虽然 XHR 主要用于从服务器获取数据， 它也可以用来将数据发回。 数据可以用 GET 或 POST 方式发回，以及任意数量的 HTTP 信息头。这给你很大灵活性。当你向服务器发回的数据量超过浏览器的最大 URL\n长度时 XHR 特别有用。这种情况下，你可以用 POST 方式发回数据：\n\n\tvar url = '/data.php';\n\tvar params = [\n\t'id=934875',\n\t'limit=20'\n\t];\n\tvar req = new XMLHttpRequest();\n\treq.onerror = function() {\n\t\t// Error.\n\t};\n\treq.onreadystatechange = function() {\n\t\tif (req.readyState == 4) {\n\t\t\t// Success.\n\t\t}\n\t};\n\treq.open('POST', url, true);\n\treq.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n\treq.setRequestHeader('Content-Length', params.length);\n\treq.send(params.join('&'));\n\n> - 灯标是向服务器回送数据最快和最有效的方法。服务器根本不需要发回任何响应正文，所以你不必担心客户端下载数据。唯一的缺点是接收到的响应类型是受限的。如果你需要向客户端返回大量数据，那么使用 XHR。如果你只关心将数据发送到服务器端（可能需要极少的回复），那么使用图像灯标。\n\n---\n> - XML 与 JSON 相比显得非常冗杂。而且 JSON 在JavaScript可以直接简单的使用();\n\n> 当使用 XHR 时 JSON 数据作为一个字符串返回。\n该字符串使用()转换为一个本地对象。然而，当使用动态脚本标签插入时，JSON 数据被视为另一个JavaScript 文件并作为本地码执行。为做到这一点，数据必须被包装在回调函数之中。这就是所谓的“JSON填充”或 JSON-P。下面是我们用 JSON-P 格式书写的用户列表：\n\n\tparseJSON([\n\t\t{\"id\":1, \"username\":\"alice\", \"realname\":\"Alice Smith\", \"email\":\"alice@alicesmith.com\"},\n\t\t{\"id\":2, \"username\":\"bob\", \"realname\":\"Bob Jones\", \"email\":\"bob@bobjones.com\"},\n\t\t{\"id\":3, \"username\":\"carol\", \"realname\":\"Carol Williams\", \"email\":\"carol@carolwilliams.com\"},\n\t\t{\"id\":4, \"username\":\"dave\", \"realname\":\"Dave Johnson\", \"email\":\"dave@davejohnson.com\"}\n\t]);\n　　最快的 JSON 格式是使用数组的 JSON-P 格式。虽然这只比使用 XHR 的 JSON 略快，但是这种差异随着列表尺寸的增大而增大。 如果你所从事的项目需要一个10'000或100'000个单元构成的列表， 那么JSON-P 比 JSON 好很多。\n　　JSON-P 必须是可执行的 JavaScript，它使用动态\n脚本标签注入技术可在任何网站中被任何人调用。从另一个角度说，JSON 在运行之前并不是有效的\nJavaScript，使用 XHR 时只是被当作字符串获取。不要将任何敏感的数据编码为 JSON-P，因为你无法确定它是否包含私密信息，或者包含随机的 URL 或 cookie。\n\n---\nSummary 总结\n===\n---\n高性能 Ajax 包括：知道你项目的具体需求，选择正确的数据格式和与之相配的传输技术。\n\n> - 作为数据格式，纯文本和 HTML 是高度限制的，但它们可节省客户端的 CPU 周期。XML 被广泛应用普遍支持，但它非常冗长且解析缓慢。JSON 是轻量级的，解析迅速。字符分隔的自定义格式非常轻量，在大量数据集解析时速度最快，但需要编写额外的程序在服务器端构造格式，并在客户端解析。\n> - 减少请求数量，可通过 JavaScript 和 CSS 文件打包，或者使用 MXHR。\n> - 缩短页面的加载时间，在页面其它内容加载之后，使用 Ajax 获取少量重要文件。\n> - 确保代码错误不要直接显示给用户，并在服务器端处理错误。\n> - 学会何时使用一个健壮的 Ajax 库，何时编写自己的底层 Ajax 代码。\n\n---\nAjax 是提升你网站潜在性能之最大的改进区域之一，因为很多网站大量使用异步请求，又因为它提供\n了许多不相关问题的解决方案，这些问题诸如，需要加载太多资源。对 XHR 的创造性应用是如此的与众不同，它不是呆滞不友好的界面，而是响应迅速且高效的代名词；它不会引起用户的憎恨，谁见了它都会爱上它。\n","slug":"高性能JavaScript7","published":1,"updated":"2016-10-31T07:25:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciuyzluus001be6tbdwtlvx3w","content":"<h1 id=\"第七章-Ajax-异步-JavaScript-和-XML\"><a href=\"#第七章-Ajax-异步-JavaScript-和-XML\" class=\"headerlink\" title=\"第七章 Ajax 异步 JavaScript 和 XML\"></a><strong>第七章 Ajax 异步 JavaScript 和 XML</strong></h1><h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><a id=\"more\"></a></h2><blockquote>\n<ul>\n<li>向服务器请求数据的五种常用技术：</li>\n</ul>\n</blockquote>\n<ul>\n<li>XMLHttpRequest (XHR)</li>\n<li>Dynamic script tag insertion 动态脚本标签插入</li>\n<li>iframes</li>\n<li>Comet</li>\n<li>Multipart XHR 多部分的 XHR</li>\n</ul>\n<p>在现代高性能 JavaScript 中使用的三种技术是 XHR，动态脚本标签插入和多部分的 XHR。</p>\n<blockquote>\n<ul>\n<li><p>由于 XHR 提供了高级别的控制，浏览器在上面增加了一些限制。你不能使用 XHR 从当前运行的代码域之外请求数据，而且老版本的 IE 也不提供 readyState 3，它不支持流。从请求返回的数据像一个字符串或者一个 XML 对象那样对待，这意味着处理大量数据将相当缓慢。尽管有这些缺点，XHR 仍旧是最常用的请求数据技术，也是最强大的。它应当成为你的首选。</p>\n</li>\n<li><p>GET请求在IE中有长度限制，只有当URL和参数的长度超过了2048个字符时才能使用POST提取数据。</p>\n</li>\n</ul>\n</blockquote>\n<hr>\n<blockquote>\n<ul>\n<li>动态脚本标签插入克服了XHR最大的限制——同源。它可以从不同的服务器上获取数据，但是因此，它也是不安全的，包括修改任何内容、将用户重定向到另一个站点，或跟踪他们在页面上的操作并将数据发送给第三方。</li>\n</ul>\n</blockquote>\n<pre><code>var scriptElement = document.createElement(&apos;script&apos;);\nscriptElement.src = &apos;http://any-domain.com/javascript/lib.js&apos;;\ndocument.getElementsByTagName_r(&apos;head&apos;)[0].appendChild(scriptElement);\n</code></pre><blockquote>\n<ul>\n<li>多部分的XHR（MXHR）允许你只用一个 HTTP 请求就可以从服务器端获取多个资源。</li>\n</ul>\n</blockquote>\n<hr>\n<blockquote>\n<ul>\n<li>当数据只需发送给服务器时，有两种广泛应用的技术：XHR 和灯标。</li>\n</ul>\n</blockquote>\n<p>虽然 XHR 主要用于从服务器获取数据， 它也可以用来将数据发回。 数据可以用 GET 或 POST 方式发回，以及任意数量的 HTTP 信息头。这给你很大灵活性。当你向服务器发回的数据量超过浏览器的最大 URL<br>长度时 XHR 特别有用。这种情况下，你可以用 POST 方式发回数据：</p>\n<pre><code>var url = &apos;/data.php&apos;;\nvar params = [\n&apos;id=934875&apos;,\n&apos;limit=20&apos;\n];\nvar req = new XMLHttpRequest();\nreq.onerror = function() {\n    // Error.\n};\nreq.onreadystatechange = function() {\n    if (req.readyState == 4) {\n        // Success.\n    }\n};\nreq.open(&apos;POST&apos;, url, true);\nreq.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;);\nreq.setRequestHeader(&apos;Content-Length&apos;, params.length);\nreq.send(params.join(&apos;&amp;&apos;));\n</code></pre><blockquote>\n<ul>\n<li>灯标是向服务器回送数据最快和最有效的方法。服务器根本不需要发回任何响应正文，所以你不必担心客户端下载数据。唯一的缺点是接收到的响应类型是受限的。如果你需要向客户端返回大量数据，那么使用 XHR。如果你只关心将数据发送到服务器端（可能需要极少的回复），那么使用图像灯标。</li>\n</ul>\n</blockquote>\n<hr>\n<blockquote>\n<ul>\n<li>XML 与 JSON 相比显得非常冗杂。而且 JSON 在JavaScript可以直接简单的使用();</li>\n</ul>\n<p>当使用 XHR 时 JSON 数据作为一个字符串返回。<br>该字符串使用()转换为一个本地对象。然而，当使用动态脚本标签插入时，JSON 数据被视为另一个JavaScript 文件并作为本地码执行。为做到这一点，数据必须被包装在回调函数之中。这就是所谓的“JSON填充”或 JSON-P。下面是我们用 JSON-P 格式书写的用户列表：</p>\n</blockquote>\n<pre><code>parseJSON([\n    {&quot;id&quot;:1, &quot;username&quot;:&quot;alice&quot;, &quot;realname&quot;:&quot;Alice Smith&quot;, &quot;email&quot;:&quot;alice@alicesmith.com&quot;},\n    {&quot;id&quot;:2, &quot;username&quot;:&quot;bob&quot;, &quot;realname&quot;:&quot;Bob Jones&quot;, &quot;email&quot;:&quot;bob@bobjones.com&quot;},\n    {&quot;id&quot;:3, &quot;username&quot;:&quot;carol&quot;, &quot;realname&quot;:&quot;Carol Williams&quot;, &quot;email&quot;:&quot;carol@carolwilliams.com&quot;},\n    {&quot;id&quot;:4, &quot;username&quot;:&quot;dave&quot;, &quot;realname&quot;:&quot;Dave Johnson&quot;, &quot;email&quot;:&quot;dave@davejohnson.com&quot;}\n]);\n</code></pre><p>　　最快的 JSON 格式是使用数组的 JSON-P 格式。虽然这只比使用 XHR 的 JSON 略快，但是这种差异随着列表尺寸的增大而增大。 如果你所从事的项目需要一个10’000或100’000个单元构成的列表， 那么JSON-P 比 JSON 好很多。<br>　　JSON-P 必须是可执行的 JavaScript，它使用动态<br>脚本标签注入技术可在任何网站中被任何人调用。从另一个角度说，JSON 在运行之前并不是有效的<br>JavaScript，使用 XHR 时只是被当作字符串获取。不要将任何敏感的数据编码为 JSON-P，因为你无法确定它是否包含私密信息，或者包含随机的 URL 或 cookie。</p>\n<hr>\n<h1 id=\"Summary-总结\"><a href=\"#Summary-总结\" class=\"headerlink\" title=\"Summary 总结\"></a>Summary 总结</h1><hr>\n<p>高性能 Ajax 包括：知道你项目的具体需求，选择正确的数据格式和与之相配的传输技术。</p>\n<blockquote>\n<ul>\n<li>作为数据格式，纯文本和 HTML 是高度限制的，但它们可节省客户端的 CPU 周期。XML 被广泛应用普遍支持，但它非常冗长且解析缓慢。JSON 是轻量级的，解析迅速。字符分隔的自定义格式非常轻量，在大量数据集解析时速度最快，但需要编写额外的程序在服务器端构造格式，并在客户端解析。</li>\n<li>减少请求数量，可通过 JavaScript 和 CSS 文件打包，或者使用 MXHR。</li>\n<li>缩短页面的加载时间，在页面其它内容加载之后，使用 Ajax 获取少量重要文件。</li>\n<li>确保代码错误不要直接显示给用户，并在服务器端处理错误。</li>\n<li>学会何时使用一个健壮的 Ajax 库，何时编写自己的底层 Ajax 代码。</li>\n</ul>\n</blockquote>\n<hr>\n<p>Ajax 是提升你网站潜在性能之最大的改进区域之一，因为很多网站大量使用异步请求，又因为它提供<br>了许多不相关问题的解决方案，这些问题诸如，需要加载太多资源。对 XHR 的创造性应用是如此的与众不同，它不是呆滞不友好的界面，而是响应迅速且高效的代名词；它不会引起用户的憎恨，谁见了它都会爱上它。</p>\n","excerpt":"<h1 id=\"第七章-Ajax-异步-JavaScript-和-XML\"><a href=\"#第七章-Ajax-异步-JavaScript-和-XML\" class=\"headerlink\" title=\"第七章 Ajax 异步 JavaScript 和 XML\"></a><strong>第七章 Ajax 异步 JavaScript 和 XML</strong></h1><h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a>","more":"</h2><blockquote>\n<ul>\n<li>向服务器请求数据的五种常用技术：</li>\n</ul>\n</blockquote>\n<ul>\n<li>XMLHttpRequest (XHR)</li>\n<li>Dynamic script tag insertion 动态脚本标签插入</li>\n<li>iframes</li>\n<li>Comet</li>\n<li>Multipart XHR 多部分的 XHR</li>\n</ul>\n<p>在现代高性能 JavaScript 中使用的三种技术是 XHR，动态脚本标签插入和多部分的 XHR。</p>\n<blockquote>\n<ul>\n<li><p>由于 XHR 提供了高级别的控制，浏览器在上面增加了一些限制。你不能使用 XHR 从当前运行的代码域之外请求数据，而且老版本的 IE 也不提供 readyState 3，它不支持流。从请求返回的数据像一个字符串或者一个 XML 对象那样对待，这意味着处理大量数据将相当缓慢。尽管有这些缺点，XHR 仍旧是最常用的请求数据技术，也是最强大的。它应当成为你的首选。</p>\n</li>\n<li><p>GET请求在IE中有长度限制，只有当URL和参数的长度超过了2048个字符时才能使用POST提取数据。</p>\n</li>\n</ul>\n</blockquote>\n<hr>\n<blockquote>\n<ul>\n<li>动态脚本标签插入克服了XHR最大的限制——同源。它可以从不同的服务器上获取数据，但是因此，它也是不安全的，包括修改任何内容、将用户重定向到另一个站点，或跟踪他们在页面上的操作并将数据发送给第三方。</li>\n</ul>\n</blockquote>\n<pre><code>var scriptElement = document.createElement(&apos;script&apos;);\nscriptElement.src = &apos;http://any-domain.com/javascript/lib.js&apos;;\ndocument.getElementsByTagName_r(&apos;head&apos;)[0].appendChild(scriptElement);\n</code></pre><blockquote>\n<ul>\n<li>多部分的XHR（MXHR）允许你只用一个 HTTP 请求就可以从服务器端获取多个资源。</li>\n</ul>\n</blockquote>\n<hr>\n<blockquote>\n<ul>\n<li>当数据只需发送给服务器时，有两种广泛应用的技术：XHR 和灯标。</li>\n</ul>\n</blockquote>\n<p>虽然 XHR 主要用于从服务器获取数据， 它也可以用来将数据发回。 数据可以用 GET 或 POST 方式发回，以及任意数量的 HTTP 信息头。这给你很大灵活性。当你向服务器发回的数据量超过浏览器的最大 URL<br>长度时 XHR 特别有用。这种情况下，你可以用 POST 方式发回数据：</p>\n<pre><code>var url = &apos;/data.php&apos;;\nvar params = [\n&apos;id=934875&apos;,\n&apos;limit=20&apos;\n];\nvar req = new XMLHttpRequest();\nreq.onerror = function() {\n    // Error.\n};\nreq.onreadystatechange = function() {\n    if (req.readyState == 4) {\n        // Success.\n    }\n};\nreq.open(&apos;POST&apos;, url, true);\nreq.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;);\nreq.setRequestHeader(&apos;Content-Length&apos;, params.length);\nreq.send(params.join(&apos;&amp;&apos;));\n</code></pre><blockquote>\n<ul>\n<li>灯标是向服务器回送数据最快和最有效的方法。服务器根本不需要发回任何响应正文，所以你不必担心客户端下载数据。唯一的缺点是接收到的响应类型是受限的。如果你需要向客户端返回大量数据，那么使用 XHR。如果你只关心将数据发送到服务器端（可能需要极少的回复），那么使用图像灯标。</li>\n</ul>\n</blockquote>\n<hr>\n<blockquote>\n<ul>\n<li>XML 与 JSON 相比显得非常冗杂。而且 JSON 在JavaScript可以直接简单的使用();</li>\n</ul>\n<p>当使用 XHR 时 JSON 数据作为一个字符串返回。<br>该字符串使用()转换为一个本地对象。然而，当使用动态脚本标签插入时，JSON 数据被视为另一个JavaScript 文件并作为本地码执行。为做到这一点，数据必须被包装在回调函数之中。这就是所谓的“JSON填充”或 JSON-P。下面是我们用 JSON-P 格式书写的用户列表：</p>\n</blockquote>\n<pre><code>parseJSON([\n    {&quot;id&quot;:1, &quot;username&quot;:&quot;alice&quot;, &quot;realname&quot;:&quot;Alice Smith&quot;, &quot;email&quot;:&quot;alice@alicesmith.com&quot;},\n    {&quot;id&quot;:2, &quot;username&quot;:&quot;bob&quot;, &quot;realname&quot;:&quot;Bob Jones&quot;, &quot;email&quot;:&quot;bob@bobjones.com&quot;},\n    {&quot;id&quot;:3, &quot;username&quot;:&quot;carol&quot;, &quot;realname&quot;:&quot;Carol Williams&quot;, &quot;email&quot;:&quot;carol@carolwilliams.com&quot;},\n    {&quot;id&quot;:4, &quot;username&quot;:&quot;dave&quot;, &quot;realname&quot;:&quot;Dave Johnson&quot;, &quot;email&quot;:&quot;dave@davejohnson.com&quot;}\n]);\n</code></pre><p>　　最快的 JSON 格式是使用数组的 JSON-P 格式。虽然这只比使用 XHR 的 JSON 略快，但是这种差异随着列表尺寸的增大而增大。 如果你所从事的项目需要一个10’000或100’000个单元构成的列表， 那么JSON-P 比 JSON 好很多。<br>　　JSON-P 必须是可执行的 JavaScript，它使用动态<br>脚本标签注入技术可在任何网站中被任何人调用。从另一个角度说，JSON 在运行之前并不是有效的<br>JavaScript，使用 XHR 时只是被当作字符串获取。不要将任何敏感的数据编码为 JSON-P，因为你无法确定它是否包含私密信息，或者包含随机的 URL 或 cookie。</p>\n<hr>\n<h1 id=\"Summary-总结\"><a href=\"#Summary-总结\" class=\"headerlink\" title=\"Summary 总结\"></a>Summary 总结</h1><hr>\n<p>高性能 Ajax 包括：知道你项目的具体需求，选择正确的数据格式和与之相配的传输技术。</p>\n<blockquote>\n<ul>\n<li>作为数据格式，纯文本和 HTML 是高度限制的，但它们可节省客户端的 CPU 周期。XML 被广泛应用普遍支持，但它非常冗长且解析缓慢。JSON 是轻量级的，解析迅速。字符分隔的自定义格式非常轻量，在大量数据集解析时速度最快，但需要编写额外的程序在服务器端构造格式，并在客户端解析。</li>\n<li>减少请求数量，可通过 JavaScript 和 CSS 文件打包，或者使用 MXHR。</li>\n<li>缩短页面的加载时间，在页面其它内容加载之后，使用 Ajax 获取少量重要文件。</li>\n<li>确保代码错误不要直接显示给用户，并在服务器端处理错误。</li>\n<li>学会何时使用一个健壮的 Ajax 库，何时编写自己的底层 Ajax 代码。</li>\n</ul>\n</blockquote>\n<hr>\n<p>Ajax 是提升你网站潜在性能之最大的改进区域之一，因为很多网站大量使用异步请求，又因为它提供<br>了许多不相关问题的解决方案，这些问题诸如，需要加载太多资源。对 XHR 的创造性应用是如此的与众不同，它不是呆滞不友好的界面，而是响应迅速且高效的代名词；它不会引起用户的憎恨，谁见了它都会爱上它。</p>"},{"title":"JavaScript 字符串和正则表达式","date":"2015-08-03T05:42:23.000Z","_content":"**第五章 Strings and Regular Expressions 字符串和正则表达式**\n===\n<!--more-->\n> - 字符串的连接尽量使用简单的+和+=，这样的性能更高。\n\n\tstr += \"one\" + \"two\";\n\t//下面的方式将比上面的快。因为少了一步建立临时字符串。\n\tstr += \"one\";\n\tstr += \"two\";\n\t//下面的代码也可以优化\n\tstr = str + \"one\" + \"two\";\n\t//但是下面的代码还是要建立临时字符串\n\tstr = \"one\" + str + \"two\";\n\n> - 在IE中，以上的技术并不适用。\n\n　　在 IE8中，连接字符串只是记录下构成新字符串的各部分字符串的引用。在最后时刻（当你真正使用连接后的字符串时），各部分字符串才被逐个拷贝到一个新的“真正的”字符串中，然后用它取代先前的字符串引用，所以并非每次使用字符串时都发生合并操作。\n　　在 IE8 以前的版本更慢，它每连接一堆字符串都要复制到新分配的内存中。所以str = str + \"one\" + \"two\";这段代码要拷贝两次。\n　　在IE中使用数组联结方法效率更高。\n\n\t// 优化前\n\tvar str = \"I'm a thirty-five character string.\",\n\tnewStr = \"\",\n\tappends = 5000;\n\twhile (appends--) {\n\t\tnewStr += str;\n\t}\n\t// 优化后\n\tvar str = \"I'm a thirty-five character string.\",\n\tstrs = [],\n\tnewStr,\n\tappends = 5000;\n\twhile (appends--) {\n\t\tstrs[strs.length] = str;\n\t}\n\tnewStr = strs.join(\"\");\n> - concat方法也可以连接字符串，但是比直接+或+=要慢一些。\n\n---\n\n> - 正则表达式的工作过程。\n\n编译--> 设置起始位置--> 匹配每个正则表达式的字元-->匹配成功或失败\n> - 正则的回溯，在这里不详细写了，内容太多，感兴趣的可以去网上查写资料看一下。\n\n> - 回溯失控解决办法：具体化。\n\n　　此类问题的解决办法在于尽可能具体地指出分隔符之间的字符匹配形式。例如\".*?\"用于匹配双引号包围的一个字符串。用更具体的[^\"\\rn]*取代过于宽泛的.*?，就去除了回溯时可能发生的几种情况，如尝试\n用点号匹配引号，或者扩展搜索超出预期范围。\n　　如果没有办法替换更具体的，如[^<]替代[\\s\\S]因为在搜索过程\n中可能会遇到其他类型的标签，你可以通过重复一个非捕获组来达到同样效果， 它包含一个回顾 （阻塞下一个所需的标签）和[\\s\\S]（任意字符）元序列。这确保中间位置上你查找的每个标签都会失败，然后，\n更重要的是，[\\s\\S]模板在你在回顾过程中阻塞的标签被发现之前不能被扩展。\n\n> - 修剪字符串。去除字符串首尾的空格是一个简单而常见的任务。\n\n　　可以用正则表达式来进行修剪。\n\n\tif (!String.prototype.trim) {\n\t\tString.prototype.trim = function() {\n\t\t\treturn this.replace(/^\\s+/, \"\").replace(/\\s+$/, \"\");\n\t\t}\n\t}\n\t// test the new method...\n\t// tab (\\t) and line feed (\\n) characters are\n\t// included in the leading whitespace.\n\tvar str = \" \\t\\n test string \".trim();\n\talert(str == \"test string\"); // alerts \"true\"\nif 语句避免覆盖 trim 函数如果它已经存在，因为原生函数进行了优化，通常远远快于你用 JavaScript 自己写的函数。\n下面是几种正则修剪的代码：\n\t\n\t// trim 2 \n\tString.prototype.trim = function() {\n\treturn this.replace(/^\\s+|\\s+$/g, \"\");\n\t}\n这可能是最通常的解决方案。它通过分支功能合并了两个简单的正则表达式，并使用/g（全局）标记替换所有匹配，而不只是第一个（当目标字符串首尾都有空格时它将匹配两次）。这并不是一个可怕的方法，但是对长字符串操作时，它比使用两个简单的子表达式要慢，因为两个分支选项都要测试每个字符位置。\n\n\t// trim 3\n\tString.prototype.trim = function() {\n\t\treturn this.replace(/^\\s*([\\s\\S]*?)\\s*$/, \"$1\");\n\t}\n这个正则表达式的工作原理是匹配整个字符串，捕获从第一个到最后一个非空格字符之间的序列，记入后向引用 1。然后使用后向引用 1 替代整个字符串，就留下了这个字符串的修剪版本。\n\n\t// trim 4\n\tString.prototype.trim = function() {\n\t\treturn this.replace(/^\\s*([\\s\\S]*\\S)?\\s*$/, \"$1\");\n\t}\n这个表达式与上一个很像，但出于性能原因以贪婪量词取代了懒惰量词。为确保捕获组只匹配到最后一个非空格字符，必需尾随一个\\S。然而，由于正则表达式必需能够匹配全部由空格组成的字符串，整个捕获组通过尾随一个?量词而成为可选组。\n\t\n\t// trim 5\n\tString.prototype.trim = function() {\n\t\treturn this.replace(/^\\s*(\\S*(\\s+\\S+)*)\\s*$/, \"$1\");\n\t}\n\n下面代码是不用正则表达式写的修剪字符串，虽然性能不如正则表达式，但是还是值得学习的。\n\n\t// trim 6\n\tString.prototype.trim = function() {\n\t\tvar start = 0,\n\t\tend = this.length - 1,\n\t\tws = \" \\n\\r\\t\\f\\x0b\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\n\t\t\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u200b\\u2028\\u2029\\u202f\n\t\t\\u205f\\u3000\\ufeff\";\n\t\twhile (ws.indexOf(this.charAt(start)) > -1) {\n\t\t\tstart++;\n\t\t}\n\t\twhile (end > start && ws.indexOf(this.charAt(end)) > -1) {\n\t\t\tend--;\n\t\t}\n\t\treturn this.slice(start, end + 1);\n\t}\n此代码中的 ws 变量包括 ECMAScript 5 中定义的所有空白字符。 出于效率原因，在得到修剪区的起始和终止位置之前避免拷贝字符串的任何部分。\n\n---\nSummary 总结\n===\n---\n密集的字符串操作和粗浅地编写正则表达式可能是主要性能障碍，但本章中的建议可帮助您避免常见缺陷。\n\n> - 当连接数量巨大或尺寸巨大的字符串时，数组联合是 IE7 和它的早期版本上唯一具有合理性能的方法\n> - 如果你不关心 IE7 和它的早期版本， 数组联合是连接字符串最慢的方法之一。使用简单的+和+=取而代之，可避免（产生）不必要的中间字符串。\n> - 回溯既是正则表达式匹配功能基本的组成部分，又是正则表达式影响效率的常见原因。\n> - 回溯失控发生在正则表达式本应很快发现匹配的地方，因为某些特殊的匹配字符串动作，导致运行缓慢甚至浏览器崩溃。避免此问题的技术包括：使相邻字元互斥，避免嵌套量词对一个字符串的相同部分多次匹配，通过重复利用前瞻操作的原子特性去除不必要的回溯。\n> - 提高正则表达式效率的各种技术手段，帮助正则表达式更快地找到匹配，以及在非匹配位置上花费更少时间（见《更多提高正则表达式效率的方法》）。\n> - 正则表达式并不总是完成工作的最佳工具，尤其当你只是搜索一个文本字符串时。\n> - 虽然有很多方法来修整一个字符串，使用两个简单的正则表达式（一个用于去除头部空格，另一个用于去除尾部空格）提供了一个简洁、跨浏览器的方法，适用于不同内容和长度的字符串。从字符串末尾开始循环查找第一个非空格字符，或者在一个混合应用中将此技术与正则表达式结合起来，提供了一个很好的替代方案，它很少受到字符串整体长度的影响。","source":"_posts/高性能JavaScript5.md","raw":"title: JavaScript 字符串和正则表达式\ndate: 2015-08-3 13:42:23\ntags: 高性能JavaScript学习笔记\ncategories: 高性能JavaScript-5\n---\n**第五章 Strings and Regular Expressions 字符串和正则表达式**\n===\n<!--more-->\n> - 字符串的连接尽量使用简单的+和+=，这样的性能更高。\n\n\tstr += \"one\" + \"two\";\n\t//下面的方式将比上面的快。因为少了一步建立临时字符串。\n\tstr += \"one\";\n\tstr += \"two\";\n\t//下面的代码也可以优化\n\tstr = str + \"one\" + \"two\";\n\t//但是下面的代码还是要建立临时字符串\n\tstr = \"one\" + str + \"two\";\n\n> - 在IE中，以上的技术并不适用。\n\n　　在 IE8中，连接字符串只是记录下构成新字符串的各部分字符串的引用。在最后时刻（当你真正使用连接后的字符串时），各部分字符串才被逐个拷贝到一个新的“真正的”字符串中，然后用它取代先前的字符串引用，所以并非每次使用字符串时都发生合并操作。\n　　在 IE8 以前的版本更慢，它每连接一堆字符串都要复制到新分配的内存中。所以str = str + \"one\" + \"two\";这段代码要拷贝两次。\n　　在IE中使用数组联结方法效率更高。\n\n\t// 优化前\n\tvar str = \"I'm a thirty-five character string.\",\n\tnewStr = \"\",\n\tappends = 5000;\n\twhile (appends--) {\n\t\tnewStr += str;\n\t}\n\t// 优化后\n\tvar str = \"I'm a thirty-five character string.\",\n\tstrs = [],\n\tnewStr,\n\tappends = 5000;\n\twhile (appends--) {\n\t\tstrs[strs.length] = str;\n\t}\n\tnewStr = strs.join(\"\");\n> - concat方法也可以连接字符串，但是比直接+或+=要慢一些。\n\n---\n\n> - 正则表达式的工作过程。\n\n编译--> 设置起始位置--> 匹配每个正则表达式的字元-->匹配成功或失败\n> - 正则的回溯，在这里不详细写了，内容太多，感兴趣的可以去网上查写资料看一下。\n\n> - 回溯失控解决办法：具体化。\n\n　　此类问题的解决办法在于尽可能具体地指出分隔符之间的字符匹配形式。例如\".*?\"用于匹配双引号包围的一个字符串。用更具体的[^\"\\rn]*取代过于宽泛的.*?，就去除了回溯时可能发生的几种情况，如尝试\n用点号匹配引号，或者扩展搜索超出预期范围。\n　　如果没有办法替换更具体的，如[^<]替代[\\s\\S]因为在搜索过程\n中可能会遇到其他类型的标签，你可以通过重复一个非捕获组来达到同样效果， 它包含一个回顾 （阻塞下一个所需的标签）和[\\s\\S]（任意字符）元序列。这确保中间位置上你查找的每个标签都会失败，然后，\n更重要的是，[\\s\\S]模板在你在回顾过程中阻塞的标签被发现之前不能被扩展。\n\n> - 修剪字符串。去除字符串首尾的空格是一个简单而常见的任务。\n\n　　可以用正则表达式来进行修剪。\n\n\tif (!String.prototype.trim) {\n\t\tString.prototype.trim = function() {\n\t\t\treturn this.replace(/^\\s+/, \"\").replace(/\\s+$/, \"\");\n\t\t}\n\t}\n\t// test the new method...\n\t// tab (\\t) and line feed (\\n) characters are\n\t// included in the leading whitespace.\n\tvar str = \" \\t\\n test string \".trim();\n\talert(str == \"test string\"); // alerts \"true\"\nif 语句避免覆盖 trim 函数如果它已经存在，因为原生函数进行了优化，通常远远快于你用 JavaScript 自己写的函数。\n下面是几种正则修剪的代码：\n\t\n\t// trim 2 \n\tString.prototype.trim = function() {\n\treturn this.replace(/^\\s+|\\s+$/g, \"\");\n\t}\n这可能是最通常的解决方案。它通过分支功能合并了两个简单的正则表达式，并使用/g（全局）标记替换所有匹配，而不只是第一个（当目标字符串首尾都有空格时它将匹配两次）。这并不是一个可怕的方法，但是对长字符串操作时，它比使用两个简单的子表达式要慢，因为两个分支选项都要测试每个字符位置。\n\n\t// trim 3\n\tString.prototype.trim = function() {\n\t\treturn this.replace(/^\\s*([\\s\\S]*?)\\s*$/, \"$1\");\n\t}\n这个正则表达式的工作原理是匹配整个字符串，捕获从第一个到最后一个非空格字符之间的序列，记入后向引用 1。然后使用后向引用 1 替代整个字符串，就留下了这个字符串的修剪版本。\n\n\t// trim 4\n\tString.prototype.trim = function() {\n\t\treturn this.replace(/^\\s*([\\s\\S]*\\S)?\\s*$/, \"$1\");\n\t}\n这个表达式与上一个很像，但出于性能原因以贪婪量词取代了懒惰量词。为确保捕获组只匹配到最后一个非空格字符，必需尾随一个\\S。然而，由于正则表达式必需能够匹配全部由空格组成的字符串，整个捕获组通过尾随一个?量词而成为可选组。\n\t\n\t// trim 5\n\tString.prototype.trim = function() {\n\t\treturn this.replace(/^\\s*(\\S*(\\s+\\S+)*)\\s*$/, \"$1\");\n\t}\n\n下面代码是不用正则表达式写的修剪字符串，虽然性能不如正则表达式，但是还是值得学习的。\n\n\t// trim 6\n\tString.prototype.trim = function() {\n\t\tvar start = 0,\n\t\tend = this.length - 1,\n\t\tws = \" \\n\\r\\t\\f\\x0b\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\n\t\t\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u200b\\u2028\\u2029\\u202f\n\t\t\\u205f\\u3000\\ufeff\";\n\t\twhile (ws.indexOf(this.charAt(start)) > -1) {\n\t\t\tstart++;\n\t\t}\n\t\twhile (end > start && ws.indexOf(this.charAt(end)) > -1) {\n\t\t\tend--;\n\t\t}\n\t\treturn this.slice(start, end + 1);\n\t}\n此代码中的 ws 变量包括 ECMAScript 5 中定义的所有空白字符。 出于效率原因，在得到修剪区的起始和终止位置之前避免拷贝字符串的任何部分。\n\n---\nSummary 总结\n===\n---\n密集的字符串操作和粗浅地编写正则表达式可能是主要性能障碍，但本章中的建议可帮助您避免常见缺陷。\n\n> - 当连接数量巨大或尺寸巨大的字符串时，数组联合是 IE7 和它的早期版本上唯一具有合理性能的方法\n> - 如果你不关心 IE7 和它的早期版本， 数组联合是连接字符串最慢的方法之一。使用简单的+和+=取而代之，可避免（产生）不必要的中间字符串。\n> - 回溯既是正则表达式匹配功能基本的组成部分，又是正则表达式影响效率的常见原因。\n> - 回溯失控发生在正则表达式本应很快发现匹配的地方，因为某些特殊的匹配字符串动作，导致运行缓慢甚至浏览器崩溃。避免此问题的技术包括：使相邻字元互斥，避免嵌套量词对一个字符串的相同部分多次匹配，通过重复利用前瞻操作的原子特性去除不必要的回溯。\n> - 提高正则表达式效率的各种技术手段，帮助正则表达式更快地找到匹配，以及在非匹配位置上花费更少时间（见《更多提高正则表达式效率的方法》）。\n> - 正则表达式并不总是完成工作的最佳工具，尤其当你只是搜索一个文本字符串时。\n> - 虽然有很多方法来修整一个字符串，使用两个简单的正则表达式（一个用于去除头部空格，另一个用于去除尾部空格）提供了一个简洁、跨浏览器的方法，适用于不同内容和长度的字符串。从字符串末尾开始循环查找第一个非空格字符，或者在一个混合应用中将此技术与正则表达式结合起来，提供了一个很好的替代方案，它很少受到字符串整体长度的影响。","slug":"高性能JavaScript5","published":1,"updated":"2016-10-31T07:25:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciuyzluux001fe6tbqa00ujcb","content":"<h1 id=\"第五章-Strings-and-Regular-Expressions-字符串和正则表达式\"><a href=\"#第五章-Strings-and-Regular-Expressions-字符串和正则表达式\" class=\"headerlink\" title=\"第五章 Strings and Regular Expressions 字符串和正则表达式\"></a><strong>第五章 Strings and Regular Expressions 字符串和正则表达式</strong></h1><a id=\"more\"></a>\n<blockquote>\n<ul>\n<li>字符串的连接尽量使用简单的+和+=，这样的性能更高。</li>\n</ul>\n</blockquote>\n<pre><code>str += &quot;one&quot; + &quot;two&quot;;\n//下面的方式将比上面的快。因为少了一步建立临时字符串。\nstr += &quot;one&quot;;\nstr += &quot;two&quot;;\n//下面的代码也可以优化\nstr = str + &quot;one&quot; + &quot;two&quot;;\n//但是下面的代码还是要建立临时字符串\nstr = &quot;one&quot; + str + &quot;two&quot;;\n</code></pre><blockquote>\n<ul>\n<li>在IE中，以上的技术并不适用。</li>\n</ul>\n</blockquote>\n<p>　　在 IE8中，连接字符串只是记录下构成新字符串的各部分字符串的引用。在最后时刻（当你真正使用连接后的字符串时），各部分字符串才被逐个拷贝到一个新的“真正的”字符串中，然后用它取代先前的字符串引用，所以并非每次使用字符串时都发生合并操作。<br>　　在 IE8 以前的版本更慢，它每连接一堆字符串都要复制到新分配的内存中。所以str = str + “one” + “two”;这段代码要拷贝两次。<br>　　在IE中使用数组联结方法效率更高。</p>\n<pre><code>// 优化前\nvar str = &quot;I&apos;m a thirty-five character string.&quot;,\nnewStr = &quot;&quot;,\nappends = 5000;\nwhile (appends--) {\n    newStr += str;\n}\n// 优化后\nvar str = &quot;I&apos;m a thirty-five character string.&quot;,\nstrs = [],\nnewStr,\nappends = 5000;\nwhile (appends--) {\n    strs[strs.length] = str;\n}\nnewStr = strs.join(&quot;&quot;);\n</code></pre><blockquote>\n<ul>\n<li>concat方法也可以连接字符串，但是比直接+或+=要慢一些。</li>\n</ul>\n</blockquote>\n<hr>\n<blockquote>\n<ul>\n<li>正则表达式的工作过程。</li>\n</ul>\n</blockquote>\n<p>编译–&gt; 设置起始位置–&gt; 匹配每个正则表达式的字元–&gt;匹配成功或失败</p>\n<blockquote>\n<ul>\n<li><p>正则的回溯，在这里不详细写了，内容太多，感兴趣的可以去网上查写资料看一下。</p>\n</li>\n<li><p>回溯失控解决办法：具体化。</p>\n</li>\n</ul>\n</blockquote>\n<p>　　此类问题的解决办法在于尽可能具体地指出分隔符之间的字符匹配形式。例如”.<em>?”用于匹配双引号包围的一个字符串。用更具体的[^”\\rn]</em>取代过于宽泛的.*?，就去除了回溯时可能发生的几种情况，如尝试<br>用点号匹配引号，或者扩展搜索超出预期范围。<br>　　如果没有办法替换更具体的，如[^&lt;]替代[\\s\\S]因为在搜索过程<br>中可能会遇到其他类型的标签，你可以通过重复一个非捕获组来达到同样效果， 它包含一个回顾 （阻塞下一个所需的标签）和[\\s\\S]（任意字符）元序列。这确保中间位置上你查找的每个标签都会失败，然后，<br>更重要的是，[\\s\\S]模板在你在回顾过程中阻塞的标签被发现之前不能被扩展。</p>\n<blockquote>\n<ul>\n<li>修剪字符串。去除字符串首尾的空格是一个简单而常见的任务。</li>\n</ul>\n</blockquote>\n<p>　　可以用正则表达式来进行修剪。</p>\n<pre><code>if (!String.prototype.trim) {\n    String.prototype.trim = function() {\n        return this.replace(/^\\s+/, &quot;&quot;).replace(/\\s+$/, &quot;&quot;);\n    }\n}\n// test the new method...\n// tab (\\t) and line feed (\\n) characters are\n// included in the leading whitespace.\nvar str = &quot; \\t\\n test string &quot;.trim();\nalert(str == &quot;test string&quot;); // alerts &quot;true&quot;\n</code></pre><p>if 语句避免覆盖 trim 函数如果它已经存在，因为原生函数进行了优化，通常远远快于你用 JavaScript 自己写的函数。<br>下面是几种正则修剪的代码：</p>\n<pre><code>// trim 2 \nString.prototype.trim = function() {\nreturn this.replace(/^\\s+|\\s+$/g, &quot;&quot;);\n}\n</code></pre><p>这可能是最通常的解决方案。它通过分支功能合并了两个简单的正则表达式，并使用/g（全局）标记替换所有匹配，而不只是第一个（当目标字符串首尾都有空格时它将匹配两次）。这并不是一个可怕的方法，但是对长字符串操作时，它比使用两个简单的子表达式要慢，因为两个分支选项都要测试每个字符位置。</p>\n<pre><code>// trim 3\nString.prototype.trim = function() {\n    return this.replace(/^\\s*([\\s\\S]*?)\\s*$/, &quot;$1&quot;);\n}\n</code></pre><p>这个正则表达式的工作原理是匹配整个字符串，捕获从第一个到最后一个非空格字符之间的序列，记入后向引用 1。然后使用后向引用 1 替代整个字符串，就留下了这个字符串的修剪版本。</p>\n<pre><code>// trim 4\nString.prototype.trim = function() {\n    return this.replace(/^\\s*([\\s\\S]*\\S)?\\s*$/, &quot;$1&quot;);\n}\n</code></pre><p>这个表达式与上一个很像，但出于性能原因以贪婪量词取代了懒惰量词。为确保捕获组只匹配到最后一个非空格字符，必需尾随一个\\S。然而，由于正则表达式必需能够匹配全部由空格组成的字符串，整个捕获组通过尾随一个?量词而成为可选组。</p>\n<pre><code>// trim 5\nString.prototype.trim = function() {\n    return this.replace(/^\\s*(\\S*(\\s+\\S+)*)\\s*$/, &quot;$1&quot;);\n}\n</code></pre><p>下面代码是不用正则表达式写的修剪字符串，虽然性能不如正则表达式，但是还是值得学习的。</p>\n<pre><code>// trim 6\nString.prototype.trim = function() {\n    var start = 0,\n    end = this.length - 1,\n    ws = &quot; \\n\\r\\t\\f\\x0b\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\n    \\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u200b\\u2028\\u2029\\u202f\n    \\u205f\\u3000\\ufeff&quot;;\n    while (ws.indexOf(this.charAt(start)) &gt; -1) {\n        start++;\n    }\n    while (end &gt; start &amp;&amp; ws.indexOf(this.charAt(end)) &gt; -1) {\n        end--;\n    }\n    return this.slice(start, end + 1);\n}\n</code></pre><p>此代码中的 ws 变量包括 ECMAScript 5 中定义的所有空白字符。 出于效率原因，在得到修剪区的起始和终止位置之前避免拷贝字符串的任何部分。</p>\n<hr>\n<h1 id=\"Summary-总结\"><a href=\"#Summary-总结\" class=\"headerlink\" title=\"Summary 总结\"></a>Summary 总结</h1><hr>\n<p>密集的字符串操作和粗浅地编写正则表达式可能是主要性能障碍，但本章中的建议可帮助您避免常见缺陷。</p>\n<blockquote>\n<ul>\n<li>当连接数量巨大或尺寸巨大的字符串时，数组联合是 IE7 和它的早期版本上唯一具有合理性能的方法</li>\n<li>如果你不关心 IE7 和它的早期版本， 数组联合是连接字符串最慢的方法之一。使用简单的+和+=取而代之，可避免（产生）不必要的中间字符串。</li>\n<li>回溯既是正则表达式匹配功能基本的组成部分，又是正则表达式影响效率的常见原因。</li>\n<li>回溯失控发生在正则表达式本应很快发现匹配的地方，因为某些特殊的匹配字符串动作，导致运行缓慢甚至浏览器崩溃。避免此问题的技术包括：使相邻字元互斥，避免嵌套量词对一个字符串的相同部分多次匹配，通过重复利用前瞻操作的原子特性去除不必要的回溯。</li>\n<li>提高正则表达式效率的各种技术手段，帮助正则表达式更快地找到匹配，以及在非匹配位置上花费更少时间（见《更多提高正则表达式效率的方法》）。</li>\n<li>正则表达式并不总是完成工作的最佳工具，尤其当你只是搜索一个文本字符串时。</li>\n<li>虽然有很多方法来修整一个字符串，使用两个简单的正则表达式（一个用于去除头部空格，另一个用于去除尾部空格）提供了一个简洁、跨浏览器的方法，适用于不同内容和长度的字符串。从字符串末尾开始循环查找第一个非空格字符，或者在一个混合应用中将此技术与正则表达式结合起来，提供了一个很好的替代方案，它很少受到字符串整体长度的影响。</li>\n</ul>\n</blockquote>\n","excerpt":"<h1 id=\"第五章-Strings-and-Regular-Expressions-字符串和正则表达式\"><a href=\"#第五章-Strings-and-Regular-Expressions-字符串和正则表达式\" class=\"headerlink\" title=\"第五章 Strings and Regular Expressions 字符串和正则表达式\"></a><strong>第五章 Strings and Regular Expressions 字符串和正则表达式</strong></h1>","more":"<blockquote>\n<ul>\n<li>字符串的连接尽量使用简单的+和+=，这样的性能更高。</li>\n</ul>\n</blockquote>\n<pre><code>str += &quot;one&quot; + &quot;two&quot;;\n//下面的方式将比上面的快。因为少了一步建立临时字符串。\nstr += &quot;one&quot;;\nstr += &quot;two&quot;;\n//下面的代码也可以优化\nstr = str + &quot;one&quot; + &quot;two&quot;;\n//但是下面的代码还是要建立临时字符串\nstr = &quot;one&quot; + str + &quot;two&quot;;\n</code></pre><blockquote>\n<ul>\n<li>在IE中，以上的技术并不适用。</li>\n</ul>\n</blockquote>\n<p>　　在 IE8中，连接字符串只是记录下构成新字符串的各部分字符串的引用。在最后时刻（当你真正使用连接后的字符串时），各部分字符串才被逐个拷贝到一个新的“真正的”字符串中，然后用它取代先前的字符串引用，所以并非每次使用字符串时都发生合并操作。<br>　　在 IE8 以前的版本更慢，它每连接一堆字符串都要复制到新分配的内存中。所以str = str + “one” + “two”;这段代码要拷贝两次。<br>　　在IE中使用数组联结方法效率更高。</p>\n<pre><code>// 优化前\nvar str = &quot;I&apos;m a thirty-five character string.&quot;,\nnewStr = &quot;&quot;,\nappends = 5000;\nwhile (appends--) {\n    newStr += str;\n}\n// 优化后\nvar str = &quot;I&apos;m a thirty-five character string.&quot;,\nstrs = [],\nnewStr,\nappends = 5000;\nwhile (appends--) {\n    strs[strs.length] = str;\n}\nnewStr = strs.join(&quot;&quot;);\n</code></pre><blockquote>\n<ul>\n<li>concat方法也可以连接字符串，但是比直接+或+=要慢一些。</li>\n</ul>\n</blockquote>\n<hr>\n<blockquote>\n<ul>\n<li>正则表达式的工作过程。</li>\n</ul>\n</blockquote>\n<p>编译–&gt; 设置起始位置–&gt; 匹配每个正则表达式的字元–&gt;匹配成功或失败</p>\n<blockquote>\n<ul>\n<li><p>正则的回溯，在这里不详细写了，内容太多，感兴趣的可以去网上查写资料看一下。</p>\n</li>\n<li><p>回溯失控解决办法：具体化。</p>\n</li>\n</ul>\n</blockquote>\n<p>　　此类问题的解决办法在于尽可能具体地指出分隔符之间的字符匹配形式。例如”.<em>?”用于匹配双引号包围的一个字符串。用更具体的[^”\\rn]</em>取代过于宽泛的.*?，就去除了回溯时可能发生的几种情况，如尝试<br>用点号匹配引号，或者扩展搜索超出预期范围。<br>　　如果没有办法替换更具体的，如[^&lt;]替代[\\s\\S]因为在搜索过程<br>中可能会遇到其他类型的标签，你可以通过重复一个非捕获组来达到同样效果， 它包含一个回顾 （阻塞下一个所需的标签）和[\\s\\S]（任意字符）元序列。这确保中间位置上你查找的每个标签都会失败，然后，<br>更重要的是，[\\s\\S]模板在你在回顾过程中阻塞的标签被发现之前不能被扩展。</p>\n<blockquote>\n<ul>\n<li>修剪字符串。去除字符串首尾的空格是一个简单而常见的任务。</li>\n</ul>\n</blockquote>\n<p>　　可以用正则表达式来进行修剪。</p>\n<pre><code>if (!String.prototype.trim) {\n    String.prototype.trim = function() {\n        return this.replace(/^\\s+/, &quot;&quot;).replace(/\\s+$/, &quot;&quot;);\n    }\n}\n// test the new method...\n// tab (\\t) and line feed (\\n) characters are\n// included in the leading whitespace.\nvar str = &quot; \\t\\n test string &quot;.trim();\nalert(str == &quot;test string&quot;); // alerts &quot;true&quot;\n</code></pre><p>if 语句避免覆盖 trim 函数如果它已经存在，因为原生函数进行了优化，通常远远快于你用 JavaScript 自己写的函数。<br>下面是几种正则修剪的代码：</p>\n<pre><code>// trim 2 \nString.prototype.trim = function() {\nreturn this.replace(/^\\s+|\\s+$/g, &quot;&quot;);\n}\n</code></pre><p>这可能是最通常的解决方案。它通过分支功能合并了两个简单的正则表达式，并使用/g（全局）标记替换所有匹配，而不只是第一个（当目标字符串首尾都有空格时它将匹配两次）。这并不是一个可怕的方法，但是对长字符串操作时，它比使用两个简单的子表达式要慢，因为两个分支选项都要测试每个字符位置。</p>\n<pre><code>// trim 3\nString.prototype.trim = function() {\n    return this.replace(/^\\s*([\\s\\S]*?)\\s*$/, &quot;$1&quot;);\n}\n</code></pre><p>这个正则表达式的工作原理是匹配整个字符串，捕获从第一个到最后一个非空格字符之间的序列，记入后向引用 1。然后使用后向引用 1 替代整个字符串，就留下了这个字符串的修剪版本。</p>\n<pre><code>// trim 4\nString.prototype.trim = function() {\n    return this.replace(/^\\s*([\\s\\S]*\\S)?\\s*$/, &quot;$1&quot;);\n}\n</code></pre><p>这个表达式与上一个很像，但出于性能原因以贪婪量词取代了懒惰量词。为确保捕获组只匹配到最后一个非空格字符，必需尾随一个\\S。然而，由于正则表达式必需能够匹配全部由空格组成的字符串，整个捕获组通过尾随一个?量词而成为可选组。</p>\n<pre><code>// trim 5\nString.prototype.trim = function() {\n    return this.replace(/^\\s*(\\S*(\\s+\\S+)*)\\s*$/, &quot;$1&quot;);\n}\n</code></pre><p>下面代码是不用正则表达式写的修剪字符串，虽然性能不如正则表达式，但是还是值得学习的。</p>\n<pre><code>// trim 6\nString.prototype.trim = function() {\n    var start = 0,\n    end = this.length - 1,\n    ws = &quot; \\n\\r\\t\\f\\x0b\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\n    \\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u200b\\u2028\\u2029\\u202f\n    \\u205f\\u3000\\ufeff&quot;;\n    while (ws.indexOf(this.charAt(start)) &gt; -1) {\n        start++;\n    }\n    while (end &gt; start &amp;&amp; ws.indexOf(this.charAt(end)) &gt; -1) {\n        end--;\n    }\n    return this.slice(start, end + 1);\n}\n</code></pre><p>此代码中的 ws 变量包括 ECMAScript 5 中定义的所有空白字符。 出于效率原因，在得到修剪区的起始和终止位置之前避免拷贝字符串的任何部分。</p>\n<hr>\n<h1 id=\"Summary-总结\"><a href=\"#Summary-总结\" class=\"headerlink\" title=\"Summary 总结\"></a>Summary 总结</h1><hr>\n<p>密集的字符串操作和粗浅地编写正则表达式可能是主要性能障碍，但本章中的建议可帮助您避免常见缺陷。</p>\n<blockquote>\n<ul>\n<li>当连接数量巨大或尺寸巨大的字符串时，数组联合是 IE7 和它的早期版本上唯一具有合理性能的方法</li>\n<li>如果你不关心 IE7 和它的早期版本， 数组联合是连接字符串最慢的方法之一。使用简单的+和+=取而代之，可避免（产生）不必要的中间字符串。</li>\n<li>回溯既是正则表达式匹配功能基本的组成部分，又是正则表达式影响效率的常见原因。</li>\n<li>回溯失控发生在正则表达式本应很快发现匹配的地方，因为某些特殊的匹配字符串动作，导致运行缓慢甚至浏览器崩溃。避免此问题的技术包括：使相邻字元互斥，避免嵌套量词对一个字符串的相同部分多次匹配，通过重复利用前瞻操作的原子特性去除不必要的回溯。</li>\n<li>提高正则表达式效率的各种技术手段，帮助正则表达式更快地找到匹配，以及在非匹配位置上花费更少时间（见《更多提高正则表达式效率的方法》）。</li>\n<li>正则表达式并不总是完成工作的最佳工具，尤其当你只是搜索一个文本字符串时。</li>\n<li>虽然有很多方法来修整一个字符串，使用两个简单的正则表达式（一个用于去除头部空格，另一个用于去除尾部空格）提供了一个简洁、跨浏览器的方法，适用于不同内容和长度的字符串。从字符串末尾开始循环查找第一个非空格字符，或者在一个混合应用中将此技术与正则表达式结合起来，提供了一个很好的替代方案，它很少受到字符串整体长度的影响。</li>\n</ul>\n</blockquote>"},{"title":"JavaScript 编程实践","date":"2015-08-04T11:21:18.000Z","_content":"**第八章 Programming Practices 编程实践**\n===\n<!--more-->\n---\n每种编程语言都有痛点，而且低效模式随着时间的推移不断发展。其原因在于，越来越多的人们开始使用这种语言，不断扩种它的边界。自 2005 年以来，当术语“Ajax”出现时，网页开发者对 JavaScript 和浏览器的推动作用远超过以往。其结果是出现了一些非常具体的模式，即有优秀的做法也有糟糕的做法。这些模式的出现，是因为网络上 JavaScript 的性质决定的。\n\n> - JavaScript与许多脚本语言一样，允许你在程序中获取一个包含代码的字符串然后运行它。有四种标准方法可以实现： eval_r()， Function()构造器， setTimeout()和 setInterval()。每个函数允许你传入一串 JavaScript代码，然后运行它。例如：\n\n\tvar num1 = 5,\n\tnum2 = 6,\n\t//eval_r() evaluating a string of code\n\tresult = eval_r(\"num1 + num2\"),\n\t//Function() evaluating strings of code\n\tsum = new Function(\"arg1\", \"arg2\", \"return arg1 + arg2\");\n\t//setTimeout() evaluating a string of code\n\tsetTimeout(\"sum = num1 + num2\", 100);\n\t//setInterval() evaluating a string of code\n\tsetInterval(\"sum = num1 + num2\", 100);\n\n大多数情况下，没必要使用 eval_r()或 Function()，如果可能的话，尽量避免使用它们。至于另外两个函数，setTimeout()和 setInterval()，第一个参数传入一个函数而不是一个字符串。例如：\n\n\tsetTimeout(function(){\n\t\tsum = num1 + num2;\n\t}, 100);\n\tsetInterval(function(){\n\t\tsum = num1 + num2;\n\t}, 100);\n\n---\n> - 尽量使用对象直接量。这样可以提高性能，同时减少代码量。\n\n> - 不要做重复的工作。下面例子解决重复工作的问题。\n\n\tfunction addHandler(target, eventType, handler){\n\t\tif (target.addEventListener){ //DOM2 Events\n\t\t\ttarget.addEventListener(eventType, handler, false);\n\t\t} else { //IE\n\t\t\ttarget.attachEvent(\"on\" + eventType, handler);\n\t\t}\n\t}\n\tfunction removeHandler(target, eventType, handler){\n\t\tif (target.removeEventListener){ //DOM2 Events\n\t\t\ttarget.removeEventListener(eventType, handler, false);\n\t\t} else { //IE\n\t\t\ttarget.detachEvent(\"on\" + eventType, handler);\n\t\t}\n\t}\n隐藏的性能问题在于每次函数调用时都执行重复工作。每一次，都进行同样的检查，看看某种方法是否存在。如果你假设 target 唯一的值就是 DOM 对象，而且用户不可能在页面加载时魔术般地改变浏览器，那么这种判断就是重复的。如果 addHandler()一上来就调用addEventListener()那么每个后续调用都要出现这句代码。在每次调用中重复同样的工作是一种浪费，有多种办法避免这一点。\n\n可以使用延迟加载：\n\n\tfunction addHandler(target, eventType, handler){\n\t\t\t//overwrite the existing function\n\t\tif (target.addEventListener){ //DOM2 Events\n\t\t\taddHandler = function(target, eventType, handler){\n\t\t\t\ttarget.addEventListener(eventType, handler, false);\n\t\t\t};\n\t\t} else { //IE\n\t\t\taddHandler = function(target, eventType, handler){\n\t\t\t\ttarget.attachEvent(\"on\" + eventType, handler);\n\t\t\t};\n\t\t}\n\t\t//call the new function\n\t\taddHandler(target, eventType, handler);\n\t\t}\n\t\tfunction removeHandler(target, eventType, handler){\n\t\t\t//overwrite the existing function\n\t\t\tif (target.removeEventListener){ //DOM2 Events\n\t\t\t\tremoveHandler = function(target, eventType, handler){\n\t\t\t\t\ttarget.addEventListener(eventType, handler, false);\n\t\t\t\t};\n\t\t\t} else { //IE\n\t\t\t\tremoveHandler = function(target, eventType, handler){\n\t\t\t\ttarget.detachEvent(\"on\" + eventType, handler);\n\t\t\t};\n\t\t}\n\t\t//call the new function\n\t\tremoveHandler(target, eventType, handler);\n\t}\n\n条件预加载：\n\t\n\tvar addHandler = document.body.addEventListener ?\n\tfunction(target, eventType, handler){\n\t\ttarget.addEventListener(eventType, handler, false);\n\t}:\n\tfunction(target, eventType, handler){\n\t\ttarget.attachEvent(\"on\" + eventType, handler);\n\t};\n\tvar removeHandler = document.body.removeEventListener ?\n\tfunction(target, eventType, handler){\n\t\ttarget.removeEventListener(eventType, handler, false);\n\t}:\n\tfunction(target, eventType, handler){\n\t\ttarget.detachEvent(\"on\" + eventType, handler);\n\t};\n\n---\n> - 使用位操作符可以提升性能。\n> - 尽量使用原生方法，可以提高性能。如Math.abs(num)等。\n\n---\nSummary 总结\n===\n---\n\nJavaScript 提出了一些独特的性能挑战，关系到你组织代码的方法。网页应用变得越来越高级，包含的\nJavaScript 代码越来越多，出现了一些模式和反模式。请牢记以下编程经验：\n\n> - 通过避免使用 eval_r()和 Function()构造器避免二次评估。此外，给 setTimeout()和 setInterval()传递函数参数而不是字符串参数。\n> - 创建新对象和数组时使用对象直接量和数组直接量。它们比非直接量形式创建和初始化更快。\n> - 避免重复进行相同工作。当需要检测浏览器时，使用延迟加载或条件预加载。\n> - 当执行数学远算时，考虑使用位操作，它直接在数字底层进行操作。\n> - 原生方法总是比 JavaScript 写的东西要快。尽量使用原生方法。\n> - 本书涵盖了很多技术和方法，如果将这些优化应用在那些经常运行的代码上，你将会看到巨大的性能提升。","source":"_posts/高性能JavaScript8.md","raw":"title: JavaScript 编程实践\ndate: 2015-08-4 19:21:18\ntags: 高性能JavaScript学习笔记\ncategories: 高性能JavaScript-8\n---\n**第八章 Programming Practices 编程实践**\n===\n<!--more-->\n---\n每种编程语言都有痛点，而且低效模式随着时间的推移不断发展。其原因在于，越来越多的人们开始使用这种语言，不断扩种它的边界。自 2005 年以来，当术语“Ajax”出现时，网页开发者对 JavaScript 和浏览器的推动作用远超过以往。其结果是出现了一些非常具体的模式，即有优秀的做法也有糟糕的做法。这些模式的出现，是因为网络上 JavaScript 的性质决定的。\n\n> - JavaScript与许多脚本语言一样，允许你在程序中获取一个包含代码的字符串然后运行它。有四种标准方法可以实现： eval_r()， Function()构造器， setTimeout()和 setInterval()。每个函数允许你传入一串 JavaScript代码，然后运行它。例如：\n\n\tvar num1 = 5,\n\tnum2 = 6,\n\t//eval_r() evaluating a string of code\n\tresult = eval_r(\"num1 + num2\"),\n\t//Function() evaluating strings of code\n\tsum = new Function(\"arg1\", \"arg2\", \"return arg1 + arg2\");\n\t//setTimeout() evaluating a string of code\n\tsetTimeout(\"sum = num1 + num2\", 100);\n\t//setInterval() evaluating a string of code\n\tsetInterval(\"sum = num1 + num2\", 100);\n\n大多数情况下，没必要使用 eval_r()或 Function()，如果可能的话，尽量避免使用它们。至于另外两个函数，setTimeout()和 setInterval()，第一个参数传入一个函数而不是一个字符串。例如：\n\n\tsetTimeout(function(){\n\t\tsum = num1 + num2;\n\t}, 100);\n\tsetInterval(function(){\n\t\tsum = num1 + num2;\n\t}, 100);\n\n---\n> - 尽量使用对象直接量。这样可以提高性能，同时减少代码量。\n\n> - 不要做重复的工作。下面例子解决重复工作的问题。\n\n\tfunction addHandler(target, eventType, handler){\n\t\tif (target.addEventListener){ //DOM2 Events\n\t\t\ttarget.addEventListener(eventType, handler, false);\n\t\t} else { //IE\n\t\t\ttarget.attachEvent(\"on\" + eventType, handler);\n\t\t}\n\t}\n\tfunction removeHandler(target, eventType, handler){\n\t\tif (target.removeEventListener){ //DOM2 Events\n\t\t\ttarget.removeEventListener(eventType, handler, false);\n\t\t} else { //IE\n\t\t\ttarget.detachEvent(\"on\" + eventType, handler);\n\t\t}\n\t}\n隐藏的性能问题在于每次函数调用时都执行重复工作。每一次，都进行同样的检查，看看某种方法是否存在。如果你假设 target 唯一的值就是 DOM 对象，而且用户不可能在页面加载时魔术般地改变浏览器，那么这种判断就是重复的。如果 addHandler()一上来就调用addEventListener()那么每个后续调用都要出现这句代码。在每次调用中重复同样的工作是一种浪费，有多种办法避免这一点。\n\n可以使用延迟加载：\n\n\tfunction addHandler(target, eventType, handler){\n\t\t\t//overwrite the existing function\n\t\tif (target.addEventListener){ //DOM2 Events\n\t\t\taddHandler = function(target, eventType, handler){\n\t\t\t\ttarget.addEventListener(eventType, handler, false);\n\t\t\t};\n\t\t} else { //IE\n\t\t\taddHandler = function(target, eventType, handler){\n\t\t\t\ttarget.attachEvent(\"on\" + eventType, handler);\n\t\t\t};\n\t\t}\n\t\t//call the new function\n\t\taddHandler(target, eventType, handler);\n\t\t}\n\t\tfunction removeHandler(target, eventType, handler){\n\t\t\t//overwrite the existing function\n\t\t\tif (target.removeEventListener){ //DOM2 Events\n\t\t\t\tremoveHandler = function(target, eventType, handler){\n\t\t\t\t\ttarget.addEventListener(eventType, handler, false);\n\t\t\t\t};\n\t\t\t} else { //IE\n\t\t\t\tremoveHandler = function(target, eventType, handler){\n\t\t\t\ttarget.detachEvent(\"on\" + eventType, handler);\n\t\t\t};\n\t\t}\n\t\t//call the new function\n\t\tremoveHandler(target, eventType, handler);\n\t}\n\n条件预加载：\n\t\n\tvar addHandler = document.body.addEventListener ?\n\tfunction(target, eventType, handler){\n\t\ttarget.addEventListener(eventType, handler, false);\n\t}:\n\tfunction(target, eventType, handler){\n\t\ttarget.attachEvent(\"on\" + eventType, handler);\n\t};\n\tvar removeHandler = document.body.removeEventListener ?\n\tfunction(target, eventType, handler){\n\t\ttarget.removeEventListener(eventType, handler, false);\n\t}:\n\tfunction(target, eventType, handler){\n\t\ttarget.detachEvent(\"on\" + eventType, handler);\n\t};\n\n---\n> - 使用位操作符可以提升性能。\n> - 尽量使用原生方法，可以提高性能。如Math.abs(num)等。\n\n---\nSummary 总结\n===\n---\n\nJavaScript 提出了一些独特的性能挑战，关系到你组织代码的方法。网页应用变得越来越高级，包含的\nJavaScript 代码越来越多，出现了一些模式和反模式。请牢记以下编程经验：\n\n> - 通过避免使用 eval_r()和 Function()构造器避免二次评估。此外，给 setTimeout()和 setInterval()传递函数参数而不是字符串参数。\n> - 创建新对象和数组时使用对象直接量和数组直接量。它们比非直接量形式创建和初始化更快。\n> - 避免重复进行相同工作。当需要检测浏览器时，使用延迟加载或条件预加载。\n> - 当执行数学远算时，考虑使用位操作，它直接在数字底层进行操作。\n> - 原生方法总是比 JavaScript 写的东西要快。尽量使用原生方法。\n> - 本书涵盖了很多技术和方法，如果将这些优化应用在那些经常运行的代码上，你将会看到巨大的性能提升。","slug":"高性能JavaScript8","published":1,"updated":"2016-10-31T07:25:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciuyzluv3001ie6tbdf7qaa0q","content":"<h1 id=\"第八章-Programming-Practices-编程实践\"><a href=\"#第八章-Programming-Practices-编程实践\" class=\"headerlink\" title=\"第八章 Programming Practices 编程实践\"></a><strong>第八章 Programming Practices 编程实践</strong></h1><h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><a id=\"more\"></a></h2><p>每种编程语言都有痛点，而且低效模式随着时间的推移不断发展。其原因在于，越来越多的人们开始使用这种语言，不断扩种它的边界。自 2005 年以来，当术语“Ajax”出现时，网页开发者对 JavaScript 和浏览器的推动作用远超过以往。其结果是出现了一些非常具体的模式，即有优秀的做法也有糟糕的做法。这些模式的出现，是因为网络上 JavaScript 的性质决定的。</p>\n<blockquote>\n<ul>\n<li>JavaScript与许多脚本语言一样，允许你在程序中获取一个包含代码的字符串然后运行它。有四种标准方法可以实现： eval_r()， Function()构造器， setTimeout()和 setInterval()。每个函数允许你传入一串 JavaScript代码，然后运行它。例如：</li>\n</ul>\n</blockquote>\n<pre><code>var num1 = 5,\nnum2 = 6,\n//eval_r() evaluating a string of code\nresult = eval_r(&quot;num1 + num2&quot;),\n//Function() evaluating strings of code\nsum = new Function(&quot;arg1&quot;, &quot;arg2&quot;, &quot;return arg1 + arg2&quot;);\n//setTimeout() evaluating a string of code\nsetTimeout(&quot;sum = num1 + num2&quot;, 100);\n//setInterval() evaluating a string of code\nsetInterval(&quot;sum = num1 + num2&quot;, 100);\n</code></pre><p>大多数情况下，没必要使用 eval_r()或 Function()，如果可能的话，尽量避免使用它们。至于另外两个函数，setTimeout()和 setInterval()，第一个参数传入一个函数而不是一个字符串。例如：</p>\n<pre><code>setTimeout(function(){\n    sum = num1 + num2;\n}, 100);\nsetInterval(function(){\n    sum = num1 + num2;\n}, 100);\n</code></pre><hr>\n<blockquote>\n<ul>\n<li><p>尽量使用对象直接量。这样可以提高性能，同时减少代码量。</p>\n</li>\n<li><p>不要做重复的工作。下面例子解决重复工作的问题。</p>\n</li>\n</ul>\n</blockquote>\n<pre><code>function addHandler(target, eventType, handler){\n    if (target.addEventListener){ //DOM2 Events\n        target.addEventListener(eventType, handler, false);\n    } else { //IE\n        target.attachEvent(&quot;on&quot; + eventType, handler);\n    }\n}\nfunction removeHandler(target, eventType, handler){\n    if (target.removeEventListener){ //DOM2 Events\n        target.removeEventListener(eventType, handler, false);\n    } else { //IE\n        target.detachEvent(&quot;on&quot; + eventType, handler);\n    }\n}\n</code></pre><p>隐藏的性能问题在于每次函数调用时都执行重复工作。每一次，都进行同样的检查，看看某种方法是否存在。如果你假设 target 唯一的值就是 DOM 对象，而且用户不可能在页面加载时魔术般地改变浏览器，那么这种判断就是重复的。如果 addHandler()一上来就调用addEventListener()那么每个后续调用都要出现这句代码。在每次调用中重复同样的工作是一种浪费，有多种办法避免这一点。</p>\n<p>可以使用延迟加载：</p>\n<pre><code>function addHandler(target, eventType, handler){\n        //overwrite the existing function\n    if (target.addEventListener){ //DOM2 Events\n        addHandler = function(target, eventType, handler){\n            target.addEventListener(eventType, handler, false);\n        };\n    } else { //IE\n        addHandler = function(target, eventType, handler){\n            target.attachEvent(&quot;on&quot; + eventType, handler);\n        };\n    }\n    //call the new function\n    addHandler(target, eventType, handler);\n    }\n    function removeHandler(target, eventType, handler){\n        //overwrite the existing function\n        if (target.removeEventListener){ //DOM2 Events\n            removeHandler = function(target, eventType, handler){\n                target.addEventListener(eventType, handler, false);\n            };\n        } else { //IE\n            removeHandler = function(target, eventType, handler){\n            target.detachEvent(&quot;on&quot; + eventType, handler);\n        };\n    }\n    //call the new function\n    removeHandler(target, eventType, handler);\n}\n</code></pre><p>条件预加载：</p>\n<pre><code>var addHandler = document.body.addEventListener ?\nfunction(target, eventType, handler){\n    target.addEventListener(eventType, handler, false);\n}:\nfunction(target, eventType, handler){\n    target.attachEvent(&quot;on&quot; + eventType, handler);\n};\nvar removeHandler = document.body.removeEventListener ?\nfunction(target, eventType, handler){\n    target.removeEventListener(eventType, handler, false);\n}:\nfunction(target, eventType, handler){\n    target.detachEvent(&quot;on&quot; + eventType, handler);\n};\n</code></pre><hr>\n<blockquote>\n<ul>\n<li>使用位操作符可以提升性能。</li>\n<li>尽量使用原生方法，可以提高性能。如Math.abs(num)等。</li>\n</ul>\n</blockquote>\n<hr>\n<h1 id=\"Summary-总结\"><a href=\"#Summary-总结\" class=\"headerlink\" title=\"Summary 总结\"></a>Summary 总结</h1><hr>\n<p>JavaScript 提出了一些独特的性能挑战，关系到你组织代码的方法。网页应用变得越来越高级，包含的<br>JavaScript 代码越来越多，出现了一些模式和反模式。请牢记以下编程经验：</p>\n<blockquote>\n<ul>\n<li>通过避免使用 eval_r()和 Function()构造器避免二次评估。此外，给 setTimeout()和 setInterval()传递函数参数而不是字符串参数。</li>\n<li>创建新对象和数组时使用对象直接量和数组直接量。它们比非直接量形式创建和初始化更快。</li>\n<li>避免重复进行相同工作。当需要检测浏览器时，使用延迟加载或条件预加载。</li>\n<li>当执行数学远算时，考虑使用位操作，它直接在数字底层进行操作。</li>\n<li>原生方法总是比 JavaScript 写的东西要快。尽量使用原生方法。</li>\n<li>本书涵盖了很多技术和方法，如果将这些优化应用在那些经常运行的代码上，你将会看到巨大的性能提升。</li>\n</ul>\n</blockquote>\n","excerpt":"<h1 id=\"第八章-Programming-Practices-编程实践\"><a href=\"#第八章-Programming-Practices-编程实践\" class=\"headerlink\" title=\"第八章 Programming Practices 编程实践\"></a><strong>第八章 Programming Practices 编程实践</strong></h1><h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a>","more":"</h2><p>每种编程语言都有痛点，而且低效模式随着时间的推移不断发展。其原因在于，越来越多的人们开始使用这种语言，不断扩种它的边界。自 2005 年以来，当术语“Ajax”出现时，网页开发者对 JavaScript 和浏览器的推动作用远超过以往。其结果是出现了一些非常具体的模式，即有优秀的做法也有糟糕的做法。这些模式的出现，是因为网络上 JavaScript 的性质决定的。</p>\n<blockquote>\n<ul>\n<li>JavaScript与许多脚本语言一样，允许你在程序中获取一个包含代码的字符串然后运行它。有四种标准方法可以实现： eval_r()， Function()构造器， setTimeout()和 setInterval()。每个函数允许你传入一串 JavaScript代码，然后运行它。例如：</li>\n</ul>\n</blockquote>\n<pre><code>var num1 = 5,\nnum2 = 6,\n//eval_r() evaluating a string of code\nresult = eval_r(&quot;num1 + num2&quot;),\n//Function() evaluating strings of code\nsum = new Function(&quot;arg1&quot;, &quot;arg2&quot;, &quot;return arg1 + arg2&quot;);\n//setTimeout() evaluating a string of code\nsetTimeout(&quot;sum = num1 + num2&quot;, 100);\n//setInterval() evaluating a string of code\nsetInterval(&quot;sum = num1 + num2&quot;, 100);\n</code></pre><p>大多数情况下，没必要使用 eval_r()或 Function()，如果可能的话，尽量避免使用它们。至于另外两个函数，setTimeout()和 setInterval()，第一个参数传入一个函数而不是一个字符串。例如：</p>\n<pre><code>setTimeout(function(){\n    sum = num1 + num2;\n}, 100);\nsetInterval(function(){\n    sum = num1 + num2;\n}, 100);\n</code></pre><hr>\n<blockquote>\n<ul>\n<li><p>尽量使用对象直接量。这样可以提高性能，同时减少代码量。</p>\n</li>\n<li><p>不要做重复的工作。下面例子解决重复工作的问题。</p>\n</li>\n</ul>\n</blockquote>\n<pre><code>function addHandler(target, eventType, handler){\n    if (target.addEventListener){ //DOM2 Events\n        target.addEventListener(eventType, handler, false);\n    } else { //IE\n        target.attachEvent(&quot;on&quot; + eventType, handler);\n    }\n}\nfunction removeHandler(target, eventType, handler){\n    if (target.removeEventListener){ //DOM2 Events\n        target.removeEventListener(eventType, handler, false);\n    } else { //IE\n        target.detachEvent(&quot;on&quot; + eventType, handler);\n    }\n}\n</code></pre><p>隐藏的性能问题在于每次函数调用时都执行重复工作。每一次，都进行同样的检查，看看某种方法是否存在。如果你假设 target 唯一的值就是 DOM 对象，而且用户不可能在页面加载时魔术般地改变浏览器，那么这种判断就是重复的。如果 addHandler()一上来就调用addEventListener()那么每个后续调用都要出现这句代码。在每次调用中重复同样的工作是一种浪费，有多种办法避免这一点。</p>\n<p>可以使用延迟加载：</p>\n<pre><code>function addHandler(target, eventType, handler){\n        //overwrite the existing function\n    if (target.addEventListener){ //DOM2 Events\n        addHandler = function(target, eventType, handler){\n            target.addEventListener(eventType, handler, false);\n        };\n    } else { //IE\n        addHandler = function(target, eventType, handler){\n            target.attachEvent(&quot;on&quot; + eventType, handler);\n        };\n    }\n    //call the new function\n    addHandler(target, eventType, handler);\n    }\n    function removeHandler(target, eventType, handler){\n        //overwrite the existing function\n        if (target.removeEventListener){ //DOM2 Events\n            removeHandler = function(target, eventType, handler){\n                target.addEventListener(eventType, handler, false);\n            };\n        } else { //IE\n            removeHandler = function(target, eventType, handler){\n            target.detachEvent(&quot;on&quot; + eventType, handler);\n        };\n    }\n    //call the new function\n    removeHandler(target, eventType, handler);\n}\n</code></pre><p>条件预加载：</p>\n<pre><code>var addHandler = document.body.addEventListener ?\nfunction(target, eventType, handler){\n    target.addEventListener(eventType, handler, false);\n}:\nfunction(target, eventType, handler){\n    target.attachEvent(&quot;on&quot; + eventType, handler);\n};\nvar removeHandler = document.body.removeEventListener ?\nfunction(target, eventType, handler){\n    target.removeEventListener(eventType, handler, false);\n}:\nfunction(target, eventType, handler){\n    target.detachEvent(&quot;on&quot; + eventType, handler);\n};\n</code></pre><hr>\n<blockquote>\n<ul>\n<li>使用位操作符可以提升性能。</li>\n<li>尽量使用原生方法，可以提高性能。如Math.abs(num)等。</li>\n</ul>\n</blockquote>\n<hr>\n<h1 id=\"Summary-总结\"><a href=\"#Summary-总结\" class=\"headerlink\" title=\"Summary 总结\"></a>Summary 总结</h1><hr>\n<p>JavaScript 提出了一些独特的性能挑战，关系到你组织代码的方法。网页应用变得越来越高级，包含的<br>JavaScript 代码越来越多，出现了一些模式和反模式。请牢记以下编程经验：</p>\n<blockquote>\n<ul>\n<li>通过避免使用 eval_r()和 Function()构造器避免二次评估。此外，给 setTimeout()和 setInterval()传递函数参数而不是字符串参数。</li>\n<li>创建新对象和数组时使用对象直接量和数组直接量。它们比非直接量形式创建和初始化更快。</li>\n<li>避免重复进行相同工作。当需要检测浏览器时，使用延迟加载或条件预加载。</li>\n<li>当执行数学远算时，考虑使用位操作，它直接在数字底层进行操作。</li>\n<li>原生方法总是比 JavaScript 写的东西要快。尽量使用原生方法。</li>\n<li>本书涵盖了很多技术和方法，如果将这些优化应用在那些经常运行的代码上，你将会看到巨大的性能提升。</li>\n</ul>\n</blockquote>"},{"title":"JavaScript 算法和流程控制的优化","date":"2015-08-02T15:12:08.000Z","_content":"**第四章 Algorithms and Flow Control 算法和流程控制**\n===\n本章主要讨论算法和流程控制的优化。\n<!--more-->\n---\n> - 在循环中，只有for-in明显比其它的循环要慢。\n由于每次迭代操作要搜索实例或原形的属性，for-in 循环每次迭代都要付出更多开销，所以比其他类型循环慢一些。因此除非需要对不知道数目的对象进行操作，否则尽量避免使用for-in循环。\n\n> - 循环中length局部变量缓存，在上章讨论过，这里不再多说。\n\n\tfor (var i=0, len=items.length; i < len; i++){\n\t\tprocess(items[i]);\n\t}\n> - 使用达夫设备来减少循环迭代的次数(达夫设备在这里不详细叙述，感兴趣可以自己查资料学习一下)。\n\n\t//credit: Jeff Greenberg\n\tvar iterations = Math.floor(items.length / 8),\n\tstartAt = items.length % 8,\n\ti = 0;\n\tdo {\n\t\tswitch(startAt){\n\t\t\tcase 0: process(items[i++]);\n\t\t\tcase 7: process(items[i++]);\n\t\t\tcase 6: process(items[i++]);\n\t\t\tcase 5: process(items[i++]);\n\t\t\tcase 4: process(items[i++]);\n\t\t\tcase 3: process(items[i++]);\n\t\t\tcase 2: process(items[i++]);\n\t\t\tcase 1: process(items[i++]);\n\t\t}\n\t\tstartAt = 0;\n\t} while (--iterations);\n\n> - 可以利用二分法优化if-else。 在条件不规则而且很多的情况下，switch要比if-else快一些。\n\n> - 当有大量离散的值需要测试时，尽量使用查表法代替switch或if-else。\n\n\t//define the array of results\n\tvar results = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10]\n\t//return the correct result\n\treturn results[value];\n> - 错误的递归会导致长时间的运行，还会遇到浏览器调用栈大小的限制。\n> - 使用优化的循环替代长时间运行的递归函数可以提高性能。因为运行一个循环比反复调用一个函数的开销要低。\n\n> - 利用制表来将每次循环或递归的结果缓存，来优化性能。\n\n\tfunction memfactorial(n){\n\tif (!memfactorial.cache){\n\t\tmemfactorial.cache = {\n\t\t\"0\": 1,\n\t\t\"1\": 1\n\t};\n\t}\n\tif (!memfactorial.cache.hasOwnProperty(n)){\n\t\tmemfactorial.cache[n] = n * memfactorial (n-1);\n\t}\n\treturn memfactorial.cache[n];\n\n下面代码是封装一个制表的函数。\n\n\tfunction memoize(fundamental, cache){\n\t\tcache = cache || {};\n\t\tvar shell = function(arg){\n\t\t\tif (!cache.hasOwnProperty(arg)){\n\t\t\t\tcache[arg] = fundamental(arg);\n\t\t\t}\n\t\t\treturn cache[arg];\n\t\t};\n\t\treturn shell;\n\t}\n\t\n---\nSummary 总结\n===\n---\n\n> - for，while，do-while 循环的性能特性相似，谁也不比谁更快或更慢。\n> - 除非你要迭代遍历一个属性未知的对象，否则不要使用 for-in 循环。\n> - 改善循环性能的最好办法是减少每次迭代中的运算量，并减少循环迭代次数。\n> - 一般来说，switch 总是比 if-else 更快，但并不总是最好的解决方法。\n> - 当判断条件较多时，查表法比 if-else 或者 switch 更快。\n> - 浏览器的调用栈尺寸限制了递归算法在 JavaScript 中的应用；栈溢出错误导致其他代码也不能正常执行。\n> - 如果你遇到一个栈溢出错误，将方法修改为一个迭代算法或者使用制表法可以避免重复工作。\n> - 运行的代码总量越大，使用这些策略所带来的性能提升就越明显。\n","source":"_posts/高性能JavaScript4.md","raw":"title: JavaScript 算法和流程控制的优化\ndate: 2015-08-2 23:12:08\ntags: 高性能JavaScript学习笔记\ncategories: 高性能JavaScript-4\n---\n**第四章 Algorithms and Flow Control 算法和流程控制**\n===\n本章主要讨论算法和流程控制的优化。\n<!--more-->\n---\n> - 在循环中，只有for-in明显比其它的循环要慢。\n由于每次迭代操作要搜索实例或原形的属性，for-in 循环每次迭代都要付出更多开销，所以比其他类型循环慢一些。因此除非需要对不知道数目的对象进行操作，否则尽量避免使用for-in循环。\n\n> - 循环中length局部变量缓存，在上章讨论过，这里不再多说。\n\n\tfor (var i=0, len=items.length; i < len; i++){\n\t\tprocess(items[i]);\n\t}\n> - 使用达夫设备来减少循环迭代的次数(达夫设备在这里不详细叙述，感兴趣可以自己查资料学习一下)。\n\n\t//credit: Jeff Greenberg\n\tvar iterations = Math.floor(items.length / 8),\n\tstartAt = items.length % 8,\n\ti = 0;\n\tdo {\n\t\tswitch(startAt){\n\t\t\tcase 0: process(items[i++]);\n\t\t\tcase 7: process(items[i++]);\n\t\t\tcase 6: process(items[i++]);\n\t\t\tcase 5: process(items[i++]);\n\t\t\tcase 4: process(items[i++]);\n\t\t\tcase 3: process(items[i++]);\n\t\t\tcase 2: process(items[i++]);\n\t\t\tcase 1: process(items[i++]);\n\t\t}\n\t\tstartAt = 0;\n\t} while (--iterations);\n\n> - 可以利用二分法优化if-else。 在条件不规则而且很多的情况下，switch要比if-else快一些。\n\n> - 当有大量离散的值需要测试时，尽量使用查表法代替switch或if-else。\n\n\t//define the array of results\n\tvar results = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10]\n\t//return the correct result\n\treturn results[value];\n> - 错误的递归会导致长时间的运行，还会遇到浏览器调用栈大小的限制。\n> - 使用优化的循环替代长时间运行的递归函数可以提高性能。因为运行一个循环比反复调用一个函数的开销要低。\n\n> - 利用制表来将每次循环或递归的结果缓存，来优化性能。\n\n\tfunction memfactorial(n){\n\tif (!memfactorial.cache){\n\t\tmemfactorial.cache = {\n\t\t\"0\": 1,\n\t\t\"1\": 1\n\t};\n\t}\n\tif (!memfactorial.cache.hasOwnProperty(n)){\n\t\tmemfactorial.cache[n] = n * memfactorial (n-1);\n\t}\n\treturn memfactorial.cache[n];\n\n下面代码是封装一个制表的函数。\n\n\tfunction memoize(fundamental, cache){\n\t\tcache = cache || {};\n\t\tvar shell = function(arg){\n\t\t\tif (!cache.hasOwnProperty(arg)){\n\t\t\t\tcache[arg] = fundamental(arg);\n\t\t\t}\n\t\t\treturn cache[arg];\n\t\t};\n\t\treturn shell;\n\t}\n\t\n---\nSummary 总结\n===\n---\n\n> - for，while，do-while 循环的性能特性相似，谁也不比谁更快或更慢。\n> - 除非你要迭代遍历一个属性未知的对象，否则不要使用 for-in 循环。\n> - 改善循环性能的最好办法是减少每次迭代中的运算量，并减少循环迭代次数。\n> - 一般来说，switch 总是比 if-else 更快，但并不总是最好的解决方法。\n> - 当判断条件较多时，查表法比 if-else 或者 switch 更快。\n> - 浏览器的调用栈尺寸限制了递归算法在 JavaScript 中的应用；栈溢出错误导致其他代码也不能正常执行。\n> - 如果你遇到一个栈溢出错误，将方法修改为一个迭代算法或者使用制表法可以避免重复工作。\n> - 运行的代码总量越大，使用这些策略所带来的性能提升就越明显。\n","slug":"高性能JavaScript4","published":1,"updated":"2016-10-31T07:25:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciuyzluv7001le6tb2yiw9ute","content":"<h1 id=\"第四章-Algorithms-and-Flow-Control-算法和流程控制\"><a href=\"#第四章-Algorithms-and-Flow-Control-算法和流程控制\" class=\"headerlink\" title=\"第四章 Algorithms and Flow Control 算法和流程控制\"></a><strong>第四章 Algorithms and Flow Control 算法和流程控制</strong></h1><p>本章主要讨论算法和流程控制的优化。</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><a id=\"more\"></a></h2><blockquote>\n<ul>\n<li><p>在循环中，只有for-in明显比其它的循环要慢。<br>由于每次迭代操作要搜索实例或原形的属性，for-in 循环每次迭代都要付出更多开销，所以比其他类型循环慢一些。因此除非需要对不知道数目的对象进行操作，否则尽量避免使用for-in循环。</p>\n</li>\n<li><p>循环中length局部变量缓存，在上章讨论过，这里不再多说。</p>\n</li>\n</ul>\n</blockquote>\n<pre><code>for (var i=0, len=items.length; i &lt; len; i++){\n    process(items[i]);\n}\n</code></pre><blockquote>\n<ul>\n<li>使用达夫设备来减少循环迭代的次数(达夫设备在这里不详细叙述，感兴趣可以自己查资料学习一下)。</li>\n</ul>\n</blockquote>\n<pre><code>//credit: Jeff Greenberg\nvar iterations = Math.floor(items.length / 8),\nstartAt = items.length % 8,\ni = 0;\ndo {\n    switch(startAt){\n        case 0: process(items[i++]);\n        case 7: process(items[i++]);\n        case 6: process(items[i++]);\n        case 5: process(items[i++]);\n        case 4: process(items[i++]);\n        case 3: process(items[i++]);\n        case 2: process(items[i++]);\n        case 1: process(items[i++]);\n    }\n    startAt = 0;\n} while (--iterations);\n</code></pre><blockquote>\n<ul>\n<li><p>可以利用二分法优化if-else。 在条件不规则而且很多的情况下，switch要比if-else快一些。</p>\n</li>\n<li><p>当有大量离散的值需要测试时，尽量使用查表法代替switch或if-else。</p>\n</li>\n</ul>\n</blockquote>\n<pre><code>//define the array of results\nvar results = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10]\n//return the correct result\nreturn results[value];\n</code></pre><blockquote>\n<ul>\n<li>错误的递归会导致长时间的运行，还会遇到浏览器调用栈大小的限制。</li>\n<li><p>使用优化的循环替代长时间运行的递归函数可以提高性能。因为运行一个循环比反复调用一个函数的开销要低。</p>\n</li>\n<li><p>利用制表来将每次循环或递归的结果缓存，来优化性能。</p>\n</li>\n</ul>\n</blockquote>\n<pre><code>function memfactorial(n){\nif (!memfactorial.cache){\n    memfactorial.cache = {\n    &quot;0&quot;: 1,\n    &quot;1&quot;: 1\n};\n}\nif (!memfactorial.cache.hasOwnProperty(n)){\n    memfactorial.cache[n] = n * memfactorial (n-1);\n}\nreturn memfactorial.cache[n];\n</code></pre><p>下面代码是封装一个制表的函数。</p>\n<pre><code>function memoize(fundamental, cache){\n    cache = cache || {};\n    var shell = function(arg){\n        if (!cache.hasOwnProperty(arg)){\n            cache[arg] = fundamental(arg);\n        }\n        return cache[arg];\n    };\n    return shell;\n}\n</code></pre><hr>\n<h1 id=\"Summary-总结\"><a href=\"#Summary-总结\" class=\"headerlink\" title=\"Summary 总结\"></a>Summary 总结</h1><hr>\n<blockquote>\n<ul>\n<li>for，while，do-while 循环的性能特性相似，谁也不比谁更快或更慢。</li>\n<li>除非你要迭代遍历一个属性未知的对象，否则不要使用 for-in 循环。</li>\n<li>改善循环性能的最好办法是减少每次迭代中的运算量，并减少循环迭代次数。</li>\n<li>一般来说，switch 总是比 if-else 更快，但并不总是最好的解决方法。</li>\n<li>当判断条件较多时，查表法比 if-else 或者 switch 更快。</li>\n<li>浏览器的调用栈尺寸限制了递归算法在 JavaScript 中的应用；栈溢出错误导致其他代码也不能正常执行。</li>\n<li>如果你遇到一个栈溢出错误，将方法修改为一个迭代算法或者使用制表法可以避免重复工作。</li>\n<li>运行的代码总量越大，使用这些策略所带来的性能提升就越明显。</li>\n</ul>\n</blockquote>\n","excerpt":"<h1 id=\"第四章-Algorithms-and-Flow-Control-算法和流程控制\"><a href=\"#第四章-Algorithms-and-Flow-Control-算法和流程控制\" class=\"headerlink\" title=\"第四章 Algorithms and Flow Control 算法和流程控制\"></a><strong>第四章 Algorithms and Flow Control 算法和流程控制</strong></h1><p>本章主要讨论算法和流程控制的优化。</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a>","more":"</h2><blockquote>\n<ul>\n<li><p>在循环中，只有for-in明显比其它的循环要慢。<br>由于每次迭代操作要搜索实例或原形的属性，for-in 循环每次迭代都要付出更多开销，所以比其他类型循环慢一些。因此除非需要对不知道数目的对象进行操作，否则尽量避免使用for-in循环。</p>\n</li>\n<li><p>循环中length局部变量缓存，在上章讨论过，这里不再多说。</p>\n</li>\n</ul>\n</blockquote>\n<pre><code>for (var i=0, len=items.length; i &lt; len; i++){\n    process(items[i]);\n}\n</code></pre><blockquote>\n<ul>\n<li>使用达夫设备来减少循环迭代的次数(达夫设备在这里不详细叙述，感兴趣可以自己查资料学习一下)。</li>\n</ul>\n</blockquote>\n<pre><code>//credit: Jeff Greenberg\nvar iterations = Math.floor(items.length / 8),\nstartAt = items.length % 8,\ni = 0;\ndo {\n    switch(startAt){\n        case 0: process(items[i++]);\n        case 7: process(items[i++]);\n        case 6: process(items[i++]);\n        case 5: process(items[i++]);\n        case 4: process(items[i++]);\n        case 3: process(items[i++]);\n        case 2: process(items[i++]);\n        case 1: process(items[i++]);\n    }\n    startAt = 0;\n} while (--iterations);\n</code></pre><blockquote>\n<ul>\n<li><p>可以利用二分法优化if-else。 在条件不规则而且很多的情况下，switch要比if-else快一些。</p>\n</li>\n<li><p>当有大量离散的值需要测试时，尽量使用查表法代替switch或if-else。</p>\n</li>\n</ul>\n</blockquote>\n<pre><code>//define the array of results\nvar results = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10]\n//return the correct result\nreturn results[value];\n</code></pre><blockquote>\n<ul>\n<li>错误的递归会导致长时间的运行，还会遇到浏览器调用栈大小的限制。</li>\n<li><p>使用优化的循环替代长时间运行的递归函数可以提高性能。因为运行一个循环比反复调用一个函数的开销要低。</p>\n</li>\n<li><p>利用制表来将每次循环或递归的结果缓存，来优化性能。</p>\n</li>\n</ul>\n</blockquote>\n<pre><code>function memfactorial(n){\nif (!memfactorial.cache){\n    memfactorial.cache = {\n    &quot;0&quot;: 1,\n    &quot;1&quot;: 1\n};\n}\nif (!memfactorial.cache.hasOwnProperty(n)){\n    memfactorial.cache[n] = n * memfactorial (n-1);\n}\nreturn memfactorial.cache[n];\n</code></pre><p>下面代码是封装一个制表的函数。</p>\n<pre><code>function memoize(fundamental, cache){\n    cache = cache || {};\n    var shell = function(arg){\n        if (!cache.hasOwnProperty(arg)){\n            cache[arg] = fundamental(arg);\n        }\n        return cache[arg];\n    };\n    return shell;\n}\n</code></pre><hr>\n<h1 id=\"Summary-总结\"><a href=\"#Summary-总结\" class=\"headerlink\" title=\"Summary 总结\"></a>Summary 总结</h1><hr>\n<blockquote>\n<ul>\n<li>for，while，do-while 循环的性能特性相似，谁也不比谁更快或更慢。</li>\n<li>除非你要迭代遍历一个属性未知的对象，否则不要使用 for-in 循环。</li>\n<li>改善循环性能的最好办法是减少每次迭代中的运算量，并减少循环迭代次数。</li>\n<li>一般来说，switch 总是比 if-else 更快，但并不总是最好的解决方法。</li>\n<li>当判断条件较多时，查表法比 if-else 或者 switch 更快。</li>\n<li>浏览器的调用栈尺寸限制了递归算法在 JavaScript 中的应用；栈溢出错误导致其他代码也不能正常执行。</li>\n<li>如果你遇到一个栈溢出错误，将方法修改为一个迭代算法或者使用制表法可以避免重复工作。</li>\n<li>运行的代码总量越大，使用这些策略所带来的性能提升就越明显。</li>\n</ul>\n</blockquote>"},{"title":"创建并部署高性能 JavaScript","date":"2015-08-05T15:19:20.000Z","_content":"**第九章 Building and Deploying High-Performance JavaScript Applications 创建并部署高性能 JavaScript **\n===\n<!--more-->\n---\n\n> - [Apache Ant](http://ant.apache.org/)是一个自动构建软件的工具。它类似于 make，但在 Java 中实现，并使用 XML 来描述生成过程，而 make 使用它自己的 Makefile 文件格式。Ant 是 Apache 软件基金会的一个项目：（http://www.apache.org/licenses/）。\n\n> - 预处理您的 JavaScript 源文件并不会使你的程序更快，但它允许你在代码中加入其它语言才有的一些特\n性，例如用条件体插入一些测试代码，来衡量你应用程序的性能。\n\n> JavaScript 紧凑指的是剔除一个 JavaScript 文件中一切运行无关内容的过程。包括注释和不必要的空格。该处理通常可将文件尺寸缩减到一半，其结果是下载速度更快，并鼓励程序员写出更好，更详细的内联文档。\n\n下面是一些处理紧凑的对比：\n\n\tjQuery 120,180 bytes\n\tjQuery + YUI Compressor 56,814 bytes\n\tjQuery + Packer 39,351 bytes\n\tRaw jQuery + gzip 34,987 bytes\n\tjQuery + YUI Compressor + gzip 19,457 bytes\n\tjQuery + Packer + gzip 19,228 bytes\n\n---\n> - 使 HTTP 组件可缓存将大大提高用户再次访问网站时的用户体验。一个具体的例子是，加载 [Yahoo!主页](http://www.yahoo.com/)时，和不使用缓存相比，使用缓存将减少 90%的 HTTP 请求和 83%的下载字节。往返时间（从请求页面开始到第一次 onload 事件）从 2.4 秒下降到 0.9 秒。如果可能的话，你还可以考虑客户端存储机制，让 JavaScript 代码自己来处理过期。\n\n---\nSummary 总结\n===\n---\n开发和部署过程对基于 JavaScript 的应用程序可以产生巨大影响，最重要的几个步骤如下：\n\n> - 合并 JavaScript 文件，减少 HTTP 请求的数量。\n> - 使用 YUI 压缩器紧凑处理 JavaScript 文件。\n> - 以压缩形式提供 JavaScript 文件（gzip 编码）\n> - 通过设置 HTTP 响应报文头使 JavaScript 文件可缓存，通过向文件名附加时间戳解决缓存问题。\n> - 使用内容传递网络（CDN）提供 JavaScript 文件，CDN 不仅可以提高性能，它还可以为你管理压缩和缓存。\n> - 所有这些步骤应当自动完成， 不论是使用公开的开发工具诸如 Apache Ant， 还是使用自定义的开发工具以实现特定需求。如果你使这些开发工具为你服务，你可以极大改善那些大量使用 JavaScript 代码的网页应用或网站的性能。\n","source":"_posts/高性能JavaScript9.md","raw":"title: 创建并部署高性能 JavaScript\ndate: 2015-08-5 23:19:20\ntags: 高性能JavaScript学习笔记\ncategories: 高性能JavaScript-9\n---\n**第九章 Building and Deploying High-Performance JavaScript Applications 创建并部署高性能 JavaScript **\n===\n<!--more-->\n---\n\n> - [Apache Ant](http://ant.apache.org/)是一个自动构建软件的工具。它类似于 make，但在 Java 中实现，并使用 XML 来描述生成过程，而 make 使用它自己的 Makefile 文件格式。Ant 是 Apache 软件基金会的一个项目：（http://www.apache.org/licenses/）。\n\n> - 预处理您的 JavaScript 源文件并不会使你的程序更快，但它允许你在代码中加入其它语言才有的一些特\n性，例如用条件体插入一些测试代码，来衡量你应用程序的性能。\n\n> JavaScript 紧凑指的是剔除一个 JavaScript 文件中一切运行无关内容的过程。包括注释和不必要的空格。该处理通常可将文件尺寸缩减到一半，其结果是下载速度更快，并鼓励程序员写出更好，更详细的内联文档。\n\n下面是一些处理紧凑的对比：\n\n\tjQuery 120,180 bytes\n\tjQuery + YUI Compressor 56,814 bytes\n\tjQuery + Packer 39,351 bytes\n\tRaw jQuery + gzip 34,987 bytes\n\tjQuery + YUI Compressor + gzip 19,457 bytes\n\tjQuery + Packer + gzip 19,228 bytes\n\n---\n> - 使 HTTP 组件可缓存将大大提高用户再次访问网站时的用户体验。一个具体的例子是，加载 [Yahoo!主页](http://www.yahoo.com/)时，和不使用缓存相比，使用缓存将减少 90%的 HTTP 请求和 83%的下载字节。往返时间（从请求页面开始到第一次 onload 事件）从 2.4 秒下降到 0.9 秒。如果可能的话，你还可以考虑客户端存储机制，让 JavaScript 代码自己来处理过期。\n\n---\nSummary 总结\n===\n---\n开发和部署过程对基于 JavaScript 的应用程序可以产生巨大影响，最重要的几个步骤如下：\n\n> - 合并 JavaScript 文件，减少 HTTP 请求的数量。\n> - 使用 YUI 压缩器紧凑处理 JavaScript 文件。\n> - 以压缩形式提供 JavaScript 文件（gzip 编码）\n> - 通过设置 HTTP 响应报文头使 JavaScript 文件可缓存，通过向文件名附加时间戳解决缓存问题。\n> - 使用内容传递网络（CDN）提供 JavaScript 文件，CDN 不仅可以提高性能，它还可以为你管理压缩和缓存。\n> - 所有这些步骤应当自动完成， 不论是使用公开的开发工具诸如 Apache Ant， 还是使用自定义的开发工具以实现特定需求。如果你使这些开发工具为你服务，你可以极大改善那些大量使用 JavaScript 代码的网页应用或网站的性能。\n","slug":"高性能JavaScript9","published":1,"updated":"2016-10-31T07:25:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciuyzluvf001pe6tbc7nmbmkg","content":"<h1 id=\"第九章-Building-and-Deploying-High-Performance-JavaScript-Applications-创建并部署高性能-JavaScript\"><a href=\"#第九章-Building-and-Deploying-High-Performance-JavaScript-Applications-创建并部署高性能-JavaScript\" class=\"headerlink\" title=\"第九章 Building and Deploying High-Performance JavaScript Applications 创建并部署高性能 JavaScript \"></a><strong>第九章 Building and Deploying High-Performance JavaScript Applications 创建并部署高性能 JavaScript </strong></h1><h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><a id=\"more\"></a></h2><blockquote>\n<ul>\n<li><p><a href=\"http://ant.apache.org/\" target=\"_blank\" rel=\"external\">Apache Ant</a>是一个自动构建软件的工具。它类似于 make，但在 Java 中实现，并使用 XML 来描述生成过程，而 make 使用它自己的 Makefile 文件格式。Ant 是 Apache 软件基金会的一个项目：（<a href=\"http://www.apache.org/licenses/）。\" target=\"_blank\" rel=\"external\">http://www.apache.org/licenses/）。</a></p>\n</li>\n<li><p>预处理您的 JavaScript 源文件并不会使你的程序更快，但它允许你在代码中加入其它语言才有的一些特<br>性，例如用条件体插入一些测试代码，来衡量你应用程序的性能。</p>\n</li>\n</ul>\n<p>JavaScript 紧凑指的是剔除一个 JavaScript 文件中一切运行无关内容的过程。包括注释和不必要的空格。该处理通常可将文件尺寸缩减到一半，其结果是下载速度更快，并鼓励程序员写出更好，更详细的内联文档。</p>\n</blockquote>\n<p>下面是一些处理紧凑的对比：</p>\n<pre><code>jQuery 120,180 bytes\njQuery + YUI Compressor 56,814 bytes\njQuery + Packer 39,351 bytes\nRaw jQuery + gzip 34,987 bytes\njQuery + YUI Compressor + gzip 19,457 bytes\njQuery + Packer + gzip 19,228 bytes\n</code></pre><hr>\n<blockquote>\n<ul>\n<li>使 HTTP 组件可缓存将大大提高用户再次访问网站时的用户体验。一个具体的例子是，加载 <a href=\"http://www.yahoo.com/\" target=\"_blank\" rel=\"external\">Yahoo!主页</a>时，和不使用缓存相比，使用缓存将减少 90%的 HTTP 请求和 83%的下载字节。往返时间（从请求页面开始到第一次 onload 事件）从 2.4 秒下降到 0.9 秒。如果可能的话，你还可以考虑客户端存储机制，让 JavaScript 代码自己来处理过期。</li>\n</ul>\n</blockquote>\n<hr>\n<h1 id=\"Summary-总结\"><a href=\"#Summary-总结\" class=\"headerlink\" title=\"Summary 总结\"></a>Summary 总结</h1><hr>\n<p>开发和部署过程对基于 JavaScript 的应用程序可以产生巨大影响，最重要的几个步骤如下：</p>\n<blockquote>\n<ul>\n<li>合并 JavaScript 文件，减少 HTTP 请求的数量。</li>\n<li>使用 YUI 压缩器紧凑处理 JavaScript 文件。</li>\n<li>以压缩形式提供 JavaScript 文件（gzip 编码）</li>\n<li>通过设置 HTTP 响应报文头使 JavaScript 文件可缓存，通过向文件名附加时间戳解决缓存问题。</li>\n<li>使用内容传递网络（CDN）提供 JavaScript 文件，CDN 不仅可以提高性能，它还可以为你管理压缩和缓存。</li>\n<li>所有这些步骤应当自动完成， 不论是使用公开的开发工具诸如 Apache Ant， 还是使用自定义的开发工具以实现特定需求。如果你使这些开发工具为你服务，你可以极大改善那些大量使用 JavaScript 代码的网页应用或网站的性能。</li>\n</ul>\n</blockquote>\n","excerpt":"<h1 id=\"第九章-Building-and-Deploying-High-Performance-JavaScript-Applications-创建并部署高性能-JavaScript\"><a href=\"#第九章-Building-and-Deploying-High-Performance-JavaScript-Applications-创建并部署高性能-JavaScript\" class=\"headerlink\" title=\"第九章 Building and Deploying High-Performance JavaScript Applications 创建并部署高性能 JavaScript \"></a><strong>第九章 Building and Deploying High-Performance JavaScript Applications 创建并部署高性能 JavaScript </strong></h1><h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a>","more":"</h2><blockquote>\n<ul>\n<li><p><a href=\"http://ant.apache.org/\">Apache Ant</a>是一个自动构建软件的工具。它类似于 make，但在 Java 中实现，并使用 XML 来描述生成过程，而 make 使用它自己的 Makefile 文件格式。Ant 是 Apache 软件基金会的一个项目：（<a href=\"http://www.apache.org/licenses/）。\">http://www.apache.org/licenses/）。</a></p>\n</li>\n<li><p>预处理您的 JavaScript 源文件并不会使你的程序更快，但它允许你在代码中加入其它语言才有的一些特<br>性，例如用条件体插入一些测试代码，来衡量你应用程序的性能。</p>\n</li>\n</ul>\n<p>JavaScript 紧凑指的是剔除一个 JavaScript 文件中一切运行无关内容的过程。包括注释和不必要的空格。该处理通常可将文件尺寸缩减到一半，其结果是下载速度更快，并鼓励程序员写出更好，更详细的内联文档。</p>\n</blockquote>\n<p>下面是一些处理紧凑的对比：</p>\n<pre><code>jQuery 120,180 bytes\njQuery + YUI Compressor 56,814 bytes\njQuery + Packer 39,351 bytes\nRaw jQuery + gzip 34,987 bytes\njQuery + YUI Compressor + gzip 19,457 bytes\njQuery + Packer + gzip 19,228 bytes\n</code></pre><hr>\n<blockquote>\n<ul>\n<li>使 HTTP 组件可缓存将大大提高用户再次访问网站时的用户体验。一个具体的例子是，加载 <a href=\"http://www.yahoo.com/\">Yahoo!主页</a>时，和不使用缓存相比，使用缓存将减少 90%的 HTTP 请求和 83%的下载字节。往返时间（从请求页面开始到第一次 onload 事件）从 2.4 秒下降到 0.9 秒。如果可能的话，你还可以考虑客户端存储机制，让 JavaScript 代码自己来处理过期。</li>\n</ul>\n</blockquote>\n<hr>\n<h1 id=\"Summary-总结\"><a href=\"#Summary-总结\" class=\"headerlink\" title=\"Summary 总结\"></a>Summary 总结</h1><hr>\n<p>开发和部署过程对基于 JavaScript 的应用程序可以产生巨大影响，最重要的几个步骤如下：</p>\n<blockquote>\n<ul>\n<li>合并 JavaScript 文件，减少 HTTP 请求的数量。</li>\n<li>使用 YUI 压缩器紧凑处理 JavaScript 文件。</li>\n<li>以压缩形式提供 JavaScript 文件（gzip 编码）</li>\n<li>通过设置 HTTP 响应报文头使 JavaScript 文件可缓存，通过向文件名附加时间戳解决缓存问题。</li>\n<li>使用内容传递网络（CDN）提供 JavaScript 文件，CDN 不仅可以提高性能，它还可以为你管理压缩和缓存。</li>\n<li>所有这些步骤应当自动完成， 不论是使用公开的开发工具诸如 Apache Ant， 还是使用自定义的开发工具以实现特定需求。如果你使这些开发工具为你服务，你可以极大改善那些大量使用 JavaScript 代码的网页应用或网站的性能。</li>\n</ul>\n</blockquote>"},{"title":"浅谈BFC的实际应用","date":"2015-08-08T04:19:21.000Z","keywords":"BFC, CSS","_content":"BFC在开发非常重要，每个人对其理解都有不同。本文章主要讨论BFC的一些实际应用。\n<!--more-->\n　　BFC 的英文全称是：block formatting context（块级格式化文本）。BFC可以理解为一个独立的渲染块，或者说是CSS布局单位。\n\n常见BFC的触发条件\n===\n---\n常见BFC的触发条件有：\n\n{% codeblock lang:css %}\n\tposition: absolute/fixed;\n\tdiplay: inline-block/table-cells/table-captions;\n\toverflow: hidden;/* 不为visible的值 */\n\tfloat: left/right;\n{% endcodeblock %}\n下面来简单的看一个例子。\n由于< span>标签默认是行级元素，所以不能给其设置宽高，如果添加属性diplay：block; 它就可以设置宽高了。\n{% codeblock lang:css %}\n\tspan{\n\t\tposition: absolute;\n\t\twidth: 100px;\n\t\theight: 100px;\n\t\tbackground-color: #000;\n\t}\n{% endcodeblock %}\n\n将这样一段CSS添加给< span>标签，改变的宽高就会生效。但并没有给其添加display:block属性。同样的\"float: left/right;\"和 \"position: absolute/fixed;\"也都会使其生效。实际上在使用这些属性的过程中，相当于隐式的给< span>标签添加了属性\"display: inline-block\"。\n这一性质其实并不常用，因为即使你不知道这些，你也可以在< span>标签中手动的添加一个\"display: block\"来改变其宽高。\n\n---\nmargin塌陷问题\n===\n先看一下这段代码：\n\n{% codeblock lang:css %}\n/* CSS代码 */\n\t.wrapper{\n\t\twidth: 200px;\n\t\theight: 200px;\n\t\tbackground-color: #fcc\n\t}\n\t.content{\n\t\tmargin-top: 100px;\n\t\twidth: 100px;\n\t\theight: 100px;\n\t\tbackground-color: #ffc;\n\t}\n{% endcodeblock %}\n{% codeblock lang:html %}\n// HTML代码\n\t<div class=\"wrapper\">\n\t\t<div class=\"content\"></div>\n\t</div>\n{% endcodeblock %}\n\n我们再看一下这段代码执行后的效果：\n![margin塌陷](http://7xkj1z.com1.z0.glb.clouddn.com/BFC1.png)\n按正常的理解，这段代码执行后的效果不应该是这样，我们想要的是子容器在父容器内部产生margin-top，而不是父容器产生margin-top。这就是大家熟知的margin塌陷问题，解决这个问题的方法有很多，有一种bug解决方法，可以在\".wrapper\"中加入\"border:1px solid #ccc;\"。当然，正常的解决方式就是利用BFC。\n将触发BFC的条件属性写入\".wrapper\"中，在这里不在写出代码。就可以解决这个问题。解决之后的效果是这样的：\n![margin塌陷](http://7xkj1z.com1.z0.glb.clouddn.com/BFC2.png)\n上面的例子中还有一个很好玩的地方：\n\n{% codeblock lang:css %}\n/* CSS代码 */\n\t.wrapper{\n\t\twidth: 200px;\n\t\theight: 200px;\n\t\tbackground-color: #fcc\n\t\tmargin-top: 100px;\n\t}\n\t.content{\n\t\tmargin-top: 100px;\n\t\twidth: 100px;\n\t\theight: 100px;\n\t\tbackground-color: #ffc;\n\t}\n{% endcodeblock %}\n{% codeblock lang:html %}\n// HTML代码\n\t<div class=\"wrapper\">\n\t\t<div class=\"content\"></div>\n\t</div>\n{% endcodeblock %}\n这段代码执行的结果与上面的一样，为什么我们给父容器添加的margin-top没有生效？其实这里不仅仅是发生了margin塌陷现象，实际上还发生了margin的重叠现象。子容器的margin-top与父容器的margin-top重叠了。解决办法同上，还是给父容器添加BFC。添加完BFC就会出现我们想要的效果。\n![margin塌陷](http://7xkj1z.com1.z0.glb.clouddn.com/BFC3.png)\n\n---\nmargin重叠\n===\n上面例子里有说到margin重叠，下面还有几种margin重叠的问题。看一下下面的例子。\n{% codeblock lang:css %}\n/* CSS代码 */\n\t.content1{\n\t\theight: 100px;\n\t\twidth: 100px;\n\t\tbackground-color: red;\n\t\tmargin-bottom: 100px;\n\t}\n\t.content2{\n\t\theight: 100px;\n\t\twidth: 100px;\n\t\tbackground-color: green;\n\t\tmargin-top: 100px;\n\t}\n{% endcodeblock %}\n{% codeblock lang:html %}\n// HTML代码\n\t<div class=\"content1\"></div>\n\t<div class=\"content2\"></div>\n{% endcodeblock %}\n这段代码运行的结果为：\n![margin重叠](http://7xkj1z.com1.z0.glb.clouddn.com/BFC4.png)\n看出问题了么，这两个margin发生了重叠，中间只有 100px 的距离。实际上，在这里的margin会取两个margin中大的数值作为实际显示出的数值。解决这个问题同样使用BFC。\n{% codeblock lang:css %}\n/* CSS代码 */\n\t.content1{\n\t\theight: 100px;\n\t\twidth: 100px;\n\t\tbackground-color: red;\n\t\tmargin-bottom: 100px;\n\t}\n\t.content2{\n\t\theight: 100px;\n\t\twidth: 100px;\n\t\tbackground-color: green;\n\t\tmargin-top: 100px;\n\t}\n\t.wrapper{\n\t\toverflow: hidden;\n\t\t/*position: fixed;*/\n\t\t/*position: absolute;*/\n\t\t/*display: inline-block;*/\n\t\t/*float: left;*/\n\t}\n{% endcodeblock %}\n{% codeblock lang:html %}\n// HTML代码\n\t<div class=\"content1\"></div>\n\t<div class=\"wrapper\">\n\t\t<div class=\"content2\"></div>\n\t</div>\n{% endcodeblock %}\n给任意一个content添加一个含有BFC的父容器，就可以解决这个问题。\n![margin重叠](http://7xkj1z.com1.z0.glb.clouddn.com/BFC5.png)\n同样的问题会发生在其它块级元素中，比如< p>标签也会发生这种现象。\n\n---\nBFC可以看到BFC\n===\n叫这个标题感觉怪怪的，看一下下面的例子你就明白了。\n\n{% codeblock lang:css %}\n\t/* CSS代码 */\n\t.content1{\n\t\theight: 100px;\n\t\twidth: 100px;\n\t\tbackground-color: red;\n\t\tfloat: left;\n\t}\n\t.content2{\n\t\theight: 200px;\n\t\twidth: 200px;\n\t\tbackground-color: green;\n\t\t/*float: left;*/\n\t}\n{% endcodeblock %}\n{% codeblock lang:html %}\n\t// HTML代码\n\t<div class=\"content1\"></div>\n\t<div class=\"content2\"></div>\n{% endcodeblock %}\n这个例子显示的结果为：\n![margin重叠](http://7xkj1z.com1.z0.glb.clouddn.com/BFC6.png)\n这段代码第一个容器中添加了\"float: left;\"属性,这样content1就会覆盖content2，如果我们不想让它覆盖，可以给第二个容器添加属性\"float:left;\"。实际上，我们也可以给第二个容器中添加BFC的触发条件，这样也同样能解决这个问题。这个过程，你可以这样理解，第一个容器添加了\"float:left;\"这个BFC触发条件，使第二个容器看不到它，所以会覆盖，如果想让第二个容器看到第一个容器，就为它添加一个BFC，因为BFC可以看到BFC。（注意：有一点要特殊说明，虽然BFC可以解决这个问题，但是其中不包括position，因为实际上position是个定位属性，在这个问题中，即使BFC看到了BFC，它也会按照position原本的定位去执行，如果觉得我说的抽象，可以自己敲代码试试。）\n\n---\n清除浮动\n===\n至于清除浮动的原理和为什么要清除浮动在这里不细说，过两天可能会单独写一章来说清除浮动。这里要说的是利用BFC可以清除浮动。\n{% codeblock lang:css %}\n\t/* CSS代码 */\n\t.content1{\n\t\theight: 100px;\n\t\twidth: 100px;\n\t\tbackground-color: red;\n\t\tfloat: left;\n\t}\n\t.wrapper{\n\t\tborder: 5px solid #000;\n\t}\n{% endcodeblock %}\n{% codeblock lang:html %}\n\t// HTML代码\n\t<div class=\"wrapper\">\n\t\t<div class=\"content\"></div>\n\t\t<div class=\"content\"></div>\n\t\t<div class=\"content\"></div>\n\t</div>\n{% endcodeblock %}\n![margin重叠](http://7xkj1z.com1.z0.glb.clouddn.com/BFC7.png)\n这里给父容器设置了border，是为了更方便的看出父容器没有被撑开，所以需要清除浮动。用BFC清除浮动很简单，只需要在父容器中添加BFC触发条件就可以。比如：\n{% codeblock lang:css %}\n\t/* CSS代码 */\n\t.content1{\n\t\theight: 100px;\n\t\twidth: 100px;\n\t\tbackground-color: red;\n\t\tfloat: left;\n\t}\n\t.wrapper{\n\t\tborder: 5px solid #000;\n\t\toverflow: hidden;\n\t}\n{% endcodeblock %}\n{% codeblock lang:html %}\n\t// HTML代码\n\t<div class=\"wrapper\">\n\t\t<div class=\"content\"></div>\n\t\t<div class=\"content\"></div>\n\t\t<div class=\"content\"></div>\n\t</div>\n{% endcodeblock %}\n![margin重叠](http://7xkj1z.com1.z0.glb.clouddn.com/BFC8.png)\n再来一个添加\"float:left;\"的效果图\n![margin重叠](http://7xkj1z.com1.z0.glb.clouddn.com/BFC9.png)\n注意：利用BFC清除浮动其实有很多问题\nposition:relative 在这里不会清除浮动，不细说。\nposition:absolute 将父容器的定位都改变了，在开发中这不是一个很好的做法。\nfloat: left 也是同理，虽然清除了子元素的浮动，却给父元素添加了浮动，如果不是特殊需要，这种方法也不是一个好的方法。\noverflow: hidden 有一个致命的问题，如果内容超出父容器或定位到父容器，就不会被看到，而且它不是按宽高撑开的。\ndisplay: inline-block 在IE6 和IE7中没有这个属性值，所以行不通。\n补充: IE6 和 IE7 中清除浮动，我们需要触发其中的hasLayout为true，hasLayout为true就相当于BFC，那么怎么触发呢？只要将zoom设置为不为0的值。（zoom值为同比例缩放）,下面是css hack解决方式(开发中尽量避免css hack)。\n{% codeblock lang:css %}\n\t/* CSS代码 */\n\t.content1{\n\t\theight: 100px;\n\t\twidth: 100px;\n\t\tbackground-color: red;\n\t\tfloat: left;\n\t}\n\t.wrapper{\n\t\tborder: 5px solid #000;\n\t\toverflow: hidden;\n\t\t_zoom: 1;\tIE6\n\t\t*zoom: 1; \tIE6/7\n\t}\n{% endcodeblock %}\n{% codeblock lang:html %}\n\t// HTML代码\n\t<div class=\"wrapper\">\n\t\t<div class=\"content\"></div>\n\t\t<div class=\"content\"></div>\n\t\t<div class=\"content\"></div>\n\t</div>\n{% endcodeblock %}\n\n---\nBFC的一些常见的简单应用就写到这里，可能后续还会有补充。关于BFC详细原理可以自己查一下，网上有很多介绍。有什么问题欢迎评论！","source":"_posts/浅谈BFC实际应用.md","raw":"title: 浅谈BFC的实际应用\ndate: 2015-08-8 12:19:21\ntags: CSS\ncategories: 浅谈BFC实际应用\nkeywords: BFC, CSS\n---\nBFC在开发非常重要，每个人对其理解都有不同。本文章主要讨论BFC的一些实际应用。\n<!--more-->\n　　BFC 的英文全称是：block formatting context（块级格式化文本）。BFC可以理解为一个独立的渲染块，或者说是CSS布局单位。\n\n常见BFC的触发条件\n===\n---\n常见BFC的触发条件有：\n\n{% codeblock lang:css %}\n\tposition: absolute/fixed;\n\tdiplay: inline-block/table-cells/table-captions;\n\toverflow: hidden;/* 不为visible的值 */\n\tfloat: left/right;\n{% endcodeblock %}\n下面来简单的看一个例子。\n由于< span>标签默认是行级元素，所以不能给其设置宽高，如果添加属性diplay：block; 它就可以设置宽高了。\n{% codeblock lang:css %}\n\tspan{\n\t\tposition: absolute;\n\t\twidth: 100px;\n\t\theight: 100px;\n\t\tbackground-color: #000;\n\t}\n{% endcodeblock %}\n\n将这样一段CSS添加给< span>标签，改变的宽高就会生效。但并没有给其添加display:block属性。同样的\"float: left/right;\"和 \"position: absolute/fixed;\"也都会使其生效。实际上在使用这些属性的过程中，相当于隐式的给< span>标签添加了属性\"display: inline-block\"。\n这一性质其实并不常用，因为即使你不知道这些，你也可以在< span>标签中手动的添加一个\"display: block\"来改变其宽高。\n\n---\nmargin塌陷问题\n===\n先看一下这段代码：\n\n{% codeblock lang:css %}\n/* CSS代码 */\n\t.wrapper{\n\t\twidth: 200px;\n\t\theight: 200px;\n\t\tbackground-color: #fcc\n\t}\n\t.content{\n\t\tmargin-top: 100px;\n\t\twidth: 100px;\n\t\theight: 100px;\n\t\tbackground-color: #ffc;\n\t}\n{% endcodeblock %}\n{% codeblock lang:html %}\n// HTML代码\n\t<div class=\"wrapper\">\n\t\t<div class=\"content\"></div>\n\t</div>\n{% endcodeblock %}\n\n我们再看一下这段代码执行后的效果：\n![margin塌陷](http://7xkj1z.com1.z0.glb.clouddn.com/BFC1.png)\n按正常的理解，这段代码执行后的效果不应该是这样，我们想要的是子容器在父容器内部产生margin-top，而不是父容器产生margin-top。这就是大家熟知的margin塌陷问题，解决这个问题的方法有很多，有一种bug解决方法，可以在\".wrapper\"中加入\"border:1px solid #ccc;\"。当然，正常的解决方式就是利用BFC。\n将触发BFC的条件属性写入\".wrapper\"中，在这里不在写出代码。就可以解决这个问题。解决之后的效果是这样的：\n![margin塌陷](http://7xkj1z.com1.z0.glb.clouddn.com/BFC2.png)\n上面的例子中还有一个很好玩的地方：\n\n{% codeblock lang:css %}\n/* CSS代码 */\n\t.wrapper{\n\t\twidth: 200px;\n\t\theight: 200px;\n\t\tbackground-color: #fcc\n\t\tmargin-top: 100px;\n\t}\n\t.content{\n\t\tmargin-top: 100px;\n\t\twidth: 100px;\n\t\theight: 100px;\n\t\tbackground-color: #ffc;\n\t}\n{% endcodeblock %}\n{% codeblock lang:html %}\n// HTML代码\n\t<div class=\"wrapper\">\n\t\t<div class=\"content\"></div>\n\t</div>\n{% endcodeblock %}\n这段代码执行的结果与上面的一样，为什么我们给父容器添加的margin-top没有生效？其实这里不仅仅是发生了margin塌陷现象，实际上还发生了margin的重叠现象。子容器的margin-top与父容器的margin-top重叠了。解决办法同上，还是给父容器添加BFC。添加完BFC就会出现我们想要的效果。\n![margin塌陷](http://7xkj1z.com1.z0.glb.clouddn.com/BFC3.png)\n\n---\nmargin重叠\n===\n上面例子里有说到margin重叠，下面还有几种margin重叠的问题。看一下下面的例子。\n{% codeblock lang:css %}\n/* CSS代码 */\n\t.content1{\n\t\theight: 100px;\n\t\twidth: 100px;\n\t\tbackground-color: red;\n\t\tmargin-bottom: 100px;\n\t}\n\t.content2{\n\t\theight: 100px;\n\t\twidth: 100px;\n\t\tbackground-color: green;\n\t\tmargin-top: 100px;\n\t}\n{% endcodeblock %}\n{% codeblock lang:html %}\n// HTML代码\n\t<div class=\"content1\"></div>\n\t<div class=\"content2\"></div>\n{% endcodeblock %}\n这段代码运行的结果为：\n![margin重叠](http://7xkj1z.com1.z0.glb.clouddn.com/BFC4.png)\n看出问题了么，这两个margin发生了重叠，中间只有 100px 的距离。实际上，在这里的margin会取两个margin中大的数值作为实际显示出的数值。解决这个问题同样使用BFC。\n{% codeblock lang:css %}\n/* CSS代码 */\n\t.content1{\n\t\theight: 100px;\n\t\twidth: 100px;\n\t\tbackground-color: red;\n\t\tmargin-bottom: 100px;\n\t}\n\t.content2{\n\t\theight: 100px;\n\t\twidth: 100px;\n\t\tbackground-color: green;\n\t\tmargin-top: 100px;\n\t}\n\t.wrapper{\n\t\toverflow: hidden;\n\t\t/*position: fixed;*/\n\t\t/*position: absolute;*/\n\t\t/*display: inline-block;*/\n\t\t/*float: left;*/\n\t}\n{% endcodeblock %}\n{% codeblock lang:html %}\n// HTML代码\n\t<div class=\"content1\"></div>\n\t<div class=\"wrapper\">\n\t\t<div class=\"content2\"></div>\n\t</div>\n{% endcodeblock %}\n给任意一个content添加一个含有BFC的父容器，就可以解决这个问题。\n![margin重叠](http://7xkj1z.com1.z0.glb.clouddn.com/BFC5.png)\n同样的问题会发生在其它块级元素中，比如< p>标签也会发生这种现象。\n\n---\nBFC可以看到BFC\n===\n叫这个标题感觉怪怪的，看一下下面的例子你就明白了。\n\n{% codeblock lang:css %}\n\t/* CSS代码 */\n\t.content1{\n\t\theight: 100px;\n\t\twidth: 100px;\n\t\tbackground-color: red;\n\t\tfloat: left;\n\t}\n\t.content2{\n\t\theight: 200px;\n\t\twidth: 200px;\n\t\tbackground-color: green;\n\t\t/*float: left;*/\n\t}\n{% endcodeblock %}\n{% codeblock lang:html %}\n\t// HTML代码\n\t<div class=\"content1\"></div>\n\t<div class=\"content2\"></div>\n{% endcodeblock %}\n这个例子显示的结果为：\n![margin重叠](http://7xkj1z.com1.z0.glb.clouddn.com/BFC6.png)\n这段代码第一个容器中添加了\"float: left;\"属性,这样content1就会覆盖content2，如果我们不想让它覆盖，可以给第二个容器添加属性\"float:left;\"。实际上，我们也可以给第二个容器中添加BFC的触发条件，这样也同样能解决这个问题。这个过程，你可以这样理解，第一个容器添加了\"float:left;\"这个BFC触发条件，使第二个容器看不到它，所以会覆盖，如果想让第二个容器看到第一个容器，就为它添加一个BFC，因为BFC可以看到BFC。（注意：有一点要特殊说明，虽然BFC可以解决这个问题，但是其中不包括position，因为实际上position是个定位属性，在这个问题中，即使BFC看到了BFC，它也会按照position原本的定位去执行，如果觉得我说的抽象，可以自己敲代码试试。）\n\n---\n清除浮动\n===\n至于清除浮动的原理和为什么要清除浮动在这里不细说，过两天可能会单独写一章来说清除浮动。这里要说的是利用BFC可以清除浮动。\n{% codeblock lang:css %}\n\t/* CSS代码 */\n\t.content1{\n\t\theight: 100px;\n\t\twidth: 100px;\n\t\tbackground-color: red;\n\t\tfloat: left;\n\t}\n\t.wrapper{\n\t\tborder: 5px solid #000;\n\t}\n{% endcodeblock %}\n{% codeblock lang:html %}\n\t// HTML代码\n\t<div class=\"wrapper\">\n\t\t<div class=\"content\"></div>\n\t\t<div class=\"content\"></div>\n\t\t<div class=\"content\"></div>\n\t</div>\n{% endcodeblock %}\n![margin重叠](http://7xkj1z.com1.z0.glb.clouddn.com/BFC7.png)\n这里给父容器设置了border，是为了更方便的看出父容器没有被撑开，所以需要清除浮动。用BFC清除浮动很简单，只需要在父容器中添加BFC触发条件就可以。比如：\n{% codeblock lang:css %}\n\t/* CSS代码 */\n\t.content1{\n\t\theight: 100px;\n\t\twidth: 100px;\n\t\tbackground-color: red;\n\t\tfloat: left;\n\t}\n\t.wrapper{\n\t\tborder: 5px solid #000;\n\t\toverflow: hidden;\n\t}\n{% endcodeblock %}\n{% codeblock lang:html %}\n\t// HTML代码\n\t<div class=\"wrapper\">\n\t\t<div class=\"content\"></div>\n\t\t<div class=\"content\"></div>\n\t\t<div class=\"content\"></div>\n\t</div>\n{% endcodeblock %}\n![margin重叠](http://7xkj1z.com1.z0.glb.clouddn.com/BFC8.png)\n再来一个添加\"float:left;\"的效果图\n![margin重叠](http://7xkj1z.com1.z0.glb.clouddn.com/BFC9.png)\n注意：利用BFC清除浮动其实有很多问题\nposition:relative 在这里不会清除浮动，不细说。\nposition:absolute 将父容器的定位都改变了，在开发中这不是一个很好的做法。\nfloat: left 也是同理，虽然清除了子元素的浮动，却给父元素添加了浮动，如果不是特殊需要，这种方法也不是一个好的方法。\noverflow: hidden 有一个致命的问题，如果内容超出父容器或定位到父容器，就不会被看到，而且它不是按宽高撑开的。\ndisplay: inline-block 在IE6 和IE7中没有这个属性值，所以行不通。\n补充: IE6 和 IE7 中清除浮动，我们需要触发其中的hasLayout为true，hasLayout为true就相当于BFC，那么怎么触发呢？只要将zoom设置为不为0的值。（zoom值为同比例缩放）,下面是css hack解决方式(开发中尽量避免css hack)。\n{% codeblock lang:css %}\n\t/* CSS代码 */\n\t.content1{\n\t\theight: 100px;\n\t\twidth: 100px;\n\t\tbackground-color: red;\n\t\tfloat: left;\n\t}\n\t.wrapper{\n\t\tborder: 5px solid #000;\n\t\toverflow: hidden;\n\t\t_zoom: 1;\tIE6\n\t\t*zoom: 1; \tIE6/7\n\t}\n{% endcodeblock %}\n{% codeblock lang:html %}\n\t// HTML代码\n\t<div class=\"wrapper\">\n\t\t<div class=\"content\"></div>\n\t\t<div class=\"content\"></div>\n\t\t<div class=\"content\"></div>\n\t</div>\n{% endcodeblock %}\n\n---\nBFC的一些常见的简单应用就写到这里，可能后续还会有补充。关于BFC详细原理可以自己查一下，网上有很多介绍。有什么问题欢迎评论！","slug":"浅谈BFC实际应用","published":1,"updated":"2016-10-31T07:25:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciuyzluvo001se6tbd1mca9cn","content":"<p>BFC在开发非常重要，每个人对其理解都有不同。本文章主要讨论BFC的一些实际应用。<br><a id=\"more\"></a><br>　　BFC 的英文全称是：block formatting context（块级格式化文本）。BFC可以理解为一个独立的渲染块，或者说是CSS布局单位。</p>\n<h1 id=\"常见BFC的触发条件\"><a href=\"#常见BFC的触发条件\" class=\"headerlink\" title=\"常见BFC的触发条件\"></a>常见BFC的触发条件</h1><hr>\n<p>常见BFC的触发条件有：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">position: absolute/fixed;</div><div class=\"line\">diplay: inline-block/table-cells/table-captions;</div><div class=\"line\">overflow: hidden;/* 不为visible的值 */</div><div class=\"line\">float: left/right;</div></pre></td></tr></table></figure>\n<p>下面来简单的看一个例子。<br>由于&lt; span&gt;标签默认是行级元素，所以不能给其设置宽高，如果添加属性diplay：block; 它就可以设置宽高了。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">span</span>&#123;</div><div class=\"line\">\t<span class=\"attribute\">position</span>: absolute;</div><div class=\"line\">\t<span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t<span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t<span class=\"attribute\">background-color</span>: <span class=\"number\">#000</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>将这样一段CSS添加给&lt; span&gt;标签，改变的宽高就会生效。但并没有给其添加display:block属性。同样的”float: left/right;”和 “position: absolute/fixed;”也都会使其生效。实际上在使用这些属性的过程中，相当于隐式的给&lt; span&gt;标签添加了属性”display: inline-block”。<br>这一性质其实并不常用，因为即使你不知道这些，你也可以在&lt; span&gt;标签中手动的添加一个”display: block”来改变其宽高。</p>\n<hr>\n<h1 id=\"margin塌陷问题\"><a href=\"#margin塌陷问题\" class=\"headerlink\" title=\"margin塌陷问题\"></a>margin塌陷问题</h1><p>先看一下这段代码：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* CSS代码 */</span></div><div class=\"line\">\t<span class=\"selector-class\">.wrapper</span>&#123;</div><div class=\"line\">\t\t<span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</div><div class=\"line\">\t\t<span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</div><div class=\"line\">\t\t<span class=\"attribute\">background-color</span>: <span class=\"number\">#fcc</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"selector-class\">.content</span>&#123;</div><div class=\"line\">\t\t<span class=\"attribute\">margin-top</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t\t<span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t\t<span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t\t<span class=\"attribute\">background-color</span>: <span class=\"number\">#ffc</span>;</div><div class=\"line\">\t&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">// HTML代码</div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrapper\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>我们再看一下这段代码执行后的效果：<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/BFC1.png\" alt=\"margin塌陷\"><br>按正常的理解，这段代码执行后的效果不应该是这样，我们想要的是子容器在父容器内部产生margin-top，而不是父容器产生margin-top。这就是大家熟知的margin塌陷问题，解决这个问题的方法有很多，有一种bug解决方法，可以在”.wrapper”中加入”border:1px solid #ccc;”。当然，正常的解决方式就是利用BFC。<br>将触发BFC的条件属性写入”.wrapper”中，在这里不在写出代码。就可以解决这个问题。解决之后的效果是这样的：<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/BFC2.png\" alt=\"margin塌陷\"><br>上面的例子中还有一个很好玩的地方：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* CSS代码 */</span></div><div class=\"line\">\t<span class=\"selector-class\">.wrapper</span>&#123;</div><div class=\"line\">\t\t<span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</div><div class=\"line\">\t\t<span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</div><div class=\"line\">\t\t<span class=\"attribute\">background-color</span>: <span class=\"number\">#fcc</span></div><div class=\"line\">\t\tmargin-top: <span class=\"number\">100px</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"selector-class\">.content</span>&#123;</div><div class=\"line\">\t\t<span class=\"attribute\">margin-top</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t\t<span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t\t<span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t\t<span class=\"attribute\">background-color</span>: <span class=\"number\">#ffc</span>;</div><div class=\"line\">\t&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">// HTML代码</div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrapper\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这段代码执行的结果与上面的一样，为什么我们给父容器添加的margin-top没有生效？其实这里不仅仅是发生了margin塌陷现象，实际上还发生了margin的重叠现象。子容器的margin-top与父容器的margin-top重叠了。解决办法同上，还是给父容器添加BFC。添加完BFC就会出现我们想要的效果。<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/BFC3.png\" alt=\"margin塌陷\"></p>\n<hr>\n<h1 id=\"margin重叠\"><a href=\"#margin重叠\" class=\"headerlink\" title=\"margin重叠\"></a>margin重叠</h1><p>上面例子里有说到margin重叠，下面还有几种margin重叠的问题。看一下下面的例子。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* CSS代码 */</span></div><div class=\"line\">\t<span class=\"selector-class\">.content1</span>&#123;</div><div class=\"line\">\t\t<span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t\t<span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t\t<span class=\"attribute\">background-color</span>: red;</div><div class=\"line\">\t\t<span class=\"attribute\">margin-bottom</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"selector-class\">.content2</span>&#123;</div><div class=\"line\">\t\t<span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t\t<span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t\t<span class=\"attribute\">background-color</span>: green;</div><div class=\"line\">\t\t<span class=\"attribute\">margin-top</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t&#125;</div></pre></td></tr></table></figure><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">// HTML代码</div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content1\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content2\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure><br>这段代码运行的结果为：<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/BFC4.png\" alt=\"margin重叠\"><br>看出问题了么，这两个margin发生了重叠，中间只有 100px 的距离。实际上，在这里的margin会取两个margin中大的数值作为实际显示出的数值。解决这个问题同样使用BFC。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* CSS代码 */</span></div><div class=\"line\">\t<span class=\"selector-class\">.content1</span>&#123;</div><div class=\"line\">\t\t<span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t\t<span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t\t<span class=\"attribute\">background-color</span>: red;</div><div class=\"line\">\t\t<span class=\"attribute\">margin-bottom</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"selector-class\">.content2</span>&#123;</div><div class=\"line\">\t\t<span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t\t<span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t\t<span class=\"attribute\">background-color</span>: green;</div><div class=\"line\">\t\t<span class=\"attribute\">margin-top</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"selector-class\">.wrapper</span>&#123;</div><div class=\"line\">\t\t<span class=\"attribute\">overflow</span>: hidden;</div><div class=\"line\">\t\t<span class=\"comment\">/*position: fixed;*/</span></div><div class=\"line\">\t\t<span class=\"comment\">/*position: absolute;*/</span></div><div class=\"line\">\t\t<span class=\"comment\">/*display: inline-block;*/</span></div><div class=\"line\">\t\t<span class=\"comment\">/*float: left;*/</span></div><div class=\"line\">\t&#125;</div></pre></td></tr></table></figure><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// HTML代码</div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content1\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrapper\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content2\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure><br>给任意一个content添加一个含有BFC的父容器，就可以解决这个问题。<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/BFC5.png\" alt=\"margin重叠\"><br>同样的问题会发生在其它块级元素中，比如&lt; p&gt;标签也会发生这种现象。</p>\n<hr>\n<h1 id=\"BFC可以看到BFC\"><a href=\"#BFC可以看到BFC\" class=\"headerlink\" title=\"BFC可以看到BFC\"></a>BFC可以看到BFC</h1><p>叫这个标题感觉怪怪的，看一下下面的例子你就明白了。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* CSS代码 */</span></div><div class=\"line\"><span class=\"selector-class\">.content1</span>&#123;</div><div class=\"line\">\t<span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t<span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t<span class=\"attribute\">background-color</span>: red;</div><div class=\"line\">\t<span class=\"attribute\">float</span>: left;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.content2</span>&#123;</div><div class=\"line\">\t<span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</div><div class=\"line\">\t<span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</div><div class=\"line\">\t<span class=\"attribute\">background-color</span>: green;</div><div class=\"line\">\t<span class=\"comment\">/*float: left;*/</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">// HTML代码</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content1\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content2\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这个例子显示的结果为：<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/BFC6.png\" alt=\"margin重叠\"><br>这段代码第一个容器中添加了”float: left;”属性,这样content1就会覆盖content2，如果我们不想让它覆盖，可以给第二个容器添加属性”float:left;”。实际上，我们也可以给第二个容器中添加BFC的触发条件，这样也同样能解决这个问题。这个过程，你可以这样理解，第一个容器添加了”float:left;”这个BFC触发条件，使第二个容器看不到它，所以会覆盖，如果想让第二个容器看到第一个容器，就为它添加一个BFC，因为BFC可以看到BFC。（注意：有一点要特殊说明，虽然BFC可以解决这个问题，但是其中不包括position，因为实际上position是个定位属性，在这个问题中，即使BFC看到了BFC，它也会按照position原本的定位去执行，如果觉得我说的抽象，可以自己敲代码试试。）</p>\n<hr>\n<h1 id=\"清除浮动\"><a href=\"#清除浮动\" class=\"headerlink\" title=\"清除浮动\"></a>清除浮动</h1><p>至于清除浮动的原理和为什么要清除浮动在这里不细说，过两天可能会单独写一章来说清除浮动。这里要说的是利用BFC可以清除浮动。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* CSS代码 */</span></div><div class=\"line\"><span class=\"selector-class\">.content1</span>&#123;</div><div class=\"line\">\t<span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t<span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t<span class=\"attribute\">background-color</span>: red;</div><div class=\"line\">\t<span class=\"attribute\">float</span>: left;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrapper</span>&#123;</div><div class=\"line\">\t<span class=\"attribute\">border</span>: <span class=\"number\">5px</span> solid <span class=\"number\">#000</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// HTML代码</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrapper\"</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure><br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/BFC7.png\" alt=\"margin重叠\"><br>这里给父容器设置了border，是为了更方便的看出父容器没有被撑开，所以需要清除浮动。用BFC清除浮动很简单，只需要在父容器中添加BFC触发条件就可以。比如：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* CSS代码 */</span></div><div class=\"line\"><span class=\"selector-class\">.content1</span>&#123;</div><div class=\"line\">\t<span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t<span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t<span class=\"attribute\">background-color</span>: red;</div><div class=\"line\">\t<span class=\"attribute\">float</span>: left;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrapper</span>&#123;</div><div class=\"line\">\t<span class=\"attribute\">border</span>: <span class=\"number\">5px</span> solid <span class=\"number\">#000</span>;</div><div class=\"line\">\t<span class=\"attribute\">overflow</span>: hidden;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// HTML代码</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrapper\"</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure><br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/BFC8.png\" alt=\"margin重叠\"><br>再来一个添加”float:left;”的效果图<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/BFC9.png\" alt=\"margin重叠\"><br>注意：利用BFC清除浮动其实有很多问题<br>position:relative 在这里不会清除浮动，不细说。<br>position:absolute 将父容器的定位都改变了，在开发中这不是一个很好的做法。<br>float: left 也是同理，虽然清除了子元素的浮动，却给父元素添加了浮动，如果不是特殊需要，这种方法也不是一个好的方法。<br>overflow: hidden 有一个致命的问题，如果内容超出父容器或定位到父容器，就不会被看到，而且它不是按宽高撑开的。<br>display: inline-block 在IE6 和IE7中没有这个属性值，所以行不通。<br>补充: IE6 和 IE7 中清除浮动，我们需要触发其中的hasLayout为true，hasLayout为true就相当于BFC，那么怎么触发呢？只要将zoom设置为不为0的值。（zoom值为同比例缩放）,下面是css hack解决方式(开发中尽量避免css hack)。<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">/* CSS代码 */</div><div class=\"line\">.content1&#123;</div><div class=\"line\">\theight: 100px;</div><div class=\"line\">\twidth: 100px;</div><div class=\"line\">\tbackground-color: red;</div><div class=\"line\">\tfloat: left;</div><div class=\"line\">&#125;</div><div class=\"line\">.wrapper&#123;</div><div class=\"line\">\tborder: 5px solid #000;</div><div class=\"line\">\toverflow: hidden;</div><div class=\"line\">\t_zoom: 1;\tIE6</div><div class=\"line\">\t*zoom: 1; \tIE6/7</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// HTML代码</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrapper\"</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<hr>\n<p>BFC的一些常见的简单应用就写到这里，可能后续还会有补充。关于BFC详细原理可以自己查一下，网上有很多介绍。有什么问题欢迎评论！</p>\n","excerpt":"<p>BFC在开发非常重要，每个人对其理解都有不同。本文章主要讨论BFC的一些实际应用。<br>","more":"<br>　　BFC 的英文全称是：block formatting context（块级格式化文本）。BFC可以理解为一个独立的渲染块，或者说是CSS布局单位。</p>\n<h1 id=\"常见BFC的触发条件\"><a href=\"#常见BFC的触发条件\" class=\"headerlink\" title=\"常见BFC的触发条件\"></a>常见BFC的触发条件</h1><hr>\n<p>常见BFC的触发条件有：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">position: absolute/fixed;</div><div class=\"line\">diplay: inline-block/table-cells/table-captions;</div><div class=\"line\">overflow: hidden;/* 不为visible的值 */</div><div class=\"line\">float: left/right;</div></pre></td></tr></table></figure>\n<p>下面来简单的看一个例子。<br>由于&lt; span&gt;标签默认是行级元素，所以不能给其设置宽高，如果添加属性diplay：block; 它就可以设置宽高了。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">span</span>&#123;</div><div class=\"line\">\t<span class=\"attribute\">position</span>: absolute;</div><div class=\"line\">\t<span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t<span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t<span class=\"attribute\">background-color</span>: <span class=\"number\">#000</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>将这样一段CSS添加给&lt; span&gt;标签，改变的宽高就会生效。但并没有给其添加display:block属性。同样的”float: left/right;”和 “position: absolute/fixed;”也都会使其生效。实际上在使用这些属性的过程中，相当于隐式的给&lt; span&gt;标签添加了属性”display: inline-block”。<br>这一性质其实并不常用，因为即使你不知道这些，你也可以在&lt; span&gt;标签中手动的添加一个”display: block”来改变其宽高。</p>\n<hr>\n<h1 id=\"margin塌陷问题\"><a href=\"#margin塌陷问题\" class=\"headerlink\" title=\"margin塌陷问题\"></a>margin塌陷问题</h1><p>先看一下这段代码：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* CSS代码 */</span></div><div class=\"line\">\t<span class=\"selector-class\">.wrapper</span>&#123;</div><div class=\"line\">\t\t<span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</div><div class=\"line\">\t\t<span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</div><div class=\"line\">\t\t<span class=\"attribute\">background-color</span>: <span class=\"number\">#fcc</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"selector-class\">.content</span>&#123;</div><div class=\"line\">\t\t<span class=\"attribute\">margin-top</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t\t<span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t\t<span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t\t<span class=\"attribute\">background-color</span>: <span class=\"number\">#ffc</span>;</div><div class=\"line\">\t&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">// HTML代码</div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrapper\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>我们再看一下这段代码执行后的效果：<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/BFC1.png\" alt=\"margin塌陷\"><br>按正常的理解，这段代码执行后的效果不应该是这样，我们想要的是子容器在父容器内部产生margin-top，而不是父容器产生margin-top。这就是大家熟知的margin塌陷问题，解决这个问题的方法有很多，有一种bug解决方法，可以在”.wrapper”中加入”border:1px solid #ccc;”。当然，正常的解决方式就是利用BFC。<br>将触发BFC的条件属性写入”.wrapper”中，在这里不在写出代码。就可以解决这个问题。解决之后的效果是这样的：<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/BFC2.png\" alt=\"margin塌陷\"><br>上面的例子中还有一个很好玩的地方：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* CSS代码 */</span></div><div class=\"line\">\t<span class=\"selector-class\">.wrapper</span>&#123;</div><div class=\"line\">\t\t<span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</div><div class=\"line\">\t\t<span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</div><div class=\"line\">\t\t<span class=\"attribute\">background-color</span>: <span class=\"number\">#fcc</span></div><div class=\"line\">\t\tmargin-top: <span class=\"number\">100px</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"selector-class\">.content</span>&#123;</div><div class=\"line\">\t\t<span class=\"attribute\">margin-top</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t\t<span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t\t<span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t\t<span class=\"attribute\">background-color</span>: <span class=\"number\">#ffc</span>;</div><div class=\"line\">\t&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">// HTML代码</div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrapper\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这段代码执行的结果与上面的一样，为什么我们给父容器添加的margin-top没有生效？其实这里不仅仅是发生了margin塌陷现象，实际上还发生了margin的重叠现象。子容器的margin-top与父容器的margin-top重叠了。解决办法同上，还是给父容器添加BFC。添加完BFC就会出现我们想要的效果。<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/BFC3.png\" alt=\"margin塌陷\"></p>\n<hr>\n<h1 id=\"margin重叠\"><a href=\"#margin重叠\" class=\"headerlink\" title=\"margin重叠\"></a>margin重叠</h1><p>上面例子里有说到margin重叠，下面还有几种margin重叠的问题。看一下下面的例子。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* CSS代码 */</span></div><div class=\"line\">\t<span class=\"selector-class\">.content1</span>&#123;</div><div class=\"line\">\t\t<span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t\t<span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t\t<span class=\"attribute\">background-color</span>: red;</div><div class=\"line\">\t\t<span class=\"attribute\">margin-bottom</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"selector-class\">.content2</span>&#123;</div><div class=\"line\">\t\t<span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t\t<span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t\t<span class=\"attribute\">background-color</span>: green;</div><div class=\"line\">\t\t<span class=\"attribute\">margin-top</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t&#125;</div></pre></td></tr></table></figure><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">// HTML代码</div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content1\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content2\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure><br>这段代码运行的结果为：<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/BFC4.png\" alt=\"margin重叠\"><br>看出问题了么，这两个margin发生了重叠，中间只有 100px 的距离。实际上，在这里的margin会取两个margin中大的数值作为实际显示出的数值。解决这个问题同样使用BFC。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* CSS代码 */</span></div><div class=\"line\">\t<span class=\"selector-class\">.content1</span>&#123;</div><div class=\"line\">\t\t<span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t\t<span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t\t<span class=\"attribute\">background-color</span>: red;</div><div class=\"line\">\t\t<span class=\"attribute\">margin-bottom</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"selector-class\">.content2</span>&#123;</div><div class=\"line\">\t\t<span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t\t<span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t\t<span class=\"attribute\">background-color</span>: green;</div><div class=\"line\">\t\t<span class=\"attribute\">margin-top</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"selector-class\">.wrapper</span>&#123;</div><div class=\"line\">\t\t<span class=\"attribute\">overflow</span>: hidden;</div><div class=\"line\">\t\t<span class=\"comment\">/*position: fixed;*/</span></div><div class=\"line\">\t\t<span class=\"comment\">/*position: absolute;*/</span></div><div class=\"line\">\t\t<span class=\"comment\">/*display: inline-block;*/</span></div><div class=\"line\">\t\t<span class=\"comment\">/*float: left;*/</span></div><div class=\"line\">\t&#125;</div></pre></td></tr></table></figure><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// HTML代码</div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content1\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrapper\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content2\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure><br>给任意一个content添加一个含有BFC的父容器，就可以解决这个问题。<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/BFC5.png\" alt=\"margin重叠\"><br>同样的问题会发生在其它块级元素中，比如&lt; p&gt;标签也会发生这种现象。</p>\n<hr>\n<h1 id=\"BFC可以看到BFC\"><a href=\"#BFC可以看到BFC\" class=\"headerlink\" title=\"BFC可以看到BFC\"></a>BFC可以看到BFC</h1><p>叫这个标题感觉怪怪的，看一下下面的例子你就明白了。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* CSS代码 */</span></div><div class=\"line\"><span class=\"selector-class\">.content1</span>&#123;</div><div class=\"line\">\t<span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t<span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t<span class=\"attribute\">background-color</span>: red;</div><div class=\"line\">\t<span class=\"attribute\">float</span>: left;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.content2</span>&#123;</div><div class=\"line\">\t<span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</div><div class=\"line\">\t<span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</div><div class=\"line\">\t<span class=\"attribute\">background-color</span>: green;</div><div class=\"line\">\t<span class=\"comment\">/*float: left;*/</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">// HTML代码</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content1\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content2\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这个例子显示的结果为：<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/BFC6.png\" alt=\"margin重叠\"><br>这段代码第一个容器中添加了”float: left;”属性,这样content1就会覆盖content2，如果我们不想让它覆盖，可以给第二个容器添加属性”float:left;”。实际上，我们也可以给第二个容器中添加BFC的触发条件，这样也同样能解决这个问题。这个过程，你可以这样理解，第一个容器添加了”float:left;”这个BFC触发条件，使第二个容器看不到它，所以会覆盖，如果想让第二个容器看到第一个容器，就为它添加一个BFC，因为BFC可以看到BFC。（注意：有一点要特殊说明，虽然BFC可以解决这个问题，但是其中不包括position，因为实际上position是个定位属性，在这个问题中，即使BFC看到了BFC，它也会按照position原本的定位去执行，如果觉得我说的抽象，可以自己敲代码试试。）</p>\n<hr>\n<h1 id=\"清除浮动\"><a href=\"#清除浮动\" class=\"headerlink\" title=\"清除浮动\"></a>清除浮动</h1><p>至于清除浮动的原理和为什么要清除浮动在这里不细说，过两天可能会单独写一章来说清除浮动。这里要说的是利用BFC可以清除浮动。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* CSS代码 */</span></div><div class=\"line\"><span class=\"selector-class\">.content1</span>&#123;</div><div class=\"line\">\t<span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t<span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t<span class=\"attribute\">background-color</span>: red;</div><div class=\"line\">\t<span class=\"attribute\">float</span>: left;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrapper</span>&#123;</div><div class=\"line\">\t<span class=\"attribute\">border</span>: <span class=\"number\">5px</span> solid <span class=\"number\">#000</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// HTML代码</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrapper\"</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure><br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/BFC7.png\" alt=\"margin重叠\"><br>这里给父容器设置了border，是为了更方便的看出父容器没有被撑开，所以需要清除浮动。用BFC清除浮动很简单，只需要在父容器中添加BFC触发条件就可以。比如：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* CSS代码 */</span></div><div class=\"line\"><span class=\"selector-class\">.content1</span>&#123;</div><div class=\"line\">\t<span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t<span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t<span class=\"attribute\">background-color</span>: red;</div><div class=\"line\">\t<span class=\"attribute\">float</span>: left;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrapper</span>&#123;</div><div class=\"line\">\t<span class=\"attribute\">border</span>: <span class=\"number\">5px</span> solid <span class=\"number\">#000</span>;</div><div class=\"line\">\t<span class=\"attribute\">overflow</span>: hidden;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// HTML代码</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrapper\"</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure><br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/BFC8.png\" alt=\"margin重叠\"><br>再来一个添加”float:left;”的效果图<br><img src=\"http://7xkj1z.com1.z0.glb.clouddn.com/BFC9.png\" alt=\"margin重叠\"><br>注意：利用BFC清除浮动其实有很多问题<br>position:relative 在这里不会清除浮动，不细说。<br>position:absolute 将父容器的定位都改变了，在开发中这不是一个很好的做法。<br>float: left 也是同理，虽然清除了子元素的浮动，却给父元素添加了浮动，如果不是特殊需要，这种方法也不是一个好的方法。<br>overflow: hidden 有一个致命的问题，如果内容超出父容器或定位到父容器，就不会被看到，而且它不是按宽高撑开的。<br>display: inline-block 在IE6 和IE7中没有这个属性值，所以行不通。<br>补充: IE6 和 IE7 中清除浮动，我们需要触发其中的hasLayout为true，hasLayout为true就相当于BFC，那么怎么触发呢？只要将zoom设置为不为0的值。（zoom值为同比例缩放）,下面是css hack解决方式(开发中尽量避免css hack)。<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">/* CSS代码 */</div><div class=\"line\">.content1&#123;</div><div class=\"line\">\theight: 100px;</div><div class=\"line\">\twidth: 100px;</div><div class=\"line\">\tbackground-color: red;</div><div class=\"line\">\tfloat: left;</div><div class=\"line\">&#125;</div><div class=\"line\">.wrapper&#123;</div><div class=\"line\">\tborder: 5px solid #000;</div><div class=\"line\">\toverflow: hidden;</div><div class=\"line\">\t_zoom: 1;\tIE6</div><div class=\"line\">\t*zoom: 1; \tIE6/7</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// HTML代码</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrapper\"</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<hr>\n<p>BFC的一些常见的简单应用就写到这里，可能后续还会有补充。关于BFC详细原理可以自己查一下，网上有很多介绍。有什么问题欢迎评论！</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"ciuyzlusd0000e6tb8paarqu1","category_id":"ciuyzlust0003e6tbm48nq62p","_id":"ciuyzlutj000ce6tbzc7pfu7f"},{"post_id":"ciuyzlusp0002e6tb3cpuk7tt","category_id":"ciuyzlut90008e6tbrhbcxtjm","_id":"ciuyzlutw000ke6tbc33r5gqg"},{"post_id":"ciuyzlut00005e6tb1i3zhwhb","category_id":"ciuyzluto000ee6tb1haabqz1","_id":"ciuyzluu4000re6tbdedhm9og"},{"post_id":"ciuyzlut50006e6tba56fanwy","category_id":"ciuyzlut90008e6tbrhbcxtjm","_id":"ciuyzluuc000ye6tbyu95s9zm"},{"post_id":"ciuyzluu3000pe6tbrzm2s360","category_id":"ciuyzlust0003e6tbm48nq62p","_id":"ciuyzluue0013e6tburntktyb"},{"post_id":"ciuyzlut80007e6tb8rrvgpfm","category_id":"ciuyzluu6000te6tbi9zagdla","_id":"ciuyzluum0015e6tbbpe37nap"},{"post_id":"ciuyzlutb000be6tbxnk36rzx","category_id":"ciuyzluuc0010e6tb4mhd20z6","_id":"ciuyzluux001ee6tbci2uhjjx"},{"post_id":"ciuyzlutl000de6tbxw9ys7yp","category_id":"ciuyzluuq0019e6tbvf7x03do","_id":"ciuyzluva001me6tbdduh5nw9"},{"post_id":"ciuyzluts000he6tbw7vph5ua","category_id":"ciuyzluv0001ge6tbrmg3rtdj","_id":"ciuyzluvq001te6tbtvm7ylnm"},{"post_id":"ciuyzlutu000je6tb3d6w3wcf","category_id":"ciuyzluvd001ne6tbeka8scnr","_id":"ciuyzluvy001ye6tbr7j6jgbk"},{"post_id":"ciuyzluu9000ue6tbprmhuf17","category_id":"ciuyzluvs001ve6tbzt1t8ncg","_id":"ciuyzluw00023e6tbu5e4ju0q"},{"post_id":"ciuyzluub000we6tb8iswmb3r","category_id":"ciuyzluvz0020e6tb2iphli38","_id":"ciuyzluw20027e6tbrd2q8nnf"},{"post_id":"ciuyzluud0011e6tbmn3af4yd","category_id":"ciuyzluvs001ve6tbzt1t8ncg","_id":"ciuyzluw40029e6tbfyr78t5s"},{"post_id":"ciuyzluuh0014e6tbq0ox48g5","category_id":"ciuyzluw20028e6tbc7dvlshn","_id":"ciuyzluw6002be6tbicglgyvm"},{"post_id":"ciuyzluuo0018e6tbkzbk1tjk","category_id":"ciuyzluw4002ae6tbrd523146","_id":"ciuyzluw7002de6tb0x8bsfr4"},{"post_id":"ciuyzluus001be6tbdwtlvx3w","category_id":"ciuyzluw6002ce6tbypno09v3","_id":"ciuyzluw8002fe6tbn8vzv59y"},{"post_id":"ciuyzluux001fe6tbqa00ujcb","category_id":"ciuyzluw7002ee6tbeynciu8v","_id":"ciuyzluw9002he6tbvjhl09go"},{"post_id":"ciuyzluv3001ie6tbdf7qaa0q","category_id":"ciuyzluw8002ge6tbu7g9kdee","_id":"ciuyzluwb002je6tbvlr4qhrt"},{"post_id":"ciuyzluv7001le6tb2yiw9ute","category_id":"ciuyzluwa002ie6tbpiu9dzrg","_id":"ciuyzluwb002le6tb7o0iy9wq"},{"post_id":"ciuyzluvf001pe6tbc7nmbmkg","category_id":"ciuyzluwb002ke6tbcul6lygg","_id":"ciuyzluwc002ne6tbmqk0djxn"},{"post_id":"ciuyzluvo001se6tbd1mca9cn","category_id":"ciuyzluwc002me6tblmmjrxu9","_id":"ciuyzluwd002oe6tb92sysl3b"}],"PostTag":[{"post_id":"ciuyzlusd0000e6tb8paarqu1","tag_id":"ciuyzlusz0004e6tb5vhqv57o","_id":"ciuyzluta000ae6tbloc7zc4r"},{"post_id":"ciuyzlutb000be6tbxnk36rzx","tag_id":"ciuyzlut90009e6tbr3nnw7w2","_id":"ciuyzlutr000ge6tbp6p1jeri"},{"post_id":"ciuyzlusp0002e6tb3cpuk7tt","tag_id":"ciuyzlut90009e6tbr3nnw7w2","_id":"ciuyzlutt000ie6tb81e2xzd6"},{"post_id":"ciuyzlut00005e6tb1i3zhwhb","tag_id":"ciuyzlut90009e6tbr3nnw7w2","_id":"ciuyzluu1000oe6tbb50or2jr"},{"post_id":"ciuyzlutu000je6tb3d6w3wcf","tag_id":"ciuyzlusz0004e6tb5vhqv57o","_id":"ciuyzluu4000qe6tbz094ibsx"},{"post_id":"ciuyzlut50006e6tba56fanwy","tag_id":"ciuyzlut90009e6tbr3nnw7w2","_id":"ciuyzluua000ve6tbmbxlnij5"},{"post_id":"ciuyzluu3000pe6tbrzm2s360","tag_id":"ciuyzlusz0004e6tb5vhqv57o","_id":"ciuyzluuc000xe6tbt2rok2x1"},{"post_id":"ciuyzlut80007e6tb8rrvgpfm","tag_id":"ciuyzlut90009e6tbr3nnw7w2","_id":"ciuyzluue0012e6tb5x055f96"},{"post_id":"ciuyzluud0011e6tbmn3af4yd","tag_id":"ciuyzluuc000ze6tbhxhwxm53","_id":"ciuyzluun0017e6tbslyeabks"},{"post_id":"ciuyzlutl000de6tbxw9ys7yp","tag_id":"ciuyzluuc000ze6tbhxhwxm53","_id":"ciuyzluus001ae6tbrhcarp6d"},{"post_id":"ciuyzluuh0014e6tbq0ox48g5","tag_id":"ciuyzluuc000ze6tbhxhwxm53","_id":"ciuyzluuw001de6tb9zxc10pe"},{"post_id":"ciuyzluuo0018e6tbkzbk1tjk","tag_id":"ciuyzluuc000ze6tbhxhwxm53","_id":"ciuyzluv2001he6tbubw1k69x"},{"post_id":"ciuyzluts000he6tbw7vph5ua","tag_id":"ciuyzluuc000ze6tbhxhwxm53","_id":"ciuyzluv6001je6tb0juuqcne"},{"post_id":"ciuyzluus001be6tbdwtlvx3w","tag_id":"ciuyzluuc000ze6tbhxhwxm53","_id":"ciuyzluve001oe6tboj87megp"},{"post_id":"ciuyzluux001fe6tbqa00ujcb","tag_id":"ciuyzluuc000ze6tbhxhwxm53","_id":"ciuyzluvm001qe6tbiif2pm4m"},{"post_id":"ciuyzlutz000ne6tbjhsfl8mu","tag_id":"ciuyzluuw001ce6tbvb7mjfsj","_id":"ciuyzluvr001ue6tbqhqicjvg"},{"post_id":"ciuyzluv3001ie6tbdf7qaa0q","tag_id":"ciuyzluuc000ze6tbhxhwxm53","_id":"ciuyzluvv001we6tb30su7wge"},{"post_id":"ciuyzluv7001le6tb2yiw9ute","tag_id":"ciuyzluuc000ze6tbhxhwxm53","_id":"ciuyzluvz001ze6tbtcgtc2ph"},{"post_id":"ciuyzluu9000ue6tbprmhuf17","tag_id":"ciuyzluuc000ze6tbhxhwxm53","_id":"ciuyzluw00021e6tbfp7yc2ev"},{"post_id":"ciuyzluvf001pe6tbc7nmbmkg","tag_id":"ciuyzluuc000ze6tbhxhwxm53","_id":"ciuyzluw00022e6tbw7ls0l79"},{"post_id":"ciuyzluub000we6tb8iswmb3r","tag_id":"ciuyzluuc000ze6tbhxhwxm53","_id":"ciuyzluw10025e6tbbmprx0ui"},{"post_id":"ciuyzluvo001se6tbd1mca9cn","tag_id":"ciuyzluvw001xe6tbc74vez3z","_id":"ciuyzluw20026e6tb9v2jnin4"}],"Tag":[{"name":"hexo","_id":"ciuyzlusz0004e6tb5vhqv57o"},{"name":"兼容性","_id":"ciuyzlut90009e6tbr3nnw7w2"},{"name":"高性能JavaScript学习笔记","_id":"ciuyzluuc000ze6tbhxhwxm53"},{"name":"没事瞎扯","_id":"ciuyzluuw001ce6tbvb7mjfsj"},{"name":"CSS","_id":"ciuyzluvw001xe6tbc74vez3z"}]}}